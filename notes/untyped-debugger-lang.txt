Various parts of the language, including function calls, lambda
syntaxes, and control flow constructs take an additional argument,
which is a hint for the debugger. This hint can specify information
for entries in a log file, for frames in a stack trace, for levels of
verbosity in a stack trace, and for other purposes:

- Arbitrary information for application-specific debugging support.
- Handles to state resources that are considered external to the
  program (i.e. outliving the program).
- Acceptable criteria for an alternate way to resume the program (e.g.
  a type and unit test suite for any debugger-inserted function
  result).
- Inhibitors for tail call elimination.
- Hints about whether the program may be experiencing a non-"stuck"
  error (e.g. using more stack frames or allocations than
  anticipated).

In "<expr [] lin1 lin2 L1 L2 ; nl1 nl2 NL1 NL2>", the capitalized
tokens represent sets of variables. The variables that come before the
semicolon are linear (usable exactly once), while the rest are
nonlinear (usable zero, one, or more times).

The brackets "[]" contain a sequence of continuation types, and
sometimes they contain the capitalized variable "W" representing an
arbitrary subsequence. The types are `hinted`, `yields`, and
`coroutine-output`.

<expr [] var ; NL> ::= (get var)
<expr [] ; var NL> ::= (get var)
<expr [W] L1 L2 ; NL> ::=
  (let <hint NL (error description)> x <expr [] L1 ; NL>
    <expr [W] L2 ; x NL>)
  -- May result in an error if `x` is used nonlinearly and would be
  -- bound to a linear value.
<expr [yields W] L1 L2 ; NL> ::=
  (let-yields <hint NL (error description)> x <expr [yields] L1 ; NL>
    <expr [yields W] L2 ; x NL>)
  -- May result in an error if `x` is used nonlinearly and would be
  -- bound to a linear value.
<expr [] L1 L2 ; NL> ::=
  (call <hint NL (error description)>
    <expr [] L1 ; NL (function)> <expr [] L2 ; NL (args)>)
  -- May result in an error if a non-(fn ...) is called, or if the
  -- args are linear and the function's `sealed-args` is used
  -- nonlinearly.
<expr [yields] L1 L2 L3 ; NL> ::=
  (yields-call <hint NL (error description)>
    <expr [yields] L1 ; NL (function)> <expr [yields] L2 ; NL (args)>)
  -- May result in an error if a non-(yields-fn ...) is called, or if
  -- the args are linear and the function's `sealed-args` is used
  -- nonlinearly.
<expr [W] L ; NL> ::= (hints <hint NL> <expr [hinted W] L ; NL>)
<expr [yields W] L ; NL> ::=
  (yields-hints <hint NL> <expr [yields hinted W] L ; NL>)
<expr [] L ; NL> ::=
  (fn <hint NL (hint for memory inspector)>
    (sealed-vars-to-capture ...) sealed-args
    <expr [hinted hinted] L ; sealed-args NL>)
  -- NOTE: This results in a linear value if `L` is nonempty or if any
  -- of the `sealed-vars-to-capture` is linear.
<expr [] L ; NL> ::=
  (yields-fn <hint NL (hint for memory inspector)>
    (sealed-vars-to-capture ...) sealed-args
    <expr [hinted yields hinted] L ; sealed-args NL>)
  -- NOTE: This results in a linear value if `L` is nonempty or if any
  -- of the `sealed-vars-to-capture` is linear.
<expr [yields W] L ; NL> ::= (yieldless <expr [W] L ; NL>)
<expr [coroutine-output] L1 L2 ; NL> ::=
  (coroutine-output <hint NL (coroutine exit hint)>
    <expr [] L1 ; NL (parent coroutine)>
    <expr [] L2 ; NL (main output)>)
  -- May result in an error if the parent coroutine isn't the right
  -- coroutine.
<expr [hinted W] L ; NL> ::= (hinted <hint NL> <expr [W] L ; NL>)
<expr [W] sealed-x L ; NL> ::=
  (unseal x sealed-x <hint NL> <expr [hinted W] x L ; NL>)
<expr [W] L ; sealed-x NL> ::=
  (unseal x sealed-x <hint x NL> <expr [hinted W] L ; x NL>)
  -- NOTE: By designing the language so a function's `sealed-args`
  -- must be passed through (unseal ...) before use, we make it so the
  -- function's implementation in between can have an arbitrary amount
  -- of abstraction without hogging the stack trace.
<expr [yields W] L1 L2 L3 ; NL> ::=
  (yield <hint NL (yield entry hint)>
    coroutine-after result
    <expr [] L1 ; NL (coroutine before)>
    <expr [hinted] L2 ; NL (coroutine input)>
    <expr [hinted yields W] coroutine-after L3 ; result NL>)
  -- May result in an error if the coroutine is complete, if it isn't
  -- a coroutine, or if it's a coroutine outside the sandbox. May also
  -- result in an error if `result` or the coroutine's
  -- `first-coroutine-input` is used nonlinearly and would be bound to
  -- a linear value.
<expr [yields W] L1 L2 L3 ; NL> ::=
  (yield-last <hint NL (yield entry hint)>
    result
    <expr [] L1 ; NL (coroutine)>
    <expr [hinted] L2 ; NL (coroutine input)>
    <expr [hinted yields W] L3 ; result NL>)
  -- May result in an error if the coroutine yields again rather than
  -- completing, if it isn't a coroutine, or if it's a coroutine
  -- outside the sandbox. May also result in an error if `result` or
  -- the coroutine's `first-coroutine-input` is used nonlinearly and
  -- would be bound to a linear value.
<expr [W] L1 ; NL> ::= (yields-sandbox <expr [yields W] L1 ; NL>)
<expr [yields] L ; NL> ::=
  (coroutine <hint NL (hint for memory inspector)>
    (sealed-vars-to-capture ...)
    parent-coroutine first-coroutine-input
    <expr [yields coroutine-output]
      parent-coroutine L ; first-coroutine-input NL>)
  -- Returns a linear value.
<expr [yields W] L ; NL> ::=
  (make-demand-monitor demander monitor
    <expr [yields W] demander monitor L ; NL>)
  -- TODO: Figure out what hints we might want for demand monitors.
<expr [yields W] L1 L2 ; NL> ::=
  (drop-demander <hint NL (error description)>
    <expr [yields] L1 ; NL>
    <expr [yields W] L2 ; NL>)
  -- May result in an error if the demander isn't a demander, or if
  -- it's a demander outside the sandbox.
<expr [yields W] L1 L2 ; NL> ::=
  (split-demander <hint NL (error description)>
    demander-prefix demander-suffix <expr [yields] L1 ; NL>
    <expr [yields W] demander-prefix demander-suffix L2 ; NL>)
  -- The list of demands for the two split-off demanders are
  -- concatenated in order to determine the list of demands for the
  -- original demander.
  --
  -- May result in an error if the demander isn't a demander, or if
  -- it's a demander outside the sandbox.
<expr [yields W] L1 L2 L3 ; NL> ::=
  (demand <hint NL (error description)>
    <expr [yields] L1 ; NL (demander)>
    <expr [yields] L2 ; NL (demand)>
    <expr [yields W] L3 ; NL (afterward)>)
  -- May result in an error if the demander isn't a demander, or if
  -- it's a demander outside the sandbox.
<expr [yields] L1 L2 ; NL> ::=
  (monitor-fold <expr [yields] L1 ; NL (monitor)>
    <expr [yields] L2 ; NL (fold init)>
    first rest <expr [yields] ; first rest NL (fold loop)>)
  -- Waits for the demand monitor to complete, and then returns the
  -- full list of demands, as folded by the given loop.
  --
  -- May result in an error if the monitor isn't a monitor, or if it's
  -- a monitor outside the sandbox. May also result in an error if
  -- `first` or `rest` is used nonlinearly and would be bound to a
  -- linear value.

<hint NL> ::= (no-hint)
<hint NL> ::= (expr <expr [] ; NL>)


Notice that the expressions (coroutine ...) and
(make-demand-monitor ...) can be used in a completely nonlinear
context, but still introduce linear variables. Because of this, linear
variables still make a showing in the language even if no linear
variables are used in the program's top level or I/O.

Notice that in this language, the nesting of CPS-style abstractions
can be visualized a lot like non-CPS nested function calls thanks to
(unseal ...). And thanks to coroutines, certain implementations of
language interpreters written in this language can inherit this
language's debugger support without hogging the main stack!