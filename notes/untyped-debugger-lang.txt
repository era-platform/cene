Various parts of the language, including function calls, lambda
syntaxes, and control flow constructs take an additional argument,
which is a hint for the debugger. This hint can specify information
for entries in a log file, for frames in a stack trace, for levels of
verbosity in a stack trace, and for other purposes:

- Arbitrary information for application-specific debugging support.
- Handles to state resources that are considered external to the
  program (i.e. outliving the program).
- Acceptable criteria for an alternate way to resume the program (e.g.
  a type and unit test suite for any debugger-inserted function
  result).
- Inhibitors for tail call elimination.
- Hints about whether the program may be experiencing a non-"stuck"
  error (e.g. using more stack frames or allocations than
  anticipated).

In "<expr [] lin1 lin2 L1 L2 ; nl1 nl2 NL1 NL2>", the capitalized
tokens represent sets of variables. The variables that come before the
semicolon are linear (usable exactly once), while the rest are
nonlinear (usable zero, one, or more times).

The brackets "[]" contain a sequence of continuation types, and
sometimes they contain the capitalized variable "W" representing an
arbitrary subsequence. The types are `hinted`, `yields`,
`coroutine-main-output`, and `coroutine-child-output`.

<expr [] var ; NL> ::= (get var)
<expr [] ; var NL> ::= (get var)
<expr [] L1 L2 ; NL> ::=
  (call <hint NL (error description)>
    <expr [] L1 ; NL (function)> <expr [] L2 ; NL (args)>)
  -- May result in an error if a non-(fn ...) is called, or if the
  -- args are linear and the function's `sealed-args` is used
  -- nonlinearly.
<expr [yields W] L1 L2 L3 ; NL> ::=
  (yields-call <hint NL (error description)>
    result <expr [] L1 ; NL (function)> <expr [] L2 ; NL (args)>
    <expr [yields W] L3 ; result NL (afterward)>)
  -- May result in an error if a non-(yields-fn ...) is called, or if
  -- the args are linear and the function's `sealed-args` is used
  -- nonlinearly. May also result in an error if `result` is used
  -- nonlinearly and would be bound to a linear value.
<expr [W] L ; NL> ::= (hints <hint NL> <expr [hinted W] L ; NL>)
<expr [yields W] L ; NL> ::=
  (yields-hints <hint NL> <expr [yields hinted W] L ; NL>)
<expr [] L1 L2 ; NL> ::=
  (fn <hint NL (hint for memory inspector)>
    captured <expr [] L1 NL> (sealed-vars-to-capture ...) sealed-args
    <hint sealed-args NL>
    <expr [hinted] captured L2 ; sealed-args NL>)
  -- NOTE: This results in a linear value if `L1` is nonempty or if
  -- any of the `sealed-vars-to-capture` is linear.
<expr [] L1 L2 ; NL> ::=
  (yields-fn <hint NL (hint for memory inspector)>
    captured <expr [] L1 NL> (sealed-vars-to-capture ...) sealed-args
    <hint sealed-args NL>
    <expr [yields hinted] captured L2 ; sealed-args NL>)
  -- NOTE: This results in a linear value if `L1` is nonempty or if
  -- any of the `sealed-vars-to-capture` is linear.
<expr [yields W] L ; NL> ::= (yields <expr [W] L ; NL>)
<expr [coroutine-main-output] L1 L2 L3 ; NL> ::=
  (coroutine-main-output
    <expr [] L1 ; NL (child coroutine)>
    <expr [] L2 ; NL (last child coroutine input)>
    <expr [] L3 ; NL (main output)>)
<expr [coroutine-child-output] L1 L2 ; NL> ::=
  (coroutine-child-output
    <expr [] L1 ; NL (parent coroutine)>
    <expr [] L2 ; NL (main output)>)
<expr [hinted W] L ; NL> ::= (hinted <hint NL> <expr [W] L ; NL>)
<expr [W] sealed-x L ; NL> ::=
  (unseal x sealed-x <hint NL> <expr [hinted W] x L ; NL>)
<expr [W] L ; sealed-x NL> ::=
  (unseal x sealed-x <hint x NL> <expr [hinted W] L ; x NL>)
  -- NOTE: By designing the language so a function's `sealed-args`
  -- must be passed through (unseal ...) before use, we make it so the
  -- function's implementation in between can have an arbitrary amount
  -- of abstraction without hogging the stack trace.
<expr [yields W] L1 L2 L3 ; NL> ::=
  (yield <hint NL (yield entry hint)>
    coroutine-after result
    <expr [] L1 ; NL (coroutine before)>
    <expr [hinted] L2 ; NL (coroutine input)>
    <hint result NL (yield exit hint)>
    <expr [yields W] coroutine-after L3 ; result NL>)
  -- May result in an error if the coroutine is complete or if it
  -- isn't a coroutine. May also result in an error if `result` is
  -- used nonlinearly and would be bound to a linear value.
<expr [W] L1 L2 L3 ; NL> ::=
  (start-coroutine <hint NL (coroutine entry hint)>
    child-coroutine parent-coroutine first-child-coroutine-input
    <expr [yields hinted coroutine-child-output]
      parent-coroutine L1 ; first-child-coroutine-input NL
      (child coroutine computation)>
    child-coroutine-output main-output
    <expr [yields hinted coroutine-main-output]
      child-coroutine L2 ; NL
      (main computation)>
    <expr [W] L3 ; child-coroutine-output main-output NL (afterward)>)
  -- May result in an error if giving the last coroutine input to the
  -- child coroutine causes it to yield again rather than completing.
  -- May also result in an error if `first-child-coroutine-input`,
  -- `child-coroutine-output`, or `main-output` is used nonlinearly
  -- and would be bound to a linear value.
  --
  -- NOTE: Notice that this expression can be used in a completely
  -- nonlinear context, but still introduces linear variables and the
  -- `yields` continuation type internally. Because of this, the other
  -- language features that use linear variables and `yields` still
  -- matter even if no linear variables or `yields` continuations are
  -- used in the program's top level or I/O.

<hint NL> ::= (no-hint)
<hint NL> ::= (expr <expr [] ; NL>)

Notice that despite the coroutine feature, the only actual side
effects are nontermination, getting stuck, and (non-semantic) resource
starvation. In normal languages, a call trace for a heavily
tail-recursive computation has far fewer exit logs than entry logs, so
it's about as flat as an imperative log -- flatter even, because it
can only nest for pure abstractions. In this language, the nesting of
CPS-style imperative abstractions can be visualized thanks to
(unseal ...). Thanks to coroutines, the debugger's imperative metaphor
will already be amenable to any additional imperative I/O primitives
needed, including cooperative multithreading and debugger-inserted
hooks for interfering with the usual semantics.
