Various parts of the language, including function calls, lambda
syntaxes, and control flow constructs take an additional argument,
which is a hint for the debugger. This hint can specify information
for entries in a log file, for frames in a stack trace, for levels of
verbosity in a stack trace, and for other purposes:

- Arbitrary information for application-specific debugging support.
  - NOTE: It would seem useful but challenging for this information
    to refer to state resources that are considered external to the
    program (i.e. outliving the program).
- Acceptable criteria for an alternate way to resume the program (e.g.
  a type and unit test suite for any debugger-inserted function
  result).
- Inhibitors for tail call elimination.
- Hints about whether the program may be experiencing a non-"stuck"
  error (e.g. using more stack frames or allocations than
  anticipated).

In "<expr [] lin1 lin2 L1 L2 ; nl1 nl2 NL1 NL2>", the capitalized
tokens represent sets of variables. The variables that come before the
semicolon are linear (usable exactly once), while the rest are
nonlinear (usable zero, one, or more times).

The brackets "[]" contain a sequence of continuation types, and
sometimes they contain the capitalized variable "W" representing an
arbitrary subsequence. The types are `*`, `hint`, and `hinted`.

<expr [*] ; NL> ::= (done)
<expr [] var ; NL> ::= (get var)
<expr [] ; var NL> ::= (get var)
<expr [W] L1 L2 ; NL> ::=
  (let <expr [hint] ; NL (error description)> x <expr [] L1 ; NL>
    <expr [W] L2 ; x NL>)
  -- May result in an error if `x` is used nonlinearly and would be
  -- bound to a linear value.
<expr [W] L1 L2 ; NL> ::= (do <expr [*] L1 ; NL> <expr [W] L2 ; NL>)
<expr [] L1 L2 ; NL> ::=
  (call <expr [hint] ; NL (error description)>
    <expr [] L1 ; NL (function)> <expr [] L2 ; NL (args)>)
  -- May result in an error if a non-(fn ...) is called, or if the
  -- args are linear and the function's `sealed-args` is used
  -- nonlinearly.
<expr [W] L ; NL> ::=
  (hints <expr [hint] ; NL> <expr [hinted W] L ; NL>)
<expr [] L ; NL> ::=
  (fn <expr [hint] ; NL (hint for memory inspector)>
    (sealed-vars-to-capture ...) sealed-args
    <expr [hinted hinted] L ; sealed-args NL
      (body with entry and exit hints)>)
  -- NOTE: This results in a linear value if `L` is nonempty or if any
  -- of the `sealed-vars-to-capture` is linear.
<expr [hinted W] L ; NL> ::=
  (hinted <expr [hint] ; NL> <expr [W] L ; NL>)
<expr [W] sealed-x L ; NL> ::=
  (unseal x sealed-x
    <expr [hinted hinted W] x L ; NL
      (body with entry and exit hints)>)
<expr [W] L ; sealed-x NL> ::=
  (unseal x sealed-x
    <expr [hinted hinted W] L ; x NL
      (body with entry and exit hints)>)
  -- NOTE: By designing the language so a function's `sealed-args`
  -- must be passed through (unseal ...) before use, we make it so the
  -- function's implementation in between can have an arbitrary amount
  -- of abstraction without hogging the stack trace.
<expr [W] L1 L2 L3 ; NL> ::=
  (yield <expr [hint] ; NL (yield emigration hint)>
    <expr [] L1 ; NL (coroutine before)>
    <expr [] L2 ; NL (coroutine input)>
    coroutine-after result
    <expr [hinted W] coroutine-after L3 ; result NL
      (afterward with yield immigration hint)>)
  -- May result in an error if the coroutine isn't a coroutine, isn't
  -- waiting for input, or doesn't call (yield ...) in response. May
  -- also result in an error if `result` or the coroutine's own input
  -- variable is used nonlinearly and would be bound to a linear
  -- value.
<expr [W] L1 L2 L3 ; NL> ::=
  (yield-request-drop <expr [hint] ; NL (yield emigration hint)>
    result
    <expr [] L1 ; NL (coroutine)>
    <expr [] L2 ; NL (coroutine input)>
    <expr [hinted W] L3 ; result NL
      (afterward with yield immigration hint)>)
  -- May result in an error if the coroutine isn't a coroutine, isn't
  -- waiting for input, or doesn't call (yield-and-drop ...) in
  -- response. May also result in an error if `result` or the
  -- coroutine's own input variable is used nonlinearly and would be
  -- bound to a linear value.
<expr [*] L1 L2 ; NL> ::=
  (yield-and-drop <expr [hint] ; NL (coroutine exit hint)>
    <expr [] L1 ; NL (parent coroutine)>
    <expr [] L2 ; NL (parent coroutine finally input)>
    <expr [] L2 ; NL (parent coroutine client input)>)
  -- Passes one value to the `finally-result-1` or `finally-result-2`
  -- variable of (yield-and-split ...) or the `finally-result`
  -- variable of (coroutine ...), and passes another value to the
  -- `result` variable of (yield-request-drop ...).
  --
  -- May result in an error if the parent coroutine isn't the right
  -- coroutine or if it isn't waiting on a (yield-request-drop ...).
  -- May also result in an error if either of the input variables is
  -- used nonlinearly and would be bound to a linear value.
<expr [W] L1 L2 L3 ; NL> ::=
  (yield-request-split <expr [hint] ; NL (yield emigration hint)>
    coroutine-after-1 coroutine-after-2 result
    <expr [] L1 ; NL (coroutine)>
    <expr [] L2 ; NL (coroutine input)>
    <expr [hinted W]
      coroutine-after-1 coroutine-after-2 L3 ; result NL
      (afterward with yield immigration hint)>)
  -- May result in an error if the coroutine isn't a coroutine, isn't
  -- waiting for input, or doesn't call (yield-and-split ...) in
  -- response. May also result in an error if `result` or the
  -- coroutine's own input variable is used nonlinearly and would be
  -- bound to a linear value.
<expr [W] L1 L2 L3 L4 L5 ; NL> ::=
  (yield-and-split <expr [hint] ; NL (coroutine exit hint)>
    <expr [] L1 ; NL (parent coroutine)>
    <expr [] L2 ; NL (parent coroutine input)>
    parent-coroutine-1 branch-input-1
    <expr [hinted *] parent-coroutine-1 L3 ; branch-input-1 NL
      (branch with yield immigration hint)>
    parent-coroutine-2 branch-input-2
    <expr [hinted *] parent-coroutine-2 L4 ; branch-input-2 NL
      (branch with yield immigration hint)>
    parent-coroutine-merged finally-result-1 finally-result-2
    <expr [hinted W]
      parent-coroutine-merged L5 ;
      finally-result-1 finally-result-2 NL
      (afterward with yield immigration hint)>)
  -- Sends two new coroutine handles instead of one, and eventually
  -- synchronizes into a single computation again. The values of
  -- `finally-result-1` and `finally-result-2` are the finally inputs
  -- of (yield-and-drop ...) for `parent-coroutine-1` and
  -- `parent-coroutine-2`.
  --
  -- May result in an error if the parent coroutine isn't the right
  -- coroutine or if it isn't waiting on a (yield-request-split ...).
  -- May also result in an error if `branch-input-1`,
  -- `branch-input-2`, `branch-result-1`, `branch-result-2`, or the
  -- coroutine's own input variable is used nonlinearly and would be
  -- bound to a linear value.
<expr [] L1 L2 ; NL> ::=
  (coroutine <expr [hint] ; NL (hint for memory inspector)>
    (sealed-vars-to-capture ...)
    parent-coroutine first-coroutine-input
    <expr [*] parent-coroutine L1 ; first-coroutine-input NL>
    finally-result
    <expr [*] L2 ; finally-result NL>)
  -- Returns a linear value.
<expr [hint] ; NL> ::= (no-hint)
<expr [hint] L ; NL> ::= (hint <expr [] L ; NL>)


Notice that the expression (coroutine ...) can be used in a completely
nonlinear context, but still introduces linear variables. Because of
this, linear variables still make a showing in the language even if no
linear variables are used in the program's top level or I/O.

Notice that in this language, the nesting of CPS-style abstractions
can be visualized a lot like non-CPS nested function calls thanks to
(unseal ...). And thanks to coroutines, certain implementations of
language interpreters written in this language can inherit this
language's debugger support without hogging the main stack!