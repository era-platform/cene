\= NOTE: The abbreviation "sbound" stands for "syntax bound."

func (sbound-read unique-ns-to-spend sbound-to-spend (fn operator table-from-sbound-keys-to-unspent-sbounds))
\= When the sbound is a branch of an s-expression, reading from it gives an operator that's a list of sbound keys or an istring of sbound keys. This operation spends the `sbound` and the `unique-ns`.

\= TODO: Add a parameter to this that relates what procedure is responsible for constructing this syntax. We'll typically want to identify this down to the specific expression which returned this syntax. For syntax constructed by macro calls, we'll typically want to include the syntax region of the macro call, and that in turn will reference the syntax region of the macro call that created it, all the way up to whatever syntax was generated by a means other than macro call.
\= TODO: See what parameters we need to add to the `sbound-read` callback and the `def-macro` body so we can obtain attribution information to pass to this call.
\= TODO: See if we need to add a function to take the union of multiple syntax regions.
\= TODO: See if we need to add a function to obtain syntax regions related to a given sbound. We'll probably need this if we want to account for nested quasiquotation's ability to process an escape sequence, discover it doesn't make its way quite to the earliest qusiquotation stage, and then ignore its results and treat it as its original syntax data again.
\= TODO: See if we should not add special parameters for these after all, but instead carry these syntax regions around as part of the operator.
func (sbound-build operator table-from-sbound-keys-to-sbounds-to-spend (fn unspent-sbound))

(def-macro <macro-name> home-scope caller-scope operator table-from-sbound-keys-to-unspent-sbounds then
  ...)
\= ...where `then` is a function that takes an operator, takes a `table-from-sbound-keys-to-unspent-sbounds`, and returns a monadic action that writes those to a place where the caller can see them. The resulting operator usually takes the form of instructions as to what to do with the remaining leaves, along with a callback that will take the fully processed leaves and construct a cexpr. A cexpr itself is a syntactic artifact, and we'll want to attribute it to particular sections of source code.


\= The Cene syntax is compatible with future customization needs by the way it can be seen as a series of macro systems. Each one of these syntaxes macroexpands to the next:
\=
\=   - Textual syntax from start to end. (This can even be traversed from end to start by looking for \ [ ] ( or ) and scanning back a line to make sure it's not part of a \= line comment.)
\=   - Escape sequence suffix trees. (This is used as the syntax for string quasiquotation labels, for whitespace normalization control, and for various escape sequences representing text.)
\=   - S-expressions. (These are comprised of lists and interpolated strings.)
\=   - Compiled expressions (aka cexprs).
\=
\= If we add a quasiquotation macro system (or even a higher-order quasiquotation macro system), it can be an intermediate stage between s-expressions and compiled expressions. Ideally, we can implement this kind of additional layer as a library; `qq` itself would be an s-expression macro still, but it would call its own framework of s-expression macros that generate quasiquotation macros (and potentially higher-order quasiquotation macros) before finally expanding to something that computes a compiled expression.


\= Here's the existing macro calling convention for reference:

(def-macro <macro-name> home-scope caller-scope my-stx-details args then
  ...)
