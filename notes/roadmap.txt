Low-level Cene tasks, in roughly the order of the Sphinx documentation table of contents:


Update most of the various built-in macros that use `stxToMaybeName` to use `stxToObtainMethod`, so they can support `(foreign/obtain-directly <value>)`.

Consider whether `contributing-only-to` and the `committing-...` operations should perform their body a later tick. If so, name them `...-later`. Note that the current purpose of using multiple ticks is not because of error-handling behavior -- the later tick's errors must invalidate side effects of the current tick too -- but because each tick represents a moment that can block on concurrent definitions happening in another tick.
For better error message behavior, implement and use `committing-to-define` and `committing-to-define-function-implementations`.

Track syntax details better.

  - Make era-reader.js attach source location information to its output.
  - When a macro generates an expression, associate that expression with the location of the expression that generated it.

Now that tables expose their keys well enough to implement `procure-sub-ns-table` in terms of a single-key lookup, consider replacing it with a single-key lookup again.
Implement `read-all-force` instead of having it built in.
Right now, `read-all-force` is broken at the run time of a program generated by `picky-javascript-quine`, because it doesn't include era-reader.js. Have `picky-javascript-quine` include era-reader.js if and only if `read-all-force` is one of the constructors in use by the program.
Implement the `--command` command line option.

Add a way for `picky-javascript-quine` to be able to encode reified first-class values other than strings, using a user-supplied serializer. That way we have an excuse as to why some values (particularly strings) are supported and others aren't.
Make all the `js` code snippets execute in a specific order. Namely, sort their Unicode scalar sequences in lexicographic order. Do execute duplicates multiple times.

For better error message behavior, be more careful about what paths in a `unique-ns` a macro call uses. By convention, paths used during calls to two different macros shouldn't collide, and paths used during two calls to the same macro should only collide in circumstances that can be comprehensively documented. Here are some examples of paths that would work well for the built-in macros:

  <unique-ns>/($$claimed-for claim:struct)/<constructor tag>/projection/<projection name>/...
    \= NOTE: This is a macro corresponding to a built-in constructor.
  
  \= NOTE: The `err` macro doesn't need to use its `unique-ns` at all.
  
  \= NOTE: These are for the upcoming redesign of `err`, not the current version.
  <unique-ns>/($$claimed-for claim:primitive err)/source-location-tag/.name
  <unique-ns>/($$claimed-for claim:primitive err)/value-of-interest/(rest/)*first/...
  
  <unique-ns>/($$claimed-for claim:primitive cline-struct)/<constructor tag>/projection/<projection name>/...
  <unique-ns>/($$claimed-for claim:primitive merge-struct)/<constructor tag>/projection/<projection name>/...
  <unique-ns>/($$claimed-for claim:primitive fuse-struct)/<constructor tag>/projection/<projection name>/...
  <unique-ns>/($$claimed-for claim:primitive def-struct)/<main tag name and list of projection names>/main-tag/.name
  <unique-ns>/($$claimed-for claim:primitive def-struct)/<main tag name and list of projection names>/projection-tag/<projection name string>/.name
  <unique-ns>/($$claimed-for claim:primitive defn)/body/...
    \= NOTE: This sub-namespace is used for a `fn` call.
  <unique-ns>/($$claimed-for claim:primitive caselet)/subject/...
  <unique-ns>/($$claimed-for claim:primitive caselet)/final-else/...
    \= NOTE: This sub-namespace is only used for the final else.
  <unique-ns>/($$claimed-for claim:primitive caselet)/then/<constructor tag>/...
    \= NOTE: This sub-namespace is not used for the final else.
  <unique-ns>/($$claimed-for claim:primitive caselet)/else/...
    \= NOTE: This sub-namespace is not used for the final else.
    \= NOTE: This sub-namespace is used for a `caselet` call.
  <unique-ns>/($$claimed-for claim:primitive case)/<constructor tag>/subject-var/.name
  <unique-ns>/($$claimed-for claim:primitive case)/<constructor tag>/branches/...
    \= NOTE: This sub-namespace is used for a `caselet` call.
  <unique-ns>/($$claimed-for claim:primitive cast)/<constructor tag>/body/...
    \= NOTE: This sub-namespace is used for a `case` call.
  <unique-ns>/($$claimed-for claim:primitive c)/func/...
  <unique-ns>/($$claimed-for claim:primitive c)/arg/...
  <unique-ns>/($$claimed-for claim:primitive fn)/main-tag/.name
  <unique-ns>/($$claimed-for claim:primitive fn)/projection-tag/<free variable name>/.name
  <unique-ns>/($$claimed-for claim:primitive fn)/body/...
    \= NOTE: A `fn` also makes a definition in the function implementation namespace, keyed by the the constructor tag built out of the `main-tag` and `projection-tag` names indicated here.
  <unique-ns>/($$claimed-for claim:primitive test-async)/dex/...
  <unique-ns>/($$claimed-for claim:primitive test-async)/actual/...
  <unique-ns>/($$claimed-for claim:primitive test-async)/expected/...
  <unique-ns>/($$claimed-for claim:primitive def-macro)/body/...
    \= NOTE: This sub-namespace is used for a `fn` call.
  <unique-ns>/($$claimed-for claim:primitive let)/<set of variable names>/binding/<variable name>/...
  <unique-ns>/($$claimed-for claim:primitive let)/<set of variable names>/body/...
  \= NOTE: The `str` macro doesn't need to use its `unique-ns` at all.
  \= NOTE: The `js` macro doesn't need to use its `unique-ns` at all.



--------

High-level Cene tasks, in roughly highest-priority-first order:


- Try to implement an example of an extensible framework (such as multimethods) in terms of the various "contribute" primitives.

- Implement the live service API described in live-services.txt.

- For better error messages, redesign `stx` values and the way we deal with them so that we're more careful about tracking source locations.

- Let people write something like (err a b c \;qq[message]) to call `follow-heart` using a clamor consisting of (list a b c), `str.\;qq[message]`, and an empty struct tagged with a name unique to this source code location.

- Design a way for users to specify the implementation of `follow-heart` for a subcomputation.

- Design and implement a rich document format (ideally making the HTML ecosystem, plain text program code, and UI toolkits obsolete). A killer feature will be to have good support for keyboard navigation (if only for accessibility), selecting paren-unbalanced snippets, copying, and pasting.

- See if we should design a different approach to unit tests.

  - Perhaps the results should be installed as definitions somewhere.

  - Perhaps we should be able to control the order.

- Design and implement an approach to user-facing content localization. This is for arbitrary snippets of code, not just strings.

- Design and implement an approach to programmer-facing identifier and comment/whitespace localization.

- Write better documentation.

  - Finish documenting the built-in operations that don't have documentation yet.

  - Integrate the remaining documentation in docs.md into the docs. Especially focus on the part about the definition namespace layout.

- Implement a multi-backend compiler of Cene in Cene.

- See if we should offer a pure runner (like Haskell's ST monad) for `string-append-later` and similar side effects. Unfortunately, strings created inside such a runner could not be used outside until a later tick. They couldn't even be compared by `dex-string`, so they would hardly be strings at all. The runner could return an encapsulated value, but what would be the point? Maybe we would need another set of dex-like primitives to represent ways to export values from the runner. Exporting a string would usually force it, but there could be more than one way to export a string.

- Reduce the compiled code size of `picky-javascript-quine` a little further.

  - The `flatTag` of `cons` and other built-in structs takes up a lot of space. We can't minify it the way we minify user-defined structs' `flatTag` values, because that would break its interactions with the implementations of built-in primitives, but we can potentially replace each occurrence with a reference to a common variable.

  - Exclude the JavaScript code generation backend from programs that don't need it. Many parts of the Cene runtime could be conditionally excluded this way, but the JavaScript backend is particularly tempting to exclude because it contains string literals with unminified JavaScript code inside.

  - Help the user to minify (or even lint or transpile) their `js` code snippets. In order to keep the Cene build process deterministic itself, we'll want to pretend the minification happens "after" it. The least "pretend" way to do this is to generate an intermediate representation that isn't quite JavaScript, but is close enough that a user-supplied program can crawl it, minify the snippets as needed, and finish it up to make a full JavaScript program. Fortunately, there's little harm in being more informal about it.

- Design and implement a package manager with a simplistic module system.

- Devote some effort to polish and style.
