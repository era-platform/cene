Immediate actionable tasks:

Change `contributing-only-to` to accept a collection (e.g. a table) of namespaces-with-holes-in-them, rather than a single namespace.

Make all the built-in macros generate the `cexpr-...` values instead of generating their own JavaScript code directly. Once we do this, derive `compile-expression-later` from the `cexpr-...` primitives instead of having `compile-expression` built in.

Implement and use `committing-to-define` and `committing-to-define-function-implementations`.

Refactor the entire "File I/O for simple builds" system so that it looks like it could use namespaces, but doesn't actually use any sub-namespaces the Cene code has access to.

Revisit `output-path-directory`, `output-path-utf-8`, and especially `cli-output-environment-variable-shadow` to be sure they behave as though they contribute to a namespace the user-level Cene code has no access to. Right now, I think `cli-output-environment-variable-shadow` outputs to a visible place in the definition namespace.



-----

Other low-level Cene tasks, in roughly the order of the Sphinx documentation table of contents:


Update most of the various built-in macros that use `stxToMaybeName` to use `stxToObtainMethod`, so they can support `(foreign/obtain-directly <value>)`.

Consider renaming "mode" to "world" throughout.
See if there's any real point to calling things "...-later", since errors that happen in the "later" portion are escalated to invalidate the prior portion anyway. Maybe we even want the mode to remain current across these operations. That could make it confusing when some operations change the mode and others don't.
Consider renaming `test-async` to `test`.
Get rid of namespace shadowing, unless we decide we need it again to achieve local macros.
Consider renaming `contributing-only-to` and the `committing-...` operations to `...-later`, since they "change" the current mode.
Reconsider the parameters to `macro-stx-details`. The mode really should be the current mode if the call is going to do anything with `unique-ns` and `definition-ns`, but why does it need those? It would probably be more relevant for this value to reify the identity of the macro definition itself, or at least contain a struct with a tag unique to that macro definition.
Implement `read-all-force` instead of having it built in.
Consider making `int-compare` a dex, which would make it the first visibly ordered dex. If we ever want a merge for dexes, a dex like this could be a problem.
Implement the `--command` command line option.

Make a not-so-sloppy version of `sloppy-javascript-quine`. Namely, the implementation should walk the compiled expressions of the given struct tag's function implementation, find any constructor occurrences that occur in conditional locations that depend only on otherwise-seen constructor occurrences, and include all of their function definitions in the result. If any of their function definitions contain an embedded first-class value in a conditional location that depends only on seen constructor occurrences, those first-class values must be of only a few known constructors. (Add a way to extend the known constructors with any struct that the caller of this not-so-sloppy quine operation can deconstruct. That way we have an excuse as to why some values are supported and others aren't.)
Redesign `compile-function-js-effects` to a macro `js.\;qq[return 1 + 2;]` that creates a JavaScript effects value that executes the given code. The code is put into a `Function(...)` expression that's run at the time the program's JavaScript code first runs, rather than putting off the execution of `Function(...)` to the time these JavaScript effects are run. Hmm... One problem with this is that it's not well-defined what happens if more than one of these expressions has a syntax error.
Hmm. We probably want a way to construct JavaScript regexes at JavaScript load time too. We'll be able to do this in a sloppy way for a while, by generating compiled expressions that refer to macroexpansion-time first-class values, but maybe we should add another primitive so we don't have to mess with run time regexes until run time. Perhaps a macro `(js-early js-effects)` can cause the expression `js-effects` to be executed in an empty environment at compile time. Again, one problem with this is that it's not well-defined what happens if more than one of these expressions encounters an error.

For better error message behavior, be more careful about what paths in a `unique-ns` a macro call uses. By convention, paths used during calls to two different macros shouldn't collide, and paths used during two calls to the same macro should only collide in circumstances that can be comprehensively documented. Here are some examples of paths that would work well for the built-in macros:

  <unique-ns>/($$claimed-for claim:struct)/<constructor tag>/projection/<projection name>/...
    \= NOTE: This is a macro corresponding to a built-in constructor.
  
  \= NOTE: The `err` macro doesn't need to use its `unique-ns` at all.
  
  \= NOTE: These are for the upcoming redesign of `err`, not the current version.
  <unique-ns>/($$claimed-for claim:primitive err)/source-location-tag/.name
  <unique-ns>/($$claimed-for claim:primitive err)/value-of-interest/(rest/)*first/...
  
  <unique-ns>/($$claimed-for claim:primitive dex-struct)/<constructor tag>/projection/<projection name>/...
  <unique-ns>/($$claimed-for claim:primitive merge-struct)/<constructor tag>/projection/<projection name>/...
  <unique-ns>/($$claimed-for claim:primitive fuse-struct)/<constructor tag>/projection/<projection name>/...
  <unique-ns>/($$claimed-for claim:primitive def-struct)/<main tag name and list of projection names>/main-tag/.name
  <unique-ns>/($$claimed-for claim:primitive def-struct)/<main tag name and list of projection names>/projection-tag/<projection name string>/.name
  <unique-ns>/($$claimed-for claim:primitive defn)/body/...
    \= NOTE: This sub-namespace is used for a `fn` call.
  <unique-ns>/($$claimed-for claim:primitive caselet)/subject/...
  <unique-ns>/($$claimed-for claim:primitive caselet)/final-else/...
    \= NOTE: This sub-namespace is only used for the final else.
  <unique-ns>/($$claimed-for claim:primitive caselet)/then/<constructor tag>/...
    \= NOTE: This sub-namespace is not used for the final else.
  <unique-ns>/($$claimed-for claim:primitive caselet)/else/...
    \= NOTE: This sub-namespace is not used for the final else.
    \= NOTE: This sub-namespace is used for a `caselet` call.
  <unique-ns>/($$claimed-for claim:primitive case)/<constructor tag>/subject-var/.name
  <unique-ns>/($$claimed-for claim:primitive case)/<constructor tag>/branches/...
    \= NOTE: This sub-namespace is used for a `caselet` call.
  <unique-ns>/($$claimed-for claim:primitive cast)/<constructor tag>/body/...
    \= NOTE: This sub-namespace is used for a `case` call.
  <unique-ns>/($$claimed-for claim:primitive isa)/<constructor tag>/subject/...
  <unique-ns>/($$claimed-for claim:primitive isa)/<constructor tag>/projection-var/<projection name>/.name
  <unique-ns>/($$claimed-for claim:primitive c)/func/...
  <unique-ns>/($$claimed-for claim:primitive c)/arg/...
  <unique-ns>/($$claimed-for claim:primitive fn)/main-tag/.name
  <unique-ns>/($$claimed-for claim:primitive fn)/projection-tag/<free variable name>/.name
  <unique-ns>/($$claimed-for claim:primitive fn)/body/...
    \= NOTE: A `fn` also makes a definition in the function implementation namespace, keyed by the the constructor tag built out of the `main-tag` and `projection-tag` names indicated here.
  <unique-ns>/($$claimed-for claim:primitive test-async)/dex/...
  <unique-ns>/($$claimed-for claim:primitive test-async)/actual/...
  <unique-ns>/($$claimed-for claim:primitive test-async)/expected/...
  <unique-ns>/($$claimed-for claim:primitive def-macro)/body/...
    \= NOTE: This sub-namespace is used for a `fn` call.
  <unique-ns>/($$claimed-for claim:primitive let)/<set of variable names>/binding/<variable name>/...
  <unique-ns>/($$claimed-for claim:primitive let)/<set of variable names>/body/...
  \= NOTE: The `str` macro doesn't need to use its `unique-ns` at all.

Consider renaming "type" to "constructor", "struct", and/or "tag" throughout the error messages and variable names of era-cene-prelude.cene and other Cene code.



--------

High-level Cene tasks, in roughly highest-priority-first order:


- Try to implement an example of an extensible framework (such as multimethods) in terms of the various "contribute" primitives.

- Implement the live service API described in live-services.txt.

- Let people write something like (err a b c \;qq[message]) to call `follow-heart` using a clamor consisting of (list a b c), `str.\;qq[message]`, and an empty struct tagged with a name unique to this source code location.

- Design a way for users to specify the implementation of `follow-heart` for a subcomputation.

- Design and implement a rich document format (ideally making the HTML ecosystem, plain text program code, and UI toolkits obsolete). A killer feature will be to have good support for keyboard navigation (if only for accessibility), selecting paren-unbalanced snippets, copying, and pasting.

- See if we should design a different approach to unit tests.

  - Perhaps the results should be installed as definitions somewhere.

  - Perhaps we should be able to control the order.

- Design and implement an approach to user-facing content localization. This is for arbitrary snippets of code, not just strings.

- Design and implement an approach to programmer-facing identifier and comment/whitespace localization.

- Write better documentation.

  - Finish documenting the built-in operations that don't have documentation yet.

  - Integrate the remaining documentation in docs.md into the docs. Especially focus on the part about the definition namespace layout.

- Implement a multi-backend compiler of Cene in Cene.

- See if we should offer a pure runner (like Haskell's ST monad) for `string-append-later` and similar side effects. Unfortunately, strings created inside such a runner could not be used outside until a later tick. They couldn't even be compared by `dex-string`, so they would hardly be strings at all. The runner could return an encapsulated value, but what would be the point? Maybe we would need another set of dex-like primitives to represent ways to export values from the runner. Exporting a string would usually force it, but there could be more than one way to export a string.

- Have the compiler do a dead code elimination pass.

- Design and implement a package manager with a simplistic module system.

- Devote some effort to polish and style.
