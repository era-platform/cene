~~ Tenerezza design direction ~~

Every first-class value is a communication channel between people. It
can carry knowledge and extension modules back and forth. Aliasing a
channel simply means its incoming modules go to more than one place
and all those places' outgoing values go to the original channel.

(TODO: See if we want to accomplish that continuation-capable design.
Right now we do half: First-class values only carry incoming modules.
However, we sometimes use these incoming modules as functions, so we
can potentially say the function inputs count as outgoing modules.)

Along every communication channel, both sides can continuously
negotiate the allocation of extra state meant to be distributed
somewhere along that channel. As long as it has been allocated, this
extra state has associated communication channels it communicates
over. (TODO: Design the tech.)

Every computation has access to several channels:

- A "conscience" channel to consult for error-handling. The person at
  the other end of this channel should be assumed to have full access
  to the computation's source code and even full extra-semantic
  control over the computation hardware, so asking them for advice is
  really only a courtesy. (TODO: Design the tech. We could almost say
  the return value of a function is the conscience channel, so it
  might be a matter of picking idioms.)

- A channel representing a snapshot state of the state resource in
  which the computation is running. Even a constant-time,
  constant-space computation has a small amount of space allocated
  somewhere and a small amount of time to manipulate it, so this idiom
  can accommodate computation platforms of various computational
  complexity tolerances. (TODO: Design the tech.)

- Channels that represent this computation's ad hoc environment, its
  parameters, and/or its continuation.

Computations are mainly expected to take constant time and constant
space, expressing a nearly instantaneous reaction from incoming to
outgoing modules. Usually the computation will be executed over some
span of time so it can react to different inputs as time goes by. If a
computation needs to do more work than that, it should express that as
a request for stateful resources. However, because that use case is
commonly desired for convenience in programming, some language
syntaxes will be dedicated to generating and handling specific kinds
of requests. (NOTE: Right now those are (union ...) and (call ...),
which generate stack frames in the Tenerezza operation's result.)

The language will have a lot in common with Staccato, including its
constant-time-and-space-per-step semantics and its data/codata frames.
However, the stack will be a tree carrying multiple active frames at
any given time, and the data/codata frames will have cryptographic
restrictions on who can construct them and who can deconstruct them.

~~ Naming rationale ~~

"Tenerezza" is a term sometimes used in musical notation like
"Staccato," and it's Italian for "tenderness." This may suggest a lack
of hard technological obstacles getting in the way of person-to-person
communication, and it reflects the sweetness I want for those people.

~~ Tenerezza technical details ~~

A channel is a set of incoming modules and a set of outgoing modules.
Even if it's a mix of data and codata, it's like a set; the data and
codata have the nature of quantifiers like "for all producers" and
"for all consumers" surrounding the set. (At least, I suspect this is
so. If not, I may resort to modeling the incoming and outgoing sets as
separate first-class values.) (TODO: Design the tech. Right now we're
only modeling incoming sets, unless we count function call arguments
as outgoing values.)

Rudimentary set functions, safe recursive set functions, and primitive
recursive set functions are outlined here:

http://www.cl.eps.manchester.ac.uk/medialand/maths/archived-events/workshops/www.mims.manchester.ac.uk/events/workshops/LC2012/slides/beckmann.pdf

We're aiming for a system simultaneously weaker and stronger than any
of those. General recursion is okay as long as we give a name to every
constant-time step, and otherwise only constant-time computation is
okay.

A basic takeaway from those systems is that they use three special
operations:

- Pair: Join two sets into the two-element set containing them (or a
  one-element set, if they're equal).

- Diff: Take the difference of one set and another.

- Union: Loop over the elements of a set, produce a new set based on
  each element, and take the union of all the results.

Besides these basic set operations, we'll be dealing with
cryptographic restrictions on who can construct and deconstruct
information. These privilege tags will define various kinds of
containment relation. Our operations will look like this:

(TODO: The designs have significantly warped since they were described
here, but these descriptions may come in handy if we bring back
two-way rather than one-way channels. Figure out what to do.)

- Pair: Given two containment relations we can construct and two
  channels, A and B, create a channel whose incoming set is a
  two-element (or one-element, if they're equal) set containing the
  input sets of A and B along the given relations, and whose outgoing
  set is ignored.

- Empty: Make a channel whose incoming set is empty, and whose
  outgoing set is ignored.

- Diff: Given two channels, A and B, partition the incoming set of A
  among three new channels depending on whether the element is
  contained by that relation in both A and B, is contained by that
  relation in A but not B, or is contained by some other relation in
  A. The outgoing sets of the three channels are forwarded to the
  outgoing set of A.

- Union: Loop over the elements of a given channel's incoming set
  contained on a given containment relation we can deconstruct, and
  process them in a given way. Create two channels, A and B:
  Channel A's incoming set is the union of all incoming sets from the
  loop's iteration results, and its outgoing set forwards to all of
  the outgoing sets from the loop's iteration results. Channel B's
  incoming set is the subset of the original channel's incoming set
  that couldn't be deconstructed, and its outgoing set forwards to
  that channel's outgoing set.

~~ Tenerezza differences from Staccato ~~

Much of Tenerezza's syntax is the same as Staccato's. Here's an
overview of the differences:

Close cousins:
Staccato's (match ...) and Tenerezza's (match-element ...)
Staccato's (frame ...) and Tenerezza's (singleton ...)

Only in Tenerezza:
(minus ...)
(empty ...)
(union ...)
(each ...)
(any-element ...)
(let-element-case ...)

Most of these differences are a bit idiosyncratic.

In order to give a name to the control flow block of (each ...),
Tenerezza syntactically distinguishes three steps for each
user-defined Tenerezza operation: <case-list> which can loop,
<element-case-list> which can destructure, and <get-expr> which can do
everything else. Staccato only needed <case-list> to destructure and
<get-expr> to do everything else. This difference is what gives
Tenerezza (any-element ...) and (let-element-case), and it's the
reason Tenerezza has (match-element ...) instead of (match ...).

The difference between Staccato's (frame ...) and Tenerezza's
(singleton ...) is that anyone can check (singleton ...) values for
equality using (minus ...), whereas there's no plan to support an
equality check for (frame ...).

The remaining, not-so-idiosyncratic difference is the addition of
certain operations to Tenerezza, making it possible to compute on
sets:

(minus ...)
(empty ...)
(union ...)
(each ...)


~~ Tenerezza syntax ~~

(TODO: Parts of this are just like Staccato syntax, so we don't
describe them. Update this so Staccato isn't required reading.)

<def> ::=
  (def <frame-name> <opt-var-list>
    <case-list>)

<case-list> ::=
  (any <get-expr>)
  (let-case <var> <case-list>)
  (each <element-case-list>)

<element-case-list> ::=
  (any-element <get-expr>)
  (let-element-case <var> <element-case-list>)

  // This requires permission to (match-element ...) the tag.
  //
  (match-element <frame-name> <env-pattern>
    <get-expr>
    <element-case-list>)

<get-expr> ::=
  (local <var>)
  (let <var> <get-expr>
    <get-expr>)
  // Sugar.
  (let-def <def>
    <get-expr>)

  // NOTE: This sort of breaks through encapsulation by letting us
  // check elements for equality, but that quirk is rationalized by
  // making it explicit in the design intent of (singleton ...).
  //
  // NOTE: This is special in that it's the only operator here that
  // wouldn't make sense under the open world assumption (OWA).
  //
  (minus <get-expr> <get-expr>)

  (empty)

  // NOTE: When this is final, both of the subexpressions are
  // considered to be final.
  (union <get-expr> <get-expr>)

  // Make a single-element set. The element is mostly encapsulated to
  // clients that don't have (match-element ...) permission for the
  // tag, but it does expose the ability to check it for equality with
  // other elements by way of (minus ...).
  //
  // This requires permission to (singleton ...) the tag.
  //
  (singleton <frame-name> <env-expr>)

  // Call all elements of the first get-expr, using the second
  // get-expr as the argument each time. Take the union of the
  // results.
  (call <get-expr> <get-expr>)

  // Sugar.
  (save <frame-name> <opt-var-list> <get-expr>)
  (fn <frame-name> <opt-var-list>
    <case-list>)
  (case <frame-name> <opt-var-list> <get-expr> <case-list>)

// A <frame-name> is a global name, and it will always be accompanied
// by an <opt-var-list>, <var-list>, <env-pattern>, or <env-expr>
// where the identifiers correspond to the values that have been
// wrapped in a dynamic tag. The actual content of the dynamic tag is
// this <frame-name> as well as the unordered set of those
// identifiers, and that overall combination will tend to be a
// compile-time constant.
//
// Every dynamic tag is associated with a definition to invoke when
// it's used with (call ...).
//
// Every dynamic tag is associated with permission requirements that
// clients must meet if they use it with (singleton ...) and similar
// requirements for (match-element ...). In fact, the overall
// combination of these requirements must be unique, and the fact that
// the <frame-name> is a global name is just a syntactic convenience.
//
<frame-name> ::= ...

<var> ::= ...  // Any identifier.
<opt-var-list> ::=
  (var-list-omitted)
  (var-list <var-list>)
<var-list> ::=
  (var-list-cons <var> <var-list>)
  (var-list-nil)
<env-pattern> ::=
  (env-pattern-cons <var> <var> <env-pattern>)
  (env-pattern-nil)
<env-expr> ::=
  (env-expr-cons <var> <get-expr> <env-expr>)
  (env-expr-nil)
