// era-sequents.txt
// Copyright 2013 Ross Angle. Released under the MIT License.


// This originally used a much less lispy syntax. The original version
// is still available as a GitHub Gist, linked to by a blog post.
//
// This Gist: https://gist.github.com/4559120
//
// The blog post:
// http://rocketnia.wordpress.com/2013/01/29/an-extensible-type-system-for-meaning-preserving-modularity/

// TODO: Add the "NEW:" fragments implemented in Era.


// Start of a bibliography:
//
// http://www.cs.nott.ac.uk/~txa/publ/obseqnow.pdf
// http://twelf.org/wiki/Canonical_form
// http://arxiv.org/pdf/1201.5240v2.pdf
// http://www.mpi-sws.org/~dreyer/papers/proposal/proposal.ps
// http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.106.7073
// http://homotopytypetheory.org/2011/04/23/running-circles-around-in-your-proof-assistant/
// http://www.scala-lang.org/docu/files/IC_TECH_REPORT_200433.pdf
// http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.26.957
// http://golem.ph.utexas.edu/category/2012/11/freedom_from_logic.html
// http://www.cs.nott.ac.uk/~txa/publ/pisigma-new.pdf
// http://www.daimi.au.dk/~eernst/tool07/papers/maspeghi04-ernst.pdf



// ===== Deductive fragment ==========================================
//
// Underlies all other fragments, except maybe the action fragment.


// == Grammar ==

// NOTE: Where we would say (a) |- (b) --- (c) |- (d), a more explicit
// sequent calculus might say (Gamma; a) |- (b) --- (Gamma; c) |- (d).
// Our inference rules always universally quanify over a context of
// preexisting facts, and their entailments always assume those facts.

// NOTE: (by Ross Angle) Currently I'm bending over backwards to avoid
// defining a term "(type)" that represents the type of a type. It's
// my way to avoid the intuition that the logic should support
// (describes (type) (type)), aka "Type : Type", and become
// inconsistent. Besides, I'm not yet convinced that "here's a type"
// is the most interesting theorem a type object demonstrates, nor
// that general "for all types..." quantification is a particularly
// valuable abstraction tool (even though we use it here).

// TODO: Include the let_in_ syntax in these grammar rules.

// A root node:
INFERENCE_RULES ::= Rule*

Rule ::=| Entailment* "---" Entailment*  // deduction
Rule ::=| Term "~~>" Term  // beta reduction
Entailment ::=| Fact*"," "|-" Fact*","
Fact ::=| "(" Fact ")"
Fact ::=| UserVar "@" UserKnowledge
UserKnowledge ::=| "(" "istype" Term ")"
UserKnowledge ::=| "(" "describes" Term Term ")"
Term ::=| TermVar
// Total functions from value to value
Term ::=| "(" "tfa" TermVar Term Term ")"
Term ::=| "(" "tfn" TermVar Term Term ")"
Term ::=| "(" "tcall" TermVar Term Term Term Term ")"
// Total functions from type to value
Term ::=| "(" "ttfa" TermVar Term ")"
Term ::=| "(" "ttfn" TermVar Term ")"
Term ::=| "(" "ttcall" TermVar Term Term Term ")"
// Large Sigma type
Term ::=| "(" "sfa" TermVar Term Term ")"
Term ::=| "(" "sfn" TermVar Term Term Term ")"
Term ::=| "(" "fst" TermVar Term Term Term ")"
Term ::=| "(" "snd" TermVar Term Term Term ")"
UserVar ::= Word | "me" | "you"
TermVar ::= Word
// NOTE: This is the grammar of nonempty sequences of case-insensitive
// ASCII letters. When another grammar is specified as an alternation
// of this one and several particular examples, those examples are the
// only instances we actually use for that grammar in this document.
Word ::= ...

// Only for inference rules, not code:
Term ::=| TermVar ("[" Term "]")+

// Shorthands:
Entailment ::=| Fact  // short for |- (fact)
Fact ::=| UserKnowledge  // short for "me @ userKnowledge"
Term ::=| "(" "bottom" ")"  // short for (ttfa ^r r)
Term ::=| "(" "unittype" ")"  // short for (ttfa ^r (tfa ^_ r r))
Term ::=| "(" "unit" ")"  // short for (ttfn ^rType (tfn ^r rType r))
Term ::=| "(" "either" Term Term ")"
    // short for
    // (ttfa ^r (tfa ^_ (tfa ^_ term1 r) (tfa ^_ (tfa ^_ term2 r) r)))
Term ::=| "(" "left" Term Term Term ")"
    // short for
    // (ttfn ^r
    //   (tfn ^a (tfa ^_ term1 r)
    //     (tfn ^b (tfn ^_ term2 r) (tcall ^_ term1 r a term3))))
Term ::=| "(" "right" Term Term Term ")"
    // short for
    // (ttfn ^r
    //   (tfn ^a (tfa ^_ term1 r)
    //     (tfn ^b (tfn ^_ term2 r) (tcall ^_ term2 r b term3))))
Term ::=| "(" "bool" ")"  // short for (either (unittype) (unittype))
Term ::=| "(" "true" ")"
    // short for (left (unittype) (unittype) (unit))
Term ::=| "(" "false" ")"
    // short for (right (unittype) (unittype) (unit))


// == Inference rules ==

// TODO: Prove a cut elimination theorem or something for all of this.

// Introduce (tfn ...) and (tfa ...).
(istype xType)
(describes xType x)
    |- (istype yType[ x ]), (describes yType[ x ] y[ x ])
---
(istype (tfa ^x xType yType[ x ]))
(describes (tfa ^x xType yType[ x ]) (tfn x ^xType y[ x ]))

// Eliminate (tfa ...) and introduce (tcall ...).
(describes (tfa ^x xType yType[ x ]) f)
(describes xType xExample)
---
(describes yType[ xExample ] (ttcall ^x xType yType[ x ] f xExample))

// Eliminate (tfn ...) and (tcall ...).
(tcall ^x xType yType[ x ] (tfn ^x xType y[ x ]) xExample)
~~>
y[ xExample ]

// Introduce (ttfn ...) and (ttfa ...).
(istype x) |- (istype yType[ x ]), (describes yType[ x ] y[ x ])
---
(istype (ttfa ^x yType[ x ]))
(describes (ttfa ^x yType[ x ]) (ttfn ^x y[ x ]))

// Eliminate (ttfa ...) and introduce (ttcall ...).
(describes (ttfa ^x yType[ x ]))
(istype xExample)
---
(describes yType[ xExample ] (ttcall ^x yType[ x ] f xExample))

// Eliminate (ttfn ...) and (ttcall ...).
(ttcall ^x yType[ x ] (ttfn ^x y[ x ]) xExample)
~~>
y[ xExample ]

// Introduce (sfa ...) and (sfn ...).
(istype x1) |- (istype yType[ x1 ])
(describes xType xVal)
(describes yType[ xVal ] y[ xVal ])
---
(istype (sfa ^x xType yType[ x ]))
(describes (sfa ^x xType yType[ x ]) (sfn ^x xType xVal y[ x ]))

// Eliminate (sfa ...).
(describes (sfa ^x xType yType[ x ]) s)
---
(describes xType (fst ^x xType yType[ ^x ] s))
(describes yType[ (fst ^x xType yType[ ^x ] s) ]
  (snd ^x xType yType[ ^x ] s))

// Eliminate (sfn ...) and (fst ...).
(fst ^x xType yType[ x ] (sfn ^x xType xVal y[ x ]))
~~>
xVal

// Eliminate (sfn ...) and (snd ...).
(snd ^x xType yType[ x ] (sfn ^x xType xVal y[ x ]))
~~>
y[ xVal ]



// ===== Observational subtyping fragment ============================
//
// Depends on the deductive fragment.

// This is essentially the equality constructed in "Observational
// Equality, Now!" However, we don't necessarily intend to treat it as
// a symmetrical judgment.


// == Grammar ==

Term ::=| "(" "subtype" Term Term ")"
Term ::=| "(" "subval" Term Term Term Term ")"
    // value equivalence across a subtype coercion
Term ::=| "(" "coerce" Term Term Term Term ")"
Term ::=| "(" "coherent" Term Term ")"
// NOTE: We need (typerefl ...) and (valrefl ...) in order to prove
// self-equality of encapsulated or otherwise non-deductive types and
// values.
// TODO: Figure out what else we need. Maybe we need to know that
// equal values passed to equal functions yield equal results.
Term ::=| "(" "typerefl" Term ")"
Term ::=| "(" "valrefl" Term Term ")"


// == Inference rules ==

(istype a)
(istype b)
---
(istype (subtype a b))

(describes aType a)
(describes bType b)
---
(istype (subval aType a bType b))

(describes (subtype a b) pf)
(describes a x)
---
(describes b (coerce a b pf x))
(describes (subval a x b (coerce a b pf x)) (coherent pf x))

(istype a)
---
(describes (subtype a a) (typerefl a))

(describes a x)
---
(describes (subval a x a x) (valrefl a x))

(coerce (tfa ^x ai ao[ x ]) (tfa ^x bi bo[ x ]) pf orig)
~~>
let
  convertypftype4[ bx ][ ax ] = (subtype ao[ ax ] bo[ bx ])
  convertypftype3[ bx ][ ax ] =
    (tfa ^_ (subval bi bx ai ax) convertypftype4[ bx ][ ax ])
  convertypftype2[ bx ] = (tfa ^ax ai convertypftype3[ bx ][ ax ])
  convertypftype1 = (tfa ^bx bi convertypftype2[ bx ])
  convertxpf = (fst ^_ (subtype bi ai) convertypftype1 pf)
  convertx[ bx ] = (coerce bi ai convertxpf bx)
  convertypf[ bx ][ ax ][ pf ] =
    (tcall ^_ (subval bi bx ai ax) convertypftype4[ bx ][ ax ]
      (tcall ^ax2 ai convertypftype3[ bx ][ ax2 ]
        (tcall ^bx2 bi convertypftype2[ bx2 ][ ax2 ]
          (snd ^_ (subtype bi ai) convertypftype1 pf)
          bx)
        ax)
      pf)
in
(tfn ^bx bi
  (coerce ao[ convertx[ bx ] ] bo[ bx ]
    convertypf[ bx ][ convertx[ bx ] ][ (coherent convertxpf bx) ]
    (tcall ^ax ai ao[ ax ] orig convertx[ bx ])))

(subtype (tfa ^x ai ao[ x ]) (tfa ^x bi bo[ x ]))
~~>
(sfn ^_ (subtype bi ai)
  (tfa ^bx bi
    (tfa ^ax ai
      (tfa ^_ (subval bi bx ai ax) (subtype ao[ ax ] bo[ bx ])))))

(subval (tfa ^x ai ao[ x ]) a (tfa ^x bi bo[ x ]) b)
~~>
(tfa ^ax ai
  (tfa ^bx bi
    (tfa ^_ (subval ai ax bi bx)
      (subval
        ao[ ax ] (tcall ^x ai ao[ x ] a ax)
        bo[ bx ] (tcall ^x bi bo[ x ] b bx)))))

(coerce (ttfa ^x ao[ x ]) (ttfa ^x bo[ x ]) pf orig)
~~>
(ttfn ^x (coerce ao[ x ] bo[ x ]
  (ttcall ^x2 (subtype ao[ x2 ] bo[ x2 ]) pf x)
  (ttcall ^x2 ao[ x2 ] orig x))

(subtype (ttfa ^x ao[ x ]) (ttfa ^x bo[ x ]))
~~>
(ttfa ^x (subtype ao[ x ] bo[ x ]))

(subval (ttfa ^x ao[ x ]) a (ttfa ^x bo[ x ]) b)
~~>
(ttfa ^x
  (subval
    ao[ x ] (ttcall ^x2 ao[ x2 ] a x)
    bo[ x ] (ttcall ^x2 bo[ x2 ] b x)))

(coerce (sfa ^x ai ao[ x ]) (sfa ^x bi bo[ x ]) pf orig)
~~>
let
  convertypffntype4[ ax ][ bx ] = (subtype ao[ ax ] bo[ bx ])
  convertypffntype3[ ax ][ bx ] =
    (tfa ^_ (subval bi bx ai ax) convertypffntype4[ bx ][ ax ])
  convertypffntype2[ bx ] = (tfa ^ax ai convertypffntype3[ bx ][ ax ])
  convertypffntype1 = (tfa ^bx bi convertypffntype2[ bx ])
  convertxpf = (fst ^_ (subtype bi ai) convertypffntype1 pf)
  convertypf[ bx ][ ax ][ pf ] =
    (tcall ^_ (subval ai ax bi bx) convertypffntype4[ ax ][ bx ]
      (tcall ^bx2 bi convertypffntype3[ ax ][ bx2 ]
        (tcall ^ax2 ai convertypffntype2[ ax2 ][ bx2 ]
          (snd ^_ (subtype bi ai) convertypffntype1 pf)
          bx)
        ax)
      pf)
  ax = (fst ^x ai ao[ x ] orig)
  ay = (snd ^x ai ao[ x ] orig)
in
(sfn ^bx bi (coerce bi ai convertxpf x)
  (coerce ao[ ax ] bo[ bx ]
    convertypf[ ax ][ bx ][ (coherent convertxpf ax) ]
    ay))

(subtype (sfa ^x ai ao[ x ]) (sfa ^x bi bo[ x ]))
~~>
(sfn ^_ (subtype ai bi)
  (tfa ^ax ai
    (tfa ^bx bi
      (tfa ^_ (subval ai ax bi bx)
        (subtype ao[ ax ] bo[ bx ])))))

(subval (sfa ^x ai ao[ x ]) a (sfa ^x bi bo[ x ]) b)
~~>
(sfn ^_ (subval ai a bi b)
  (subval
    ao[ (fst ^x ai ao[ x ] a) ] (snd ^x ai ao[ x ] a)
    bo[ (fst ^x bi bo[ x ] b) ] (snd ^x bi bo[ x ] b)))



// ===== Action fragment =============================================


// == Grammar ==

// A root node:
MODULE ::= UserAction*

Fact ::=| UserVar "@!" UserAction
// NOTE: This is a user's knowledge that they have the choice to
// perform an action.
UserKnowledge ::=| "(" "can" UserAction ")"

// Only for depictions of external modules, not inference rules or
// actionable module code:
Term ::=| "<hiddenCode>"


// == Inference rules ==

// (none)



// ===== Local collaboration fragment ================================
//
// Depends on the deductive fragment and the action fragment.


// == Grammar ==

UserKnowledge ::=| "(" "secret" Term ")"
UserKnowledge ::=| "(" "public" Key ")"
Key ::=| "(" "everyone" ")"
Key ::=| "(" "subkey" Key ExternallyVisibleWord ")"
// UserAction ::=| "(" "withsecret" TermVar Key UserAction ")"
// NOTE: In any place this grammar is used, an actual programming
// language implementation is very likely to use a different format.
// Sequences of ASCII letters aren't a very conscientious
// international standard.
ExternallyVisibleWord ::= "(" "sym" Word ")"

// Only for inference rules, not code:
Key ::=| "<language>"
Key ::=| KeyVar
KeyVar ::= Word | "myKey" | "yourKey" | "from" | "to" | "by" | "key"
ExternallyVisibleWord ::=| WordVar
WordVar ::= Word | "word"


// == Inference rules ==

|-  // Tautology
---
(public (everyone))

(public key)
---
(public (subkey key word))

(public key)
(secret x) |- (can act[ x ])
---
(can (withsecret x key act[ x ]))



// ===== Local collaborative value-level definition fragment =========
//
// Depends on the local collaboration fragment.


// == Grammar ==

UserAction ::=| "(" "define" Term Key Term Term ")"
UserAction ::=| "(" "witheach" TermVar Key Term Term UserAction ")"


// == Inference rules ==

// Introduce (define ...).
(secret myKey)
(public yourKey)
(describes xType x)
---
(can (define myKey yourKey xType x))

// Eliminate (define ...) and introduce (witheach ...).
me @! (define myKey yourKey xType x)
you @ (public myKey)
you @ (secret yourKey)
you @ (istype xType)
(you @ (describes xType x)) |- (you @ (can act[ x ]))
---
you @ (can (witheach ^x myKey yourKey xType act[ x ]))



// ===== Local collaborative phantom type fragment ===================
//
// Depends on the local collaboration fragment.
//
// TODO: If this wraps a (tfa ...), we can get nontermination! We
// should either stop using that impredicative type, abandon this
// fragment idea, or think outside the box some more.


// == Grammar ==

UserAction ::=| "(" "definewrapper" Term Term ")"
UserAction ::=|
    "(" "witheachwrapper" TermVar TermVar Term Term UserAction ")"
Term ::=| "(" "wrapper" Term ")"
// TODO: Figure out what else we might need in order to reason about
// equality of wrapped values.


// == Inference rules ==

// Introduce (wrapper ...).
(public by)
---
(istype (wrapper by))

// Introduce (definewrapper ...).
(secret by)
(istype innerType)
---
(can (definewrapper by innerType))

// Eliminate (definewrapper ...) and introduce (witheachwrapper ...).
me @! (definewrapper by innerType)
(secret by)
(istype innerType)
(describes (tfa ^_ innerType (wrapper by)) wrap),
  (describes (tfa ^_ (wrapper by) innerType) unwrap),
  |- (can act[ wrap ][ unwrap ])
---
(can
  (witheachwrapper ^wrap ^unwrap by innerType act[ wrap ][ unwrap ]))



// ===== Local collaborative extensible sum fragment =================
//
// Depends on the local collaboration fragment and the observational
// subtyping fragment.

// A certain user action can establish a new extensible sum type along
// with a policy on how that type can be extended. Another user can
// extend that sum with new cases, but only if they provide a way to
// preserve that policy, even in spite of others' independent ability
// to extend the sum.
//
// In a more user-friendly language, it may appear that several
// interdependent extensible sums and policies can be declared
// together in a bundle. However, that can probably be implemented on
// top of this single-sum, single-policy system.
//
// This system introduces a certain kind of infinity: Say one user
// starts a new extensible sum type (sumpart myKey). Another user
// extends it, but their extension family's index (i.e. newParts) is
// of type (sumpart myKey) itself, or of some related type, so now the
// inhabitants of (sumpart myKey) go into an infinite regress.
//
// TODO: See if that infinite regress leads to an embedding of
// inductive and/or coinductive definitions, or if it even leads to
// logical inconsistency.


// == Grammar ==

UserKnowledge ::=| "(" "extensible" Term ")"
UserAction ::=| "(" "startsum" Term TermVar Term Term TermVar Term ")"
UserAction ::=| "(" "witheachstartsum" TermVar TermVar TermVar
  Term TermVar Term Term TermVar Term UserAction ")"
UserAction ::=| "(" "youcanextendsum" Term Key TermVar Term ")"
UserAction ::=| "(" "extendsum" Key Term Term TermVar Term ")"
UserAction ::=|
  "(" "witheachextendsum" TermVar TermVar Key Term Term UserAction ")"
Term ::=| "(" "sumpart" Key ")"
Term ::=| "(" "extendtype" Term Term ")"
Term ::=| "(" "stoe" Term Term ")"
Term ::=| "(" "etos" Term Term ")"
Term ::=| "(" "extend" Term Term ")"
// TODO: Figure out what else we might need in order to reason about
// equality of these values.


// == Inference rules ==

// Introduce (sumpart ...).
(public by)
---
(istype (sumpart by))

// Introduce (startsum ...).
(secret myKey)
(istype seedParts)
(istype x1) |- (istype accum[ x1 ])
(istype e1), (extensible e1)
  |- (describes accum[ (extendtype seedParts e1) ]
       seedImplementation[ e1 ])
---
(can
  (startsum myKey ^x accum[ x ] seedParts ^e seedImplementation[ e ]))

// Eliminate (startsum ...) and introduce (witheachstartsum ...).
me @!
  (startsum myKey ^x accum[ x ] seedParts ^e seedImplementation[ e ])
(describes (tfa ^_ seedParts (sumpart myKey)) sumExt),
  (describes (tfa ^_ (sumpart myKey) (either seedParts (unittype)))
    sumExtElim),
  (describes accum[ (sumpart mykey) ] sumOut)
  |- (can act[ sumExt ][ sumExtElim ][ sumOut ])
---
(can
  (witheachstartsum ^sumExt ^sumExtElim ^sumOut
    myKey ^x accum[ x ] seedParts ^e seedImplementation[ e ]
    act[ sumExt ][ sumExtElim ][ sumOut ]))

// Eliminate (startsum ...) and introduce (youcanextendsum ...).
//
// TODO: See if we actually need to share accum[ x ] itself or if we
// can share less information while still making it just as possible
// to formulate an extension.
//
// TODO: See if we need to send an abstracted version of accum[ x ] in
// order to make certain kinds of extension invariants possible to
// enforce.
//
me @!
  (startsum myKey ^x accum[ x ] seedParts ^e seedImplementation[ e ])
(public yourKey)
---
(can (youcanextendsum myKey yourKey ^x accum[ x ]))

// Eliminate (youcanextendsum ...) and introduce (extendsum ...).
//
// TODO: The point of incorporating (sumpart myKey) is so we can take
// full advantage of preexisting definitions related to this sum when
// making an extension. See if this approach fully accomplishes this
// goal, and see if its circularity somehow leads to inconsistency.
//
// NOTE: We're having (subtype ...) indicate a proof that there's
// exactly one way to coerce, so that it stays proof-irrelevant.
// However, we're using (subval ...) to indicate that a value of one
// type supports no more observations than another value of another
// type. If we let (subtype ...) be computationally relevant,
// extend[ e ] could just be a (subtype ...) proof.
//
me @! (youcanextendsum myKey yourKey x1 accum[ x1 ])
you @ (public myKey)
you @ (secret yourKey)
you @ (istype myParts)
(you @ (istype x2)) |- (you @ (istype accum[ x2 ]))
(you @ (istype e1)), (you @ (extensible e1)) |-
let
  xParts = (extendtype (sumpart myKey) e1)
  yParts = (extendtype myParts xParts)
in
  (you @
    (describes
      (tfa ^x accum[ xParts ]
        (sfa ^y accum[ yParts ]
          (subval accum[ xParts ] x accum[ yParts ] y)))
      extend[ e1 ]))
---
you @ (can (extendsum myKey yourKey myParts ^e extend[ e ]))

// Eliminate (extendsum ...) and introduce (witheachextendsum ...).
you @! (extendsum myKey yourKey myParts ^e extend[ e ])
you @ (public myKey)
you @ (secret yourKey)
you @ (istype myParts)
(you @ (describes (tfa ^_ myParts (sumpart myKey)) sumExt)),
  (you @
    (describes (tfa ^_ (sumpart myKey) (either myParts (unittype)))
      sumExtElim)),
  |- (you @ (can act[ sumExt ][ sumExtElim ]))
---
you @
  (can
    (witheachextendsum ^sumExt ^sumExtElim myKey yourKey myParts
      act[ sumExt ][ sumExtElim ]))

// Introduce #Extend, #stoe, #etos, and #extend.
(istype myParts)
(extensible e)
---
(istype (extendtype myParts e))
(extensible (extendtype myParts e))
(describes (tfa ^_ (either myParts e) (extendtype myParts e))
  (stoe myParts e))
(describes (tfa ^_ (extendtype myParts e) (either myParts e))
  (etos myParts e))
(describes
  (tfa ^x e
    (sfa ^y (extendtype myParts e)
      (subval e x (extendtype myParts e) y)))
  (extend myParts e))

// TODO: See if (extend ...) is enough to actually prove the things we
// need to prove for (extendsum ...). We might not have transitivity
// of (subval ...) yet, or something.



// TODO: Consider adding another approach to extensible sum types,
// which would be well integrated with the idea of knowledge queries,
// but not so well integrated with the deductive system:
//
// Term ::=| "(" "k" Term ")"
// Term ::=| "(" "defined" Key Term Term ")"
// Term ::=| "(" "leteachknownexpr" TermVar Term Term ")"
// UserAction ::=| "(" "leteachknown" TermVar Term UserAction ")"
//
// A judgment (describes (k t) x) says x would terminate as evidence
// for a collection of values of t whose size is monotonic with the
// quantity of knowledge that's available for query purposes. The
// (k t) type constructor may syntactically be a monad, but it works
// more like an effect type, tainting the type of any function call
// that has it as a subexpression.
//
// The (leteachknownexpr ...) and (leteachknown ...) syntaxes perform
// knowledge queries. Instead of saying (witheach x from to type ...),
// we say (leteachknown x (defined from to type) ...).
//
// Term ::=| "(" "mysterytype" ")"
// Term ::=| "(" "mystery" Term Term Term ")"
// Term ::=| "(" "dispatcher" Key ")"
// UserAction ::=| "(" "decidemysterytype" Term Term ")"
// UserAction ::=| "(" "startdispatcher" Term Term ")"
// UserAction ::=| "(" "extenddispatcher" Term Key Term ")"
//
// If one person does (startdispatcher to resultType) and others do
// (decideMysteryType from inputType) and
// (extendDispatcher from to func), with each "func" of type
// (tfa ^_ inputType (k resultType)), then the person who started the
// dispatcher can access those methods using a value (dispatcher to)
// of type (k (tfa (mysterytype) (k resultType))). Values of type
// (mysterytype), created using (mystery from inputType inputVal),
// will dispatch to the method defined on the same "from" key that
// created them.



// ===== Example built-in module: Natural numbers ====================

(withsecret nat (subkey <language> (sym nat))
  (define (subkey <language> (sym natZero)) (everyone)
    (wrappertype nat)
    <hiddenCode>))
(withsecret nat (subkey <language> (sym nat))
  (define (subkey <language> (sym natSucc)) (everyone)
    (tfa ^_ (wrappertype nat) (wrappertype nat))
    <hiddenCode>))
(withsecret nat (subkey <language> (sym nat))
  (define (subkey <language> (sym natElim)) (everyone)
    (ttfa ^_ a
      (tfa ^_ (wrappertype nat) (tfa ^_ a (tfa ^_ (tfa ^_ a a) a))))
    <hiddenCode>))
