We have only a few main use cases for a Cene npm-installable command-line utility right now:

- Write some code as a family of Cene files, and use it to generate JS for the Web.
- Write some code as a family of Cene files, and use it to generate JS for an npm-installable command-line utility, such as a bootstrapped implementation of Cene itself.
- Write some code as a single Cene file, and execute it on its own as a command-line utility using a shebang line.

So how about this:

$ cene -h
Usage: cene [options] build.cene [arguments]

Options:
  -h, --help             Show this help message and exit.
  -v, --version          Show Cene's version number and exit.
  -i, --in dir           A directory to use as input.
  -b, --build dir        A directory to hold internal results.
  -o, --out dir          A directory where files will be overwritten.
  -c, --command command  A command run whenever the build is complete.
  -w, --watch            Keep running builds whenever inputs change.

(TODO: Support --command. Then support --build, then --watch. We haven't focused on implementing the --build and --watch options yet because they could be a premature optimization.)

To interact with the outside world, the Cene code has access to a few things in the form of nonstandard definitions:

(def-type encapsulated-string val)
(def-type assoc key value)
(def-type file-type-directory)
(def-type file-type-blob)
(def-type file-type-missing)

(defn cli-arguments mode ...)
Gets the command-line arguments that were provided after the file name to execute. The given mode must be a current one, and it must permit CLI-time operations.

(defn cli-input-directory mode ...)
Gets an input path that corresponds to the input directory provided at the command line. The given mode must be a current one, and it must permit CLI-time operations.

(defn cli-output-directory mode ...)
Gets an output path that corresponds to the output directory provided at the command line. The given mode must be a current one, and it must permit CLI-time operations.

(defn input-path-get input-path name ...)
Gets an input path that is a child of the given one.

(defn input-path-type mode input-path ...)
Gets (file-type-directory), (file-type-blob), or (file-type-missing) depending on what exists at the given input path. The given mode must be a current one, and it must permit CLI-time operations.

(defn input-path-directory-list mode input-path ...)
Lists the filenames in a directory. The given mode must be a current one, and it must permit CLI-time operations.

(defn input-path-blob-utf-8 mode input-path ...)
Reads a blob as a string in utf-8 encoding, replacing invalid sequences with the Unicode replacement character if necessary. The given mode must be a current one, and it must permit CLI-time operations.

(defn output-path-get output-path name ...)
Gets an output path that is a child of the given one.

(defn output-path-directory output-path ...)
Monadically creates the given output path and its ancestors as directories. If a single path is written as a blob and as a directory, at least one of those writes is an error. The current mode must permit CLI-time operations.

(defn output-path-blob-utf-8 output-path output-string ...)
Monadically creates the given output path's ancestors as directories, creates the path itself as a blob, and overwrites its content with the given string in utf-8 format. The string may be a (string ...) or an (encapsulated-string ...). If a single path is written as a blob and as a directory, or as a blob twice, at least one of those writes is an error. The current mode must permit CLI-time operations.

(defn cli-output-environment-variable-shadow key value ...)
Monadically sets up the given key-value pair of strings so that it's part of the environment variables during the execution of the CLI interface's --command option. The value string may be a (string ...) or an (encapsulated-string ...). This does not modify the environment variables that are observed by (cli-input-environment-variables), but those variables will be implicitly inherited unless they're shadowed here. If the same key is shadowed twice, at least one of those shadow operations is an error. The current mode must permit CLI-time operations.

(defn sloppy-javascript-quine mode constructor-tag ...)
Creates an (encapsulated-string ...) with self-contained JavaScript that will invoke a function corresponding to the given constructor tag, using the definitions currently existing in this runtime, passing it a fresh mode that permits synchronous-JavaScript-time operations. This will make no attempt to serialize first-class values; it will only put all Cene code and dependency data into a single massive JavaScript file together with a Cene interpreter that can re-run the build (including re-running the (sloppy-javascript-quine ...) operation itself!). The given mode must be a current one, and it must permit CLI-time operations.

(defn string-to-javascript-utf-16 string ...)
Translates a Cene string into a JavaScript string.

(defn javascript-utf-16-to-string string ...)
Translates a JavaScript string into a Cene string, reading it according to the utf-16 encoding, replacing invalid sequences with the Unicode replacement character if necessary.

(defn javascript-sync client-var env body)
Monadically executes a given body of JavaScript code under an environment dictated by a given list of (assoc ...) entries mapping JavaScript identifiers to Cene values (which will be wrapped on the JavaScript side) and another JavaScript identifiers referring to a Cene client object (which is not wrapped, as it does not represent a first-class Cene value). Then this executes the JavaScript code's resulting wrapped Cene monadic effects, and this finally results in their result. The current mode must permit synchronous-JavaScript-time operations.

JavaScript client object operations:

client.wrap( jsVal )
Wraps the given JavaScript value as a wrapped Cene value. If the JavaScript value is itself a wrapped Cene value, this wraps it again anyway.

client.maybeUnwrap( wrappedVal )
Returns null or { val: jsVal } depending on whether the given wrapped Cene value was obtained by wrapping a JavaScript value. If the given value isn't a wrapped Cene value, this raises an exception.

client.done( result )
Returns wrapped Cene monadic side effects that, when executed, do nothing but return the given wrapped Cene value.

client.doThen( effectfulArg, then )
Returns wrapped Cene monadic side effects that, when executed, execute the given the given wrapped Cene monadic effects, pass the result to the given JavaScript function, and execute the resulting wrapped Cene monadic side effects.

client.doCall( func, arg, then )
Returns wrapped Cene monadic side effects that, when executed, call the given wrapped Cene function with the given wrapped Cene argument, pass the result to the given JavaScript function, and execute the resulting wrapped Cene monadic side effects.

client.fork( jsMode )
Returns a wrapped Cene value representing a fresh mode that follows the given wrapped Cene mode. The given mode must be a current one, and it must have been created for running JavaScript code. The resulting mode must eventually be finished with client.sync( ... ) or its side effects will never occur. This fork action is conceived of as a JavaScript side effect, not a Cene side effect; the resulting mode will be usable regardless of future errors in the currently processing Cene effect monad.

client.doSync( forkedMode )
Returns wrapped Cene monadic side effects that, when executed, finish the given wrapped Cene mode, execute all its built-up effects, and result in (nil). The given mode must be a current one, it must have been created by client.fork( ... ), and it must be unfinished at the time these side effects execute.

client.deferIntoTrampoline( jsMode, then )
where then( trampolinedMode )
Executes the given JavaScript callback in a future JavaScript tick, with access to a fresh wrapped Cene mode which follows the given one, then executes its resuting wrapped Cene monadic side effects in the same JavaScript tick as the callback was executed in. The given mode must be a current one, it must have been created for running JavaScript code, and it must not have been finished yet. This deferral action is conceived of as a JavaScript side effect, not a Cene side effect; the deferral will occur regardless of future errors in the currently processing Cene effect monad.
