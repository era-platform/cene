We have only a few main use cases for a Cene npm-installable command-line utility right now:

- Write some code as a family of Cene files, and use it to generate JS for the Web.
- Write some code as a family of Cene files, and use it to generate JS for an npm-installable command-line utility, such as a bootstrapped implementation of Cene itself.
- Write some code as a single Cene file, and execute it on its own as a command-line utility using a shebang line.

So how about this:

$ cene -h
Usage: cene [options] build.cene [arguments]

Options:
  -h, --help             Show this help message and exit.
  -v, --version          Show Cene's version number and exit.
  -i, --in dir           A directory to use as input.
  -b, --build dir        A directory to hold internal results.
  -o, --out dir          A directory where files will be overwritten.
  -c, --command command  A command run whenever the build is complete.
  -w, --watch            Keep running builds whenever inputs change.

(TODO: Support --command. Then support --build, then --watch. We haven't focused on implementing the --build and --watch options yet because they could be a premature optimization.)

To interact with the outside world, the Cene code has access to a few things in the form of nonstandard definitions:

(def-type encapsulated-string val)
(def-type assoc key value)
(def-type file-type-directory)
(def-type file-type-blob)
(def-type file-type-missing)

(defn cli-arguments mode ...)
Gets the command-line arguments that were provided after the file name to execute. The given mode must be a current one, and it must permit CLI-time operations.

(defn cli-input-directory mode ...)
Gets an input path that corresponds to the input directory provided at the command line. The given mode must be a current one, and it must permit CLI-time operations.

(defn cli-output-directory mode ...)
Gets an output path that corresponds to the output directory provided at the command line. The given mode must be a current one, and it must permit CLI-time operations.

(defn input-path-get input-path name ...)
Gets an input path that is a child of the given one.

(defn input-path-type mode input-path ...)
Gets (file-type-directory), (file-type-blob), or (file-type-missing) depending on what exists at the given input path. The given mode must be a current one, and it must permit CLI-time operations.

(defn input-path-directory-list mode input-path ...)
Lists the filenames in a directory. The given mode must be a current one, and it must permit CLI-time operations.

(defn input-path-blob-utf-8 mode input-path ...)
Reads a blob as a string in utf-8 encoding, replacing invalid sequences with the Unicode replacement character if necessary. The given mode must be a current one, and it must permit CLI-time operations.

(defn output-path-get output-path name ...)
Gets an output path that is a child of the given one.

(defn output-path-directory output-path ...)
Monadically creates the given output path and its ancestors as directories. If a single path is written as a blob and as a directory, at least one of those writes is an error. The current mode must permit CLI-time operations.

(defn output-path-blob-utf-8 output-path output-string ...)
Monadically creates the given output path's ancestors as directories, creates the path itself as a blob, and overwrites its content with the given string in utf-8 format. The string may be a (string ...) or an (encapsulated-string ...). If a single path is written as a blob and as a directory, or as a blob twice, at least one of those writes is an error. The current mode must permit CLI-time operations.

(defn cli-output-environment-variable-shadow key value ...)
Monadically sets up the given key-value pair of strings so that it's part of the environment variables during the execution of the CLI interface's --command option. The value string may be a (string ...) or an (encapsulated-string ...). This does not modify the environment variables that are observed by (cli-input-environment-variables), but those variables will be implicitly inherited unless they're shadowed here. If the same key is shadowed twice, at least one of those shadow operations is an error. The current mode must permit CLI-time operations.

(defn sloppy-javascript-quine mode constructor-tag top-level-vars ...)
Creates an (encapsulated-string ...) with self-contained JavaScript that captures the given cons list of variable name strings and synchronously calls a function corresponding to the given constructor tag, using the definitions currently existing in this runtime, passing it a Cene client object with access to the captured variables. This will make no attempt to serialize first-class values; it will only put all Cene code and dependency data into a single massive JavaScript file together with a Cene interpreter that can re-run the build (including re-running the (sloppy-javascript-quine ...) operation itself!). The given mode must be a current one, and it must permit CLI-time operations.

(defn string-to-javascript-utf-16 string ...)
Translates a Cene string into a JavaScript string.

(defn javascript-utf-16-to-string string ...)
Translates a JavaScript string into a Cene string, reading it according to the utf-16 encoding, replacing invalid sequences with the Unicode replacement character if necessary.

(defn done-js-effects result ...)
Creates a JavaScript effects value that does nothing and results in the given value.

(defn then-js-effects js-effects then ...)
where (then intermediate)
Creates a JavaScript effects value that executes the given `js-effects` value, calls the given `then` value with the intermediate result, and proceeds by running the resulting JavaScript effects value.

(defn give-unwrapped-js-effects js-val js-then ...)
where js-then( val )
Creates a JavaScript effects value that calls the given `js-then` JavaScript function passing an unwrapped version of the given JavaScript value, and proceeds by running the resulting wrapped Cene JavaScript effects value.

(defn give-js-effects cene-val js-then ...)
where js-then( val )
Creates a JavaScript effects value that calls the given `js-then` JavaScript function passing a wrapped version of the given Cene value, and proceeds by running the resulting wrapped Cene JavaScript effects value.

(defn compile-function-js-effects params body ...)
Creates a JavaScript effects value that results in a new JavaScript function created out of the given cons list of parameter strings and the given body string.

JavaScript client object operations:

client.getTopLevelVar( varName )
Gets the current value of the top-level JavaScript variable whose name is the given JavaScript string. It must be one of the variables that was captured by the code produced by (sloppy-javascript-quine ...).

client.setTopLevelVar( varName, val )
Assigns to the top-level JavaScript variable whose name is the given JavaScript string. It must be one of the variables that was captured by the code produced by (sloppy-javascript-quine ...).

client.wrap( jsVal )
Wraps the given JavaScript value as a wrapped Cene value. If the JavaScript value is itself a wrapped Cene value, this wraps it again anyway.

client.maybeUnwrap( wrappedVal )
Returns null or { val: jsVal } depending on whether the given wrapped Cene value was obtained by wrapping a JavaScript value. If the given value isn't a wrapped Cene value, this raises an exception.

client.done( result )
Creates a wrapped Cene JavaScript effects value that does nothing and results in the given value.

client.then( jsEffects, then )
where then( intermediate )
Creates a wrapped Cene JavaScript effects value that executes the given `jsEffects` wrapped Cene JavaScript effects value, calls the given `then` JavaScript function passing a wrapped version of the intermediate result, and proceeds by running the resulting wrapped Cene JavaScript effects value.

client.giveSync( val, ceneThen )
where (ceneThen val)
Creates a wrapped Cene JavaScript effects value that synchronously calls the given `ceneThen` wrapped Cene function passing the given wrapped Cene value and proceeds by running the resulting JavaScript effects value.

client.giveAsync( val, ceneThen )
where (ceneThen val)
Creates a wrapped Cene JavaScript effects value that asynchronously calls the given `ceneThen` wrapped Cene function passing the given wrapped Cene value (taking at least one JavaScript tick) and proceeds by running the resulting JavaScript effects value.

client.defer( then )
where then()
Schedules the given JavaScript callback to execute in a future JavaScript tick, then executes its resulting wrapped Cene JavaScript effects value in the same JavaScript tick, ignoring the result.
