Cene is not statically typed (yet). If we want to provide table values with a well-defined and deterministic API, we need to ensure that the run time behavior of key comparisons does not expose implementation details of the keys. For instance, it should not let us compare name values to obtain a "less than" or "greater than" result. To accomplish this enforcement, we offer various ad hoc ways of building well-behaved comparators (and other kinds of well-behaved operators).

It will likely turn out to be simpler to add a static type system, in the long run.


\= A "cmp" is a binary relation such that, wherever it is defined, it answers whether or not the given values are indistinguishable. (There is no "custom" sense of indistinguishability allowed here. If there is any way at all to distinguish two values, they are not indistinguishable.)
\=
(cmp-default <cmp-for-trying-first> <cmp-for-trying-second>)
(cmp-give-up)
(cmp-string)
(cmp-name)
(cmp-cmp)
(cmp-combine)
(cmp-struct cons <car-cmp> <cdr-cmp>)
(cmp-by-own-method <get-method-cmp> <get-method>)
  \= Given a function and a cmp that can compare that function, returns a cmp that can compare a value by invoking that function with the value and then proceeding to invoke the resulting cmp value.
(cmp-fix <get-cmp> <get>)
  \= Given a function and a cmp that can compare that function, returns a cmp that works by passing itself to the function and then invoking the resulting cmp.
(cmp-table <key-and-val-to-method-cmp> <key-and-val-to-method>)
(call-cmp <cmp> <a> <b>)

\= A "merge" is a binary operation that is commutative, associative, and idempotent wherever it is defined.
\=
(merge-cmp <cmp>)
  \= NOTE: This only processes the cmp operation once, calling it with the two values being merged. It doesn't sanity-check that the cmp is reflexive for either argument.
(merge-default <merge-for-trying-first> <merge-for-trying-second>)
(merge-struct cons <car-merge> <cdr-merge>)
(merge-by-own-method <get-method-cmp> <get-method>)
  \= NOTE: This calls the `get-method` operation three times. It gets the method for both of the values being merged, and it gets the method for the result. By checking that all three are the same, this makes sure that the operation is associative.
(merge-fix <get-cmp> <get>)
  \= Given a function and a cmp that can compare that function, returns a merge that works by passing itself to the function and then invoking the resulting merge.
(merge-table <key-and-val-to-method-cmp> <key-and-val-to-method>)
(call-merge <merge> <a> <b>)

\= A "combine" is a binary operation that is commutative and associative wherever it is defined.
\=
(combine-merge <merge>)
(combine-default <combine-for-trying-first> <combine-for-trying-second>)
(combine-struct cons <car-combine> <cdr-combine>)
(combine-by-own-method <get-method-cmp> <get-method>)
  \= NOTE: This calls the `get-method` operation three times. It gets the method for both of the values being combined, and it gets the method for the result. By checking that all three are the same, this makes sure that the operation is associative.
(combine-fix <get-cmp> <get>)
  \= Given a function and a cmp that can compare that function, returns a combine that works by passing itself to the function and then invoking the resulting combine.
(combine-table <key-and-val-to-method-cmp> <key-and-val-to-method>)
(call-combine <combine> <a> <b>)
\= TODO: Add some way to combine numbers by addition. Figure out if there's a way to do it that is compatible with various number encodings or other commutative monoids.

(table-empty <key-cmp>)
(table-shadow <key> <maybe-val> <table>)
(table-get <key> <table>)
(table-key-cmp <table>)
(table-default <table-for-trying-first> <table-for-trying-second>)
(table-map-combine <table-to-iterate> <combine> <init-to-combine-into> <key-and-val-to-combine-component>)

\= NOTE: We can't have (cmp-map <func-cmp> <func> <result-cmp>) because it might call things equivalent that are distinguishable from each other, which would make a (combine-cmp ...) stop being commutative.

\= NOTE: We can't have (combine-map <func-cmp> <func> <result-combine>) because it might not be associative. For the same reason, we can't have this, either:
\=
\= (combine-by-calling-twice <func-cmp> <func> <result-combine>)
\=   \= Given a function that takes two values and combines them, a cmp that can compare that function, and a combine that can combine the results of that function, returns a combine that works by calling the function twice with the arguments in different orders and combining the results.
