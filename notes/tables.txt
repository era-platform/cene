Cene keeps track of stateful external resources using hierarchical paths. Thus, for a framework or interpreter to *pretend* to offer an external resource, it needs to be able to offer a path data structure that it can use to look up and track state. This is a use case for efficient key-value tables.

For writing extensible frameworks, it's useful to be able to process collections of extensions without unnecessarily depending on their order, and it's useful to be able to take a definition-time state resource (a namespace, in Cene) and divide it up across the elements of a collection of extensions in a deterministic way. This is a use case for encapsulated key-value tables where the keys are hidden but the entries remain coordinated across keyed collections. That is, their coordination allows these tables to be zipped with namespaces and other tables.

Tables rely on the ability to compare the keys for equality. We usually don't want external resource paths to be compared in a *visibly ordered* way because that would make it possible to observe when one external resource identification scheme has been globally replaced by another (e.g. if the program has been serialized, transported, and resuscitated on another machine). In a sense, this would be a violation of alpha-equivalence.

Cene is not statically typed (yet). If we want to provide table values with a well-defined and deterministic API, we need to ensure that the run time behavior of key-to-key comparisons does not expose implementation details of the keys, such as ordering, breaking that alpha-equivalence. Yet, ordering information is valuable so the collection can be implemented efficiently. To enforce encapsulation and yet compute an ordering, we offer various ad hoc ways to build well-behaved comparators (and other kinds of well-behaved operators).

This approach is at least as complex as certain static type systems already. In the long run, it will likely accumulate lots of ad hoc extensions. That said, before too long, there will hopefully be enough building blocks here that Cene libraries can bootstrap their own type systems.


\= A "dex" is a binary relation that checks whether both values are in its domain and indistinguishable. There is no "custom" sense of indistinguishability allowed here. If there is any Cene code at all that can distinguish the two values, they are not indistinguishable.
\=
\= TODO: Document the fact that (call-dex ...) returns one of these results:
\=
\=   - (nil)  ; representing that one or both of the values are outside the domain
\=   - (yep/nil)  ; representing equality
\=   - (yep <a foreign value representing "secretly less than">)
\=   - (yep <a foreign value representing "secretly greater than">)
\=
\= TODO: See if we'll ever extend this to orderings the Cene code can observe, which would open up two more:
\=
\=   - (yep/yep/nil)  ; representing "visibly less than"; the inner "yep" means that the arguments were provided in the right order
\=   - (yep/nope/nil)  ; representing "visibly greater than"
\=
def-type (dexable dex val)
  \= A value tagged with a dex that applies to it.
(dex-default <dex-for-trying-first> <dex-for-trying-second>)
(dex-give-up <ignored>)
(dex-string <ignored>)
  \= NOTE: Unlike most of these, (dex-string/nil) can distinguish values that might not have been distinguishable any other way.
(dex-name <ignored>)
  \= NOTE: Unlike most of these, (dex-name/nil) can distinguish values that might not have been distinguishable any other way.
(dex-dex <ignored>)
  \= NOTE: Unlike most of these, (dex-dex/nil) can distinguish values that might not have been distinguishable any other way. For instance, it can distinguish between (dex-default a b) and (dex-default b a).
(dex-merge <ignored>)
(dex-fuse <ignored>)
(dex-struct cons <car-dex> <cdr-dex>)
(dex-by-own-method <dexable-get-method>)
  \= Given a dexable function, returns a dex that works by invoking that function with each value to get `(yep <dex>)` or `(nil)`, verifying that the two `<dex>` values are the same, and then proceeding to invoke that value.
(dex-fix <dexable-unwrap>)
  \= Given a dexable function, returns a dex that works by passing itself to the function and then invoking the resulting dex.
(dex-table <val-dex>)
(call-dex <dex> <a> <b>)
(in-dex <dex> <x>)

\= A "merge" is a binary operation that is commutative, associative, and idempotent wherever it is defined. It returns a `(yep ...)` or `(nil)`, so it doesn't have to be defined everywhere, but when it returns `(nil)` is also subject to those laws.
\=
\= TODO: There's something interesting we might be able to do here. Some values may not let us compute an easy yes or no answer as to whether they're indistinguishable because the only way to distinguish them is to send them into the outside world and wait for the ripples to show up. For instance, a message that means "Please send a response eventually" and a message that means "Please don't send a response ever" might only be distinguishable if and when a response arrives. If a response doesn't arrive, we can't destinguish them yet. While we can't define a dex for these two messages (because that dex itself would be a way to distinguish them), we can define a merge that combines them into a result with maximal feedback or a result with minimal feedback. There might be something having to do with definition lookups or OWA extensibility that can make practical use of this technique.
\=
(merge-by-dex <dex>)
  \= NOTE: This only processes the dex operation once, calling it with the two values being merged. It doesn't sanity-check that the dex is reflexive for either argument.
(merge-default <merge-for-trying-first> <merge-for-trying-second>)
(merge-struct cons <car-merge> <cdr-merge>)
  \= TODO: Implement this.
(merge-by-own-method <dexable-get-method>)
  \= Given a dexable function, returns a merge that works by invoking that function with each value to get `(yep <merge>)` or `(nil)`, verifying that the two `<merge>` values are the same, invoking that value, and invoking the function on the result again to make sure it yields the same `<merge>`. That final check makes sure this operation is associative.
(merge-fix <dexable-unwrap>)
  \= Given a dexable function, returns a merge that works by passing itself to the function and then invoking the resulting merge.
(merge-table <val-merge>)
(call-merge <merge> <a> <b>)

\= A "fuse" is a binary operation that is commutative and associative wherever it is defined. It returns a `(yep ...)` or `(nil)`, so it doesn't have to be defined everywhere, but when it returns `(nil)` is also subject to those laws.
\=
(fuse-by-merge <merge>)
(fuse-default <fuse-for-trying-first> <fuse-for-trying-second>)
(fuse-struct cons <car-fuse> <cdr-fuse>)
  \= TODO: Implement this.
(fuse-by-own-method <dexable-get-method>)
  \= Given a dexable function, returns a fuse that works by invoking that function with each value to get `(yep <fuse>)` or `(nil)`, verifying that the two `<fuse>` values are the same, invoking that value, and invoking the function on the result again to make sure it yields the same `<fuse>`. That final check makes sure this operation is associative.
(fuse-fix <dexable-unwrap>)
  \= Given a dexable function, returns a fuse that works by passing itself to the function and then invoking the resulting fuse.
(fuse-table <val-fuse>)
(call-fuse <fuse> <a> <b>)
\= TODO: Add some way to fuse numbers by addition. Figure out if there's a way to do it that is compatible with various number encodings or other commutative monoids.

(table-empty <ignored>)
(table-shadow <dexable-key> <maybe-val> <table>)
(table-get <dexable-key> <table>)
  \= NOTE: Due to `table-zip` and `table-fuse`, this is redundant, but we keep it for efficiency.
(table-zip <a> <b> <func>)
  where (func <maybe-a-val> <maybe-b-val>)
  \= Given two tables and a function to combine values, makes a new table by iterating over the tables' combined set of keys, calling the function with both tables' `(yep ...)` or `(nil)` values for the keys, and using the function's `(yep ...)` or `(nil)` result to determine the value for the final table. The function will never be called with `(nil)` and `(nil)`.
(table-fuse <table> <init> <fuse>)
  \= NOTE: Due to `table-fuse`, clients can see the contents of the table as a finite multiset of values, even if they don't have the keys. Due to `table-fuse`, `table-zip`, and `procure-sub-ns-table`, they can observe keys in terms of other keys, but they still can't view them directly.
  \=
  \= If you want a table where clients can iterate over the keys too, make a table where the values are key-value pairs.
  \=
  \= If you want a table where clients can't see the values unless they know the keys, try using values that are themselves encapsulated, or try holding the table inside something encapsulated. (This is really open-ended advice, but there are also many possible interpretations of this requirement.)
  \=
  \= If you want a table where multiplicity of values doesn't matter, try defining an encapsulated type that replicates most of the table operations but requires a dex for values (in addition to a dex for keys) and only allows `table-fuse` for a merge, not a general fuse.
  \=
  \= If you want an orderless collection whose equality with other collections is based only on what elements are present, and not which keys they're looked up by, try using the same value as both the key and the value.

\= NOTE: We can't have (dex-map <dexable-func> <result-dex>) because it might call things equivalent that are distinguishable from each other, which would make a (merge-by-dex ...) stop being commutative.

\= NOTE: We can't have (fuse-map <dexable-func> <result-fuse>) because it might not be associative. (For instance, if the fuse is multiplication and the mapped function is adding one, ((1 + a) * (1 + ((1 + b) * (1 + c)))) !== ((1 + ((1 + a) * (1 + b))) + (1 * c)) unless a === c.) For the same reason, we can't have this, either:
\=
\= (fuse-by-calling-twice <dexable-func> <result-fuse>)
\=   \= Given a dexable function that takes two values and combines them and a fuse that can combine the results of that function, returns a fuse that works by calling the function twice with the arguments in different orders and fusing the results.
