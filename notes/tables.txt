Cene keeps track of stateful external resources using hierarchical paths. Thus, for a framework or interpreter to *pretend* to offer an external resource, it needs to be able to offer a path data structure that it can use to look up and track state. This is a use case for key-value tables.

Tables rely on the ability to compare the keys for equality. We usually don't want paths to be compared in an *ordered* way because that would make it possible to observe when one external resource identifier has been globally replaced by another (e.g. if the program has been serialized and resuscitated on another machine).

Cene is not statically typed (yet). If we want to provide table values with a well-defined and deterministic API, we need to ensure that the run time behavior of key comparisons does not expose implementation details of the keys. For instance, it should not let us compare name values to obtain a "less than" or "greater than" result. To accomplish this enforcement, we offer various ad hoc ways of building well-behaved comparators (and other kinds of well-behaved operators).

It will likely turn out to be simpler to add a static type system, in the long run. We may even find this approach turns into a sort of type system of its own.


\= A "dex" is a binary relation such that, wherever it is defined, it answers whether or not the given values are indistinguishable. (There is no "custom" sense of indistinguishability allowed here. If there is any Cene code at all that can distinguish the two values, they are not indistinguishable.)
\=
\= TODO: Document the fact that (call-dex ...) returns one of these results:
\=
\=   - (dex-result-incomparable (nope/nil) (nope/nil))
\=   - (dex-result-incomparable (yep/nil) (nope/nil))  ; representing that the first input is in the domain of this relation but the second one isn't
\=   - (dex-result-incomparable (nope/nil) (yep/nil))
\=   - (yep/nil)  ; representing equality
\=   - (yep <a foreign value representing "less than">)
\=   - (yep <a foreign value representing "greater than">)
\=
def-type (dex-result-incomparable left-is-comparable right-is-comparable)
def-type (dexable dex val)
  \= A value tagged with a dex that applies to it.
(dex-default <dex-for-trying-first> <dex-for-trying-second>)
(dex-give-up <ignored>)
(dex-string <ignored>)
  \= NOTE: Unlike most of these, (dex-string/nil) can distinguish values that might not have been distinguishable any other way.
(dex-name <ignored>)
  \= NOTE: Unlike most of these, (dex-name/nil) can distinguish values that might not have been distinguishable any other way.
(dex-dex <ignored>)
  \= NOTE: Unlike most of these, (dex-dex/nil) can distinguish values that might not have been distinguishable any other way. For instance, it can distinguish between (dex-default a b) and (dex-default b a).
(dex-merge <ignored>)
(dex-combine <ignored>)
(dex-struct cons <car-dex> <cdr-dex>)
(dex-by-own-method <dexable-get-method>)
  \= Given a dexable function, returns a dex that works by invoking that function with each value to get `(yep <dex>)` or `(nil)`, verifying that the two `<dex>` values are the same, and then proceeding to invoke that value.
(dex-fix <dexable-unwrap>)
  \= Given a dexable function, returns a dex that works by passing itself to the function and then invoking the resulting dex.
(dex-table <val-dex>)
(call-dex <dex> <a> <b>)
(in-dex <dex> <x>)

\= A "merge" is a binary operation that is commutative, associative, and idempotent wherever it is defined.
\=
\= TODO: There's something interesting we might be able to do here. Some values may not let us compute an easy yes or no answer as to whether they're indistinguishable because the only way to distinguish them is to send them into the outside world and wait for the ripples to show up. For instance, a message that means "Please send a response eventually" and a message that means "Please don't send a response ever" might only be distinguishable if and when a response arrives. If a response doesn't arrive, we can't destinguish them yet. While we can't define a dex for these two messages (because that dex itself would be a way to distinguish them), we can define a merge that combines them into a result with maximal feedback or a result with minimal feedback. There might be something having to do with definition lookups or OWA extensibility that can make practical use of this technique.
\=
(merge-dex <dex>)
  \= NOTE: This only processes the dex operation once, calling it with the two values being merged. It doesn't sanity-check that the dex is reflexive for either argument.
(merge-default <merge-for-trying-first> <merge-for-trying-second>)
(merge-struct cons <car-merge> <cdr-merge>)
(merge-by-own-method <dexable-get-method>)
  \= Given a dexable function, returns a merge that works by invoking that function with each value to get `(yep <merge>)` or `(nil)`, verifying that the two `<merge>` values are the same, invoking that value, and invoking the function on the result again to make sure it yields the same `<merge>`. That final check makes sure this operation is associative.
(merge-fix <dexable-unwrap>)
  \= Given a dexable function, returns a merge that works by passing itself to the function and then invoking the resulting merge.
(merge-table <val-merge>)
(call-merge <merge> <a> <b>)

\= A "combine" is a binary operation that is commutative and associative wherever it is defined.
\=
(combine-merge <merge>)
(combine-default <combine-for-trying-first> <combine-for-trying-second>)
(combine-struct cons <car-combine> <cdr-combine>)
(combine-by-own-method <dexable-get-method>)
  \= Given a dexable function, returns a combine that works by invoking that function with each value to get `(yep <combine>)` or `(nil)`, verifying that the two `<combine>` values are the same, invoking that value, and invoking the function on the result again to make sure it yields the same `<combine>`. That final check makes sure this operation is associative.
(combine-fix <dexable-unwrap>)
  \= Given a dexable function, returns a combine that works by passing itself to the function and then invoking the resulting combine.
(combine-table <val-combine>)
(call-combine <combine> <a> <b>)
\= TODO: Add some way to combine numbers by addition. Figure out if there's a way to do it that is compatible with various number encodings or other commutative monoids.

(table-empty <ignored>)
(table-shadow <dexable-key> <maybe-val> <table>)
(table-get <dexable-key> <table>)
(table-default <table-for-trying-first> <table-for-trying-second>)
(table-map-combine <table> <init-component> <combine> <val-to-component>)
  \= NOTE: Due to `table-map-combine`, clients can see the contents of the table as a finite (and closed world assumption) multiset of values, even if they don't have the keys.
  \=
  \= If you want a table where clients can iterate over the keys too, make a table where the values are key-value pairs.
  \=
  \= If you want a table where clients can't see the values unless they know the keys, try using values that are themselves encapsulated, or try holding the table inside something encapsulated. (This is really open-ended advice, but there are also many possible interpretations of this requirement.)
  \=
  \= If you want a table where multiplicity of values doesn't matter, try defining an encapsulated type that replicates most of the table operations but requires a dex for values (in addition to a dex for keys) and only allows `table-map-combine` for a merge, not a general combine.
  \=
  \= If you want a table that follows the open world assumption, first follow the strategy to define a table type where multiplicity doesn't matter, and then redesign the `table-empty` operation to insert a single dummy value that the clients' merge operations will not know how to deconstruct. Pay careful attention to the `dex-table` operation; it might take more than the current elements to determine whether two open sets are equal, if they're not approaching the "same" open world.
  \=
  \= If you want an orderless collection whose equality with other collections is based only on what elements are present, and not which keys they're looked up by, try using the same value as both the key and the value.
  \=
  \= NOTE: To model a similar data structure where clients need to have the keys to see the values, simply define an encapsulated struct containing a table, and define only a subset of the table operations for that struct. except `table-map-combine` and `dex-table`. (TODO: If we want ephemeron tables in Cene, we might need to add another table type like this.)
  \= TODO: Make sure we can model a data structure on
  \= TODO: Reconsider this. If this kind of table is something everyone can iterate over, even if they don't have all the keys, then how would we express a table where someone does need the keys to iterate?
(defn table-zip a b func ...)
  where (func maybe-a-val maybe-b-val)
  \= Given two tables and a function to combine values, makes a new table by iterating over the tables' combined set of keys, calling the function with both tables' `(yep ...)` or `(nil)` values for the keys, and using the function's `(yep ...)` or `(nil)` result to determine the value for the final table. The function will never be called with `(nil)` and `(nil)`.

\= NOTE: We can't have (dex-map <dexable-func> <result-dex>) because it might call things equivalent that are distinguishable from each other, which would make a (merge-dex ...) stop being commutative.

\= NOTE: We can't have (combine-map <dexable-func> <result-combine>) because it might not be associative. For the same reason, we can't have this, either:
\=
\= (combine-by-calling-twice <dexable-func> <result-combine>)
\=   \= Given a dexable function that takes two values and combines them and a combine that can combine the results of that function, returns a combine that works by calling the function twice with the arguments in different orders and combining the results.
