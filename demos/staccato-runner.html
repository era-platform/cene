<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<!--
staccato-runner.html (part of Era)
Copyright 2015 Ross Angle. Released under the MIT License.
-->
<title>Era Staccato demo</title>
<style type="text/css">
textarea { display: block; }
</style>
</head>
<body>
<p><a href="https://github.com/rocketnia/era"
    >View the Era project on GitHub.</a></p>

<p>This file merely loads Staccato without actually using it for
much. Check the console to see if there are errors. If there aren't,
great! Nothing to see here.</p>

<script type="text/plain" id="stc-prelude">

\ NOTE: This has been pasted from era-staccato-lib.stc, but it's not
\ the whole file yet. The whole file would probably have bugs.


\ These are utilities written in a macro layer over Staccato. For now,
\ I'm porting the utilities from era-avl.js. (Many of the utilities
\ were actually ported from era-staccato-lib.js and
\ era-staccato-lib-gensym.js, which were ported from era-avl.js.)
\
\ See era-staccato.js for more information about what Staccato is.


\ NOTE: This file depends only on these macros, which are implemented
\ in era-staccato-lib-runner.js:
\
\ def-type defn case caselet cast c c-new err fn run-defs test let


\ ===== Lists and boolean tags =======================================

(def-type cons car cdr)
(def-type yep val)
(def-type nope val)
(def-type nil)

(defn foldl-short state list combiner
  (cast list cons first rest nope.state
  /caselet combiner-result (c combiner state first)
    yep result combiner-result
    nope result (c-new foldl-short result rest combiner)
    err.\-qq[Expected a combiner-result of type yep or nope]))

(defn foldl state list combiner
  (cast list cons first rest state
  /c-new foldl (c combiner state first) rest combiner))

(defn foldl-double-short state list-a list-b combiner
  (cast list-a cons first-a rest-a nope.state
  /cast list-b cons first-b rest-b nope.state
  /caselet combiner-result (c combiner state first-a first-b)
    
    yep result combiner-result
    
    nope result
    (c-new foldl-double-short result list-a list-b combiner)
    
    err.\-qq[Expected a combiner-result of type yep or nope]))

(defn foldl-double state list-a list-b combiner
  (case
    (foldl-double-short state list-a list-b /fn state elem-a elem-b
      (nope/c combiner state elem-a elem-b))
    nope result result
    err.\-qq[Internal error]))

(defn rev-onto target source
  (foldl target source /fn state elem /cons elem state))

(defn rev source
  (rev-onto (nil) source))

(defn append past rest
  (rev-onto rest rev.past))

(defn map list func
  (rev/foldl (nil) list /fn state elem /cons (c func elem) state))

(defn any list func
  (foldl-short (nil) list /fn state elem
    (caselet func-result (c func elem)
      yep result func-result
      nope result (nope/nil)
      err.\-qq[Expected a func-result of type yep or nope])))

(defn any-double list-a list-b func
  (foldl-double-short (nil) list-a list-b /fn state elem-a elem-b
    (caselet func-result (c func elem-a elem-b)
      yep result func-result
      nope result (nope/nil)
      err.\-qq[Expected a func-result of type yep or nope])))

(defn not-yep-nope yep-nope
  (case yep-nope
    yep val nope.val
    nope val yep.val
    err.\-qq[Expected a yep-nope of type yep or nope]))

(defn or-yep-nope a b
  (case a yep - a
  /case b yep - b
  /nope/nil))

(defn and-yep-nope a b
  (case a nope - a
  /case b nope - b
  /yep/nil))

(defn xor-yep-nope a b
  (case a yep -
    (case b yep - (nope/nil) a)
    (case b yep - b (nope/nil))))

(defn yep-nope-swap a b
  (case a yep - b not-yep-nope.b))

(defn all func list
  (not-yep-nope/any list /fn elem /not-yep-nope/c func elem))

(defn cut list-to-measure-by list-to-cut
  (foldl (cons (nil) list-to-cut) list-to-measure-by
  /fn state ignored-elem
    (cast state cons rev-before after
      err.\-qq[Internal error]
    /cast after cons first after
      err.\-qq[
        Expected a list-to-measure-by no longer than the list-to-cut]
    /cons (cons first rev-before) after)))

(defn tails lists
  (cast lists cons list-a list-b
    err.\-qq[Expected a lists value of type cons]
  /cast list-a cons elem-a list-a lists
  /cast list-b cons elem-b list-b lists
  /c-new tails /cons list-a list-b))


\ ===== "Fixnum operations," a generic interface for bigint digits ===

\ NOTE: Although they're separated into different sections, fixops and
\ digpairs are actually interdependent.

(def-type
  fixops zero one complement compare plus minus times dual-div)
(def-type carried main carry)

(defn fixops-zero fixops
  (cast fixops
    fixops zero one complement compare plus minus times dual-div
    err.\-qq[Expected a fixops value of type fixops]
    zero))

(defn fixops-one fixops
  (cast fixops
    fixops zero one complement compare plus minus times dual-div
    err.\-qq[Expected a fixops value of type fixops]
    one))

(defn fixops-complement fixops
  (cast fixops
    fixops zero one complement compare plus minus times dual-div
    err.\-qq[Expected a fixops value of type fixops]
    complement))

(defn fixops-compare fixops
  (cast fixops
    fixops zero one complement compare plus minus times dual-div
    err.\-qq[Expected a fixops value of type fixops]
    compare))

(defn fixops-plus fixops
  (cast fixops
    fixops zero one complement compare plus minus times dual-div
    err.\-qq[Expected a fixops value of type fixops]
    plus))

(defn fixops-minus fixops
  (cast fixops
    fixops zero one complement compare plus minus times dual-div
    err.\-qq[Expected a fixops value of type fixops]
    minus))

(defn fixops-times fixops
  (cast fixops
    fixops zero one complement compare plus minus times dual-div
    err.\-qq[Expected a fixops value of type fixops]
    times))

(defn fixops-dual-div fixops
  (cast fixops
    fixops zero one complement compare plus minus times dual-div
    err.\-qq[Expected a fixops value of type fixops]
    dual-div))

(defn fixops-is-zero fixops n
  (case (fixops-compare fixops fixops-zero.fixops n) nil
    (yep/nil)
    (nope/nil)))


\ TODO: Paste the rest of era-staccato-lib.stc into this file.


(run-defs)

(test/rev/cons (yep/nil) /cons (nope/nil) /nil)

(test/rev/nil)

(test/not-yep-nope/yep/nil)

(test
  (let x (nope/nil) y (yep/nil)
  /let x y y x
  /cons x y))

</script>

<script type="text/javascript" src="../src/era-misc-strmap-avl.js">
    </script>
<script type="text/javascript" src="../src/era-misc.js"></script>
<script type="text/javascript" src="../src/era-reader.js"></script>
<script type="text/javascript" src="../src/era-staccato.js"></script>
<script type="text/javascript"
    src="../src/era-staccato-builders-gensym.js"></script>
<script type="text/javascript"
    src="../src/era-staccato-lib-runner.js"></script>
<script type="text/javascript">"use strict";

window.onload = function () {
    function generateOutput() {
        var startMillis = new Date().getTime();
        
        var code = readAll(
            document.getElementById( "stc-prelude" ).firstChild.data
            );
        
        arrAny( code, function ( tryExpr ) {
            if ( !tryExpr.ok ) {
                console.err( tryExpr.msg );
                return true;
            }
            
            processTopLevelReaderExpr( tryExpr.val );
            return false;
        } );
        
        
        var runMillis = new Date().getTime() - startMillis;
        // TODO: Either remove this or display it more prominently.
        console.log( "Ran for " + runMillis / 1000 + " seconds." );
    }
    generateOutput();
};
</script>
</body>
</html>
