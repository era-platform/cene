<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<!--
penknife.html (part of Era)
Copyright 2013 Ross Angle. Released under the MIT License.
-->
<title>Era Penknife demo</title>
<style type="text/css">
textarea { display: block; }
</style>
</head>
<body>
<p><a href="https://github.com/rocketnia/era"
    >View the Era project on GitHub.</a></p>
<p><a href="https://github.com/rocketnia/penknife"
    >View the old Penknife project on GitHub.</a></p>

<script type="text/plain" id="pk-prelude">
(defval quote.list /fn x x)

(defmacro quote.fn-with-args /fn args
/let-list (op-fork body get-fork gensym-base) args
/let-list (arglist body) body
/let-list (g-args) (list/pair-name gensym-base quote.args)
/macroexpand-to-fork
  (list quote.fn g-args (list quote.let-list arglist g-args body))
  get-fork
  (pair-name gensym-base quote.body-of-fn-with-args))

(defval quote.fix
/let-list (fix)
    (list/fn-with-args (fix func)
      (fn args (call func (cons (fix fix func) args))))
/fn-with-args (func)
  (fix fix func))

(defval quote.not /fn-with-args (x)
/if x (nil) (yep/nil))

(defval quote.isa /fn-with-args (tag-name x)
; TODO: Make the error message a raw string rather than a string-name.
/if (not/is-a-name get-tag-name.tag-name)
  (raise quote.s(Called isa with a non-name tag name))
  (name-eq tag-name get-tag-name.x))

; TODO: Rewrite this so that it doesn't duplicate a linear struct.
(defval quote.is-a-struct-with-tag /fn-with-args (tag-name x)
; TODO: Make the error message a raw string rather than a string-name.
/if (not/is-a-name get-tag-name.tag-name)
  (raise
    quote.s(Called is-a-struct-with-tag with a non-name tag name))
/if (not/is-a-struct x)
  (nil)
  (isa tag-name x))

(defmethod quote.len quote.(collection))
(set-impl quote.len quote.nil /fn-with-args (collection)
  (nil))
(set-impl quote.len quote.cons /fn-with-args (collection)
/let-list (first rest) struct-get-args.collection
  (succ len.rest))

; TODO: Rewrite this so that it doesn't duplicate a linear struct.
(defmacro quote.if-struct
/fn-with-args (op-fork body get-fork gensym-base)
/let-list (tag-name args x then else) body
/let-list (g-struct) (list/pair-name gensym-base quote.struct)
/macroexpand-to-fork
  (list quote.let-list (list g-struct) (list quote.list x)
  /list quote.if
      (list quote.is-a-struct-with-tag
        (list quote.quote tag-name) g-struct)
    (list quote.let-list args (list quote.struct-get-args g-struct)
      then)
    else)
  get-fork
  (pair-name gensym-base quote.body-of-if-struct))

(defval quote.rev-append /fix/fn-with-args (rev-append lst rev-lst)
/if-struct cons (first rest) lst
  (rev-append rest (cons first rev-lst))
  rev-lst)

; TODO: Add the following code to this prelude once we can actually
; run it. Right now it causes a JavaScript stack overflow error, but
; we can get around that by implementing an alternative to syncYoke.
</script>
<script type="text/plain" id="pk-prelude-pending">
(defval quote.take /fn-with-args (take num lst)
/if-struct succ (pred) num
  (if-struct cons (first rest) lst
    (let-list (heads tail) (take take pred rest)
      (list (cons first heads) tail))
  /if-struct nil () lst
    (raise
      quote.s(Called take with a number greater than the length of the list))
    (raise quote.s(Called take with a non-list list)))
/if-struct nil () num
  (if-struct cons (first rest) lst
    (list (nil) lst)
  /if-struct nil () lst
    (list (nil) lst)
    (raise quote.s(Called take with a non-list list)))
  (raise quote.s(Called take with a non-nat number)))

(defmacro quote.let-list-and-rest
/fn-with-args (op-fork body get-fork gensym-base)
/let-list (head-vars tail-var lst body) body
/let-list (g-heads) (list/pair-name gensym-base quote.head)
/let-list (g-tail) (list/pair-name gensym-base quote.tail)
/macroexpand-to-fork
  ; TODO: Figure out a way to insert a natural number into code,
  ; rather than generating a call to `len` like this.
  (list quote.let-list (cons g-heads g-tail)
      (list quote.take quote.take
        (list quote.len (list quote.quote head-vars)) lst)
  /list quote.let-list head-vars g-heads
  /list quote.let-list list.tail-var (list quote.list g-tail)
    body)
  get-fork
  (pair-name gensym-base quote.body-of-let-list-and-rest))

(defmacro quote.fn-with-varargs
/fn-with-args (op-fork body get-fork gensym-base)
/let-list (arglist rest body) body
/let-list (g-args) (list/pair-name gensym-base quote.args)
/macroexpand-to-fork
  (list quote.fn g-args
    (list quote.let-list-and-rest arglist rest g-args body))
  get-fork
  (pair-name gensym-base quote.body-of-fn-with-args))
</script>

<textarea id="code-in-textarea" cols="80" rows="24">
(nil)
(yep (nil))
(cons (nil) (nil))
(yep/nil) :cons (nil)
((fn x (cons x x)) (nil) (nil))
((fn x ((fn x (cons x x)) x x)) (nil) (nil))

(list quote.a quote.b)

(defval quote.curried-example /fn x /fn y (cons y x))
((curried-example (nil)) (yep/nil))

(let-list (a b) (list quote.foo quote.bar) a)
(let-list (a b) (list quote.foo quote.bar) (list a a b b a))

(if (nil) quote.foo quote.bar)
(if (yep/nil) quote.foo quote.bar)
(let-list (a b) (list quote.foo quote.bar)
  (if (nil)
    (list a a b)
    (list b b a)))
( (fn args
    (let-list (a) args
      a))
  (nil))

( (fn-with-args (a b c)
    (list b b c))
  quote.foo quote.bar quote.baz)

(call-with-mbox-env/fn args /let-list (mbox-env) args
/let-list (my-mbox) (list/mbox-new mbox-env (succ/nil))
/let-list (a) (list/mbox-get mbox-env my-mbox)
/let-list (-) (list/mbox-set mbox-env my-mbox succ.a)
/let-list (b) (list/mbox-get mbox-env my-mbox)
/let-list (-) (list/mbox-set mbox-env my-mbox succ.b)
/let-list (c) (list/mbox-get mbox-env my-mbox)
/list a b c)

(rev-append (list quote.a quote.b quote.c) (list))

(if-struct cons (first rest) (list quote.foo quote.bar quote.baz)
  (list first rest)
  (nil))

; TODO: Once we add `fn-with-varargs` to the prelude, uncomment this.
;( (fn-with-varargs (a b c) rest
;    (list a b c rest))
;  quote.a quote.b quote.c quote.d quote.e)
</textarea>
<button id="go">Execute</button>
<textarea id="result" disabled cols="80" rows="24"></textarea>

<script type="text/javascript" src="../src/era-misc.js"></script>
<script type="text/javascript" src="../src/era-reader.js"></script>
<script type="text/javascript" src="../src/era-penknife.js"></script>
<script type="text/javascript">"use strict";

// Turns out the reader is very slow right now because it makes
// frequent use of setTimeout() for control flow. This redefinition of
// `defer` is hackish, but it definitely fixes the speed issue.
var deferTrampolineEvents = [];
defer = function ( func ) {
    deferTrampolineEvents.push( func );
};
function runDeferTrampoline() {
    while ( deferTrampolineEvents.length !== 0 )
        deferTrampolineEvents.pop()();
};

function pkReadAll( string, then ) {
    function read( stream, onEnd, onFailure, onSuccess ) {
        reader( {
            stream: stream,
            readerMacros: readerMacros,
            heedsCommandEnds: true,
            infixLevel: 0,
            infixState: { type: "empty" },
            end: function ( $ ) {
                if ( $.infixState.type === "ready" )
                    $.then( { ok: true, val: $.infixState.val } );
                else
                    onEnd();
                runDeferTrampoline();
            },
            unrecognized: function ( $ ) {
                $.then( { ok: false,
                    msg: "Encountered an unrecognized character" } );
                runDeferTrampoline();
            },
            then: function ( result ) {
                if ( result.ok )
                    onSuccess( result.val );
                else
                    onFailure( result.msg );
            }
        } );
        runDeferTrampoline();
    }
    var stream = stringStream( string );
    readNext( [] );
    function readNext( resultsSoFar ) {
        read( stream, function () {  // onEnd
            then( resultsSoFar );
        }, function ( message ) {  // onFailure
            then( resultsSoFar.concat(
                [ { ok: false, msg: message } ] ) );
        }, function ( result ) {  // onSuccess
            readNext( resultsSoFar.concat(
                [ { ok: true, val: result } ] ) );
        } );
    }
}

window.onload = function () {
    function generateOutput() {
        var penknife = makePkRuntime();
        pkReadAll(
            document.getElementById( "pk-prelude" ).firstChild.data,
            function ( preludeResults ) {
        pkReadAll(
            document.getElementById( "code-in-textarea" ).value,
            function ( textareaResults ) {
        
        var results = [].concat(
            arrMap( preludeResults, function ( result ) {
                return { result: result, displayThisResult: false };
            } ),
            arrMap( textareaResults, function ( result ) {
                return { result: result, displayThisResult: true };
            } )
        );
        
        function reportError( result, errorIntro ) {
            if ( result.tag === "nope" ) {
                displays.push(
                    "" + errorIntro + " error: " + result.ind( 0 ) );
                return true;
            } else if ( result.tag !== "yep" ) {
                displays.push(
                    "" + errorIntro + " error (poorly wrapped): " +
                    result );
                return true;
            } else {
                // This is a triumph.
                return false;
            }
        }
        var displays = [];
        for ( var i = 0, n = results.length; i < n; i++ ) {
            var result = results[ i ];
            if ( !result.result.ok ) {
                displays.push( "Parse error: " + result.result.msg );
                break;
            }
            var macroexpanded =
                penknife.conveniences_macroexpandArrays(
                    result.result.val ).result;
            if ( reportError( macroexpanded, "Macroexpansion" ) ) {
                break;
            } else {
//                displays.push(
//                    "Macroexpansion: " + macroexpanded.ind( 0 ) );
            }
            var macroexpandedDrop =
                penknife.conveniences_pkDrop( macroexpanded ).result;
            if ( reportError( macroexpandedDrop,
                "Macroexpansion result drop" ) )
                break;
            
            var interpreted = penknife.conveniences_interpretBinding(
                macroexpanded.ind( 0 ) ).result;
            if ( reportError( interpreted, "Interpretation" ) ) {
                break;
            } else {
                if ( result.displayThisResult ) {
                    displays.push( "" + interpreted.ind( 0 ) );
//                    displays.push( "" );
                }
            }
            var interpretedDrop =
                penknife.conveniences_pkDrop( interpreted ).result;
            if ( reportError( interpretedDrop,
                "Interpretation result drop" ) )
                break;
            
            var defined =
                penknife.conveniences_runDefinitions().result;
            if ( reportError( defined, "Definition" ) )
                break;
            var definedDrop =
                penknife.conveniences_pkDrop( defined ).result;
            if ( reportError( definedDrop,
                "Definition result drop" ) )
                break;
        }
        document.getElementById( "result" ).value =
            displays.join( "\n" );
        
        } );
        } );
    }
    document.getElementById( "go" ).onclick = generateOutput;
    generateOutput();
};
</script>
</body>
</html>
