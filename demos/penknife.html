<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<!--
penknife.html (part of Era)
Copyright 2013 Ross Angle. Released under the MIT License.
-->
<title>Era Penknife demo</title>
<style type="text/css">
textarea { display: block; }
</style>
</head>
<body>
<p><a href="https://github.com/rocketnia/era"
    >View the Era project on GitHub.</a></p>
<p><a href="https://github.com/rocketnia/penknife"
    >View the old Penknife project on GitHub.</a></p>

<script type="text/plain" id="pk-prelude">

(defval qname.list /fn x x)

(defmacro qname.let /fn args
/let-list (op-fork body get-fork gensym-base) args
/let-list (var val body) body
/macroexpand-to-fork
  (list qname.let-list list.var (list qname.list val) body)
  get-fork
  gensym-base)

; TODO: See if we should rewrite this as a built-in utility. Even
; though it technically works for now, it's way too much effort to go
; to for an incomplete string syntax that's only used for a few
; built-in error messages.
(defmacro qname.err /fn args
/let-list (op-fork body get-fork gensym-base) args
/let-list (msg-as-name) body
/let msg-as-nl-name linear-as-nonlinear.msg-as-name
/let unpad-force
    (fn args /let-list (padded) args
    /let-list (end-minus-one) (struct-get-args string-len.padded)
      (string-cut padded (succ/succ/nil) end-minus-one))
/let raise-own
    (fn args /let-list (name) args
    /let-list (padded) struct-get-args.name
      (raise unpad-force.padded))
/let unpad
    (fn args /let-list (padded) args
    /let len string-len.padded
    /if (qualified-name-eq
          qname.succ (nl-get-tag-name linear-as-nonlinear.len))
      (let-list (end-minus-one) struct-get-args.len
        (string-cut padded (succ/succ/nil) end-minus-one))
      (raise-own
        quote.s[Expanded err with a message that wasn't long enough]))
/if (qualified-name-eq
      qname.string-name nl-get-tag-name.msg-as-nl-name)
  (let-list (msg-as-padded-string)
      (struct-get-args nl-get-linear.msg-as-nl-name)
    (macroexpand-to-fork
      (list qname.raise /list qname.quote unpad.msg-as-padded-string)
      get-fork
      gensym-base))
  (raise-own
    quote.s[Expanded err with a message that wasn't a string-name]))

(defmacro qname.fn-with-args /fn args
/let-list (op-fork body get-fork gensym-base) args
/let-list (arglist body) body
/let g-args (pair-name gensym-base quote.args)
/macroexpand-to-fork
  (list qname.fn g-args (list qname.let-list arglist g-args body))
  get-fork
  (pair-name gensym-base quote.body-of-fn-with-args))

(defval qname.fix
/let fix
    (fn-with-args (fix func)
      (fn args (call func (cons (fix fix func) args))))
/fn-with-args (func)
  (fix fix func))

(defval qname.not /fn-with-args (x)
/if x (nil) (yep/nil))

(defval qname.nl-isa /fn-with-args (tag-name nl)
/if (not is-a-qualified-name.tag-name)
  err.s[Called nl-isa with a tag name that wasn't a qualified name]
  (qualified-name-eq tag-name nl-get-tag-name.nl))

(defval qname.nl-is-a-struct-with-tag /fn-with-args (tag-name nl)
/if (not is-a-qualified-name.tag-name)
  err.s[Called nl-is-a-struct-with-tag with a tag name that wasn't a qualified name]
/if (not/nl-is-a-struct nl)
  (nil)
  (nl-isa tag-name nl))

; TODO: We have another definition of `len` below that's much shorter.
; See if we should replace it with this method-based version.
;
;(defmethod qname.len quote.(collection))
;(set-impl qname.len qname.nil /fn-with-args (collection)
;  (nil))
;(set-impl qname.len qname.cons /fn-with-args (collection)
;/let-list (first rest) struct-get-args.collection
;  (succ len.rest))

(defmacro qname.if-struct
/fn-with-args (op-fork body get-fork gensym-base)
/let-list (tag-name args x then else) body
/let g-x (pair-name gensym-base quote.x)
/let g-nl-x (pair-name gensym-base quote.nl-x)
/let g-ignored (pair-name gensym-base quote.ignored)
/macroexpand-to-fork
  (list qname.let g-nl-x (list qname.linear-as-nonlinear x)
  /list qname.let g-x (list qname.nl-get-linear g-nl-x)
  /list qname.if
      (list qname.nl-is-a-struct-with-tag
        (list qname.qname tag-name) g-nl-x)
    (list qname.let-list args (list qname.struct-get-args g-x)
      then)
    ; Let `g-x` be dropped.
    else)
  get-fork
  (pair-name gensym-base quote.body-of-if-struct))

(defval qname.fold-nat /fix/fn-with-args (foldl-nat init nat func)
/if-struct succ (pred) nat
  (foldl-nat func.init pred func)
/if-struct nil () nat
  init
  err.s[Called fold-nat with a non-nat number])

(defval qname.is-a-list /fn-with-args (x)
/if-struct cons (first rest) x
  (yep/nil)
/if-struct nil () x
  (yep/nil)
  (nil))

(defval qname.foldl /fix/fn-with-args (foldl init lst func)
/if-struct cons (first rest) lst
  (foldl (func init first) rest func)
/if-struct nil () lst
  init
  err.s[Called foldl with a non-list list])

(defval qname.rev-append /fn-with-args (lst rev-lst)
  (foldl rev-lst lst /fn-with-args (rev-lst elem)
    (cons elem rev-lst)))

(defval qname.rev /fn-with-args (lst)
  (rev-append lst (nil)))

(defval qname.mappend /fn-with-args (lst func)
  (rev/foldl (nil) lst /fn-with-args (rev-result elem)
    (rev-append func.elem rev-result)))

(defval qname.map /fn-with-args (lst func)
  (mappend lst /fn-with-args (elem)
    (list func.elem)))

(defval qname.len /fn-with-args (lst)
  (foldl (nil) lst /fn-with-args (len elem)
    succ.len))

(defval qname.nat-eq /fix/fn-with-args (nat-eq a b)
/if-struct succ (pred-a) a
  (if-struct succ (pred-b) b
    (nat-eq pred-a pred-b)
  /if-struct nil () b
    (nil)
    err.s[Called nat-eq with a non-nat second argument])
/if-struct nil () a
  (if-struct succ (b-pred) b
    (nil)
  /if-struct nil () b
    (yep/nil)
    err.s[Called nat-eq with a non-nat second argument])
  err.s[Called nat-eq with a non-nat first argument])

; NOTE: Back when we used debuggableSyncYoke, this definition caused a
; JavaScript stack overflow error. Now the above code might cause it
; instead because it uses more layers of macros.
(defval qname.take /fix/fn-with-args (take num lst)
/if-struct succ (pred) num
  (if-struct cons (first rest) lst
    (let-list (heads tail) (take pred rest)
      (list (cons first heads) tail))
  /if-struct nil () lst
    err.s[Called take with a number greater than the length of the list]
    err.s[Called take with a non-list list])
/if-struct nil () num
  (if-struct cons (first rest) lst
    (list (nil) lst)
  /if-struct nil () lst
    (list (nil) lst)
    err.s[Called take with a non-list list])
  err.s[Called take with a non-nat number])

(defmacro qname.defmacro-codegen
/fn-with-args (op-fork body get-fork gensym-base)
/let-list (name body-var gensym-names codegen-body) body
/let gbase (pair-name gensym-base quote.defmacro-codegen)
/let gbase-gensyms (pair-name gbase quote.gensyms)
/let g-op-fork (pair-name gbase-gensyms quote.g-op-fork)
/let g-get-fork (pair-name gbase-gensyms quote.g-get-fork)
/let g-gensym-base (pair-name gbase-gensyms quote.g-gensym-base)
/let g-gbase (pair-name gbase-gensyms quote.g-gbase)
/let g-gbase-gensyms (pair-name gbase-gensyms quote.g-gbase-gensyms)
/macroexpand-to-fork
  (list qname.defmacro (list qname.qname name)
  /list qname.fn-with-args
    (list g-op-fork body-var g-get-fork g-gensym-base)
  /list qname.let g-gbase
    (list qname.pair-name g-gensym-base (list qname.quote name))
  /list qname.let g-gbase-gensyms
    (list qname.pair-name g-gbase (list qname.quote quote.gensyms))
  /list qname.let-list gensym-names
    (cons qname.list /map gensym-names /fn-with-args (gensym-name)
      (list qname.pair-name g-gbase-gensyms
        (list qname.quote gensym-name)))
  /list qname.macroexpand-to-fork
    codegen-body
    g-get-fork
    (list qname.pair-name g-gbase
      (list qname.quote quote.macroexpansion)))
  get-fork
  (pair-name gbase quote.macroexpansion))

(defmacro-codegen let-list-and-rest body (g-heads g-tail)
/let-list (head-vars tail-var lst body) body
  ; TODO: Figure if we should be inserting a natural number (a
  ; non-list, non-name value) into code like this.
  (list qname.let-list (list g-heads g-tail)
      (list qname.take (list qname.quote len.head-vars) lst)
  /list qname.let-list head-vars g-heads
  /list qname.let tail-var g-tail
    body))

(defmacro-codegen fn-with-varargs body (g-args)
/let-list (arglist rest body) body
  (list qname.fn g-args
  /list qname.let-list-and-rest arglist rest g-args
    body))

(defval qname.append /fn-with-varargs () lsts
  (mappend lsts /fn-with-args (lst)
    lst))

; TODO: See if this should just be internal to the definition of `qq`.
(defval qname.expand-qq
/fix/fn-with-args
  (expand-qq qq-name uq-name uqs-name return-list level x)
/let recur
  (fn-with-args (return-list level x)
    (expand-qq qq-name uq-name uqs-name return-list level x))
/let as-list
  (fn-with-args (expr)
    (if return-list (list qname.list expr) expr))
/let parse-escape
  (fn-with-args (name)
    (if-struct cons (first rest) x
      (if (nat-eq len.x (succ/succ/nil))
        (let-list (first second) x
        /if is-an-unqualified-name.first
          (if (unqualified-name-eq first name)
            yep.second
            (nil))
          (nil))
        (nil))
      (nil)))
; TODO: Remove some of the duplicate branches from the following code.
/if-struct nil () level
  (if-struct yep (x) parse-escape.qq-name
    (as-list/list qname.list (list qname.quote qq-name)
      (recur (nil) succ.level x))
  /if-struct yep (x) parse-escape.uq-name
    as-list.x
  /if-struct yep (x) parse-escape.uqs-name
    (if return-list
      x
      err.q[Called qq with a tree containing uqs in an incorrect place])
  /if is-a-list.x
    (as-list/cons qname.append /map x /fn-with-args (elem)
      (recur (yep/nil) level elem))
    (as-list/list qname.qname x))
/if-struct succ (pred-level) level
  (if-struct yep (x) parse-escape.qq-name
    (as-list/list qname.list (list qname.quote qq-name)
      (recur (nil) succ.level x))
  /if-struct yep (x) parse-escape.uq-name
    (as-list/list qname.list (list qname.quote uq-name)
      (recur (nil) pred-level x))
  /if-struct yep (x) parse-escape.uqs-name
    (as-list/list qname.list (list qname.quote uqs-name)
      (recur (nil) pred-level x))
  /if is-a-list.x
    (as-list/cons qname.append /map x /fn-with-args (elem)
      (recur (yep/nil) level elem))
    (as-list/list qname.qname x))
  err.s[Called expand-qq with a non-nat level])

(defmacro-codegen qq body ()
/let-list (tree) body
  (expand-qq quote.qq quote.uq quote.uqs (nil) (nil) tree))

</script>
<script type="text/plain">

(defmacro qname.let-list-and-rest
/fn-with-args (op-fork body get-fork gensym-base)
/let-list (head-vars tail-var lst body) body
/let g-heads (pair-name gensym-base quote.head)
/let g-tail (pair-name gensym-base quote.tail)
/macroexpand-to-fork
  ; TODO: Figure if we should be inserting a natural number (a
  ; non-list, non-name value) into code like this.
  (list qname.let-list (list g-heads g-tail)
      (list qname.take (list qname.quote len.head-vars) lst)
  /list qname.let-list head-vars g-heads
  /list qname.let tail-var g-tail
    body)
  get-fork
  (pair-name gensym-base quote.body-of-let-list-and-rest))
</script>

<textarea id="code-in-textarea" cols="80" rows="24">
(nil)
(yep (nil))
(cons (nil) (nil))
(yep/nil) :cons (nil)
((fn x (cons x x)) (nil) (nil))
((fn x ((fn x (cons x x)) x x)) (nil) (nil))

(list quote.a quote.b)

(defval qname.curried-example /fn x /fn y (cons y x))
((curried-example (nil)) (yep/nil))

(let-list (a b) (list quote.foo quote.bar) a)
(let-list (a b) (list quote.foo quote.bar) (list a a b b a))

(if (nil) quote.foo quote.bar)
(if (yep/nil) quote.foo quote.bar)
(let-list (a b) (list quote.foo quote.bar)
  (if (nil)
    (list a a b)
    (list b b a)))
( (fn args
    (let-list (a) args
      a))
  (nil))

( (fn-with-args (a b c)
    (list b b c))
  quote.foo quote.bar quote.baz)

(call-with-mbox-env/fn-with-args (mbox-env)
/let my-mbox (mbox-new mbox-env (succ/nil))
/let a (mbox-get mbox-env my-mbox)
/let - (mbox-set mbox-env my-mbox succ.a)
/let b (mbox-get mbox-env my-mbox)
/let - (mbox-set mbox-env my-mbox succ.b)
/let c (mbox-get mbox-env my-mbox)
/list a b c)

(rev-append (list quote.a quote.b quote.c) (list))

(if-struct cons (first rest) (list quote.foo quote.bar quote.baz)
  (list first rest)
  (nil))

(take (succ/succ/nil) quote.(a b c))

( (fn-with-varargs (a b c) rest
    (list a b c rest))
  quote.a quote.b quote.c quote.d quote.e)

(map (list (nil) (succ/nil) (succ/succ/nil)) succ)

; NOTE: These tests work, but they take a little too much time to
; execute.
; TODO: Speed 'em up.
qq.(foo bar)
qq.(foo uq.(succ/succ/nil))
qq.(foo uq.(succ/succ/nil) (uqs quote.(a b c)))
qq.(foo (uq.(succ/succ/nil) (uqs quote.(a b c)) bar))
qq.(foo ((qq uq.(succ/succ/nil)) (qq (uqs quote.(a b c))) bar))
qq.(foo ((qq (uq uq.(succ/succ/nil))) (qq (uqs quote.(a b c))) bar))

; Test that we we don't let local names hijack the qualified names
; used by macro-generated code.
(let append list qq.(a b c))

(defval qname.call-with-flow-grapher /fn-with-args (body)
/call-with-mbox-env/fn-with-args (mbox-env)
/let rev-junctions-mbox (mbox-new mbox-env (nil))
/let next-node-num-mbox (mbox-new mbox-env (nil))
/let num-strays-mbox (mbox-new mbox-env (succ/nil))
/let mget (fn-with-args (mbox) (mbox-get mbox-env mbox))
/let mset (fn-with-args (mbox val) (mbox-set mbox-env mbox val))
/let inc (fn-with-args (nat-mbox) (mset nat-mbox /succ mget.nat-mbox))
/let get-next-node-num
  (fn-with-args ()
  /let result mget.next-node-num-mbox
  /let - inc.next-node-num-mbox
    result)
/let get-next-node
  (fn-with-args ()
  /nonlinear-as-linear
    (list (get-next-node-num) (mbox-new mbox-env (nil)))
    
    ; Duplicating this value causes it to record a junction in the
    ; graph.
    (fn-with-args (inner-val num-dups)
    /let-list (num used-mbox) inner-val
    /if mget.used-mbox
      err.s[Can't duplicate a flow grapher that was already used]
    /let - (mset used-mbox (yep/nil))
    /let - (if-struct succ (pred) mget.num-strays-mbox
             (mset num-strays-mbox pred)
             err.s[Internal error when duplicating a flow grapher])
    /let result
      (rev/fold-nat (nil) num-dups /fn-with-args (rev-result)
        (let - inc.num-strays-mbox
          (cons (list (get-next-node-num) (mbox-new mbox-env (nil)))
            rev-result)))
    /let rev-junctions mget.rev-junctions-mbox
    /let - (mset rev-junctions-mbox
             (cons
               (list num
                 (map result /fn-with-args (entry)
                 /let-list (num used-mbox) entry
                   num))
               rev-junctions))
      result)
    
    ; Unwrapping this value is useless.
    (fn-with-args (inner-val)
      (nil)))
/let - (body/get-next-node)
/if-struct succ (pred) mget.num-strays-mbox
  err.s[Didn't consume all flow graphsrs in a call to call-with-flow-grapher]
  (rev mget.rev-junctions-mbox))

; Build a flow graph for some example code.
(call-with-flow-grapher/fn-with-args (n)
/let m (list n n)
  (list m m m))

</textarea>
<button id="go">Execute</button>
<textarea id="result" disabled cols="80" rows="24"></textarea>

<script type="text/javascript" src="../src/era-misc.js"></script>
<script type="text/javascript" src="../src/era-reader.js"></script>
<script type="text/javascript" src="../src/era-penknife.js"></script>
<script type="text/javascript">"use strict";

// Turns out the reader is very slow right now because it makes
// frequent use of setTimeout() for control flow. This redefinition of
// `defer` is hackish, but it definitely fixes the speed issue.
var deferTrampolineEvents = [];
defer = function ( func ) {
    deferTrampolineEvents.push( func );
};
function runDeferTrampoline() {
    while ( deferTrampolineEvents.length !== 0 )
        deferTrampolineEvents.pop()();
};

function pkReadAll( string, then ) {
    function read( stream, onEnd, onFailure, onSuccess ) {
        reader( {
            stream: stream,
            readerMacros: readerMacros,
            heedsCommandEnds: true,
            infixLevel: 0,
            infixState: { type: "empty" },
            end: function ( $ ) {
                if ( $.infixState.type === "ready" )
                    $.then( { ok: true, val: $.infixState.val } );
                else
                    onEnd();
                runDeferTrampoline();
            },
            unrecognized: function ( $ ) {
                $.then( { ok: false,
                    msg: "Encountered an unrecognized character" } );
                runDeferTrampoline();
            },
            then: function ( result ) {
                if ( result.ok )
                    onSuccess( result.val );
                else
                    onFailure( result.msg );
            }
        } );
        runDeferTrampoline();
    }
    var stream = stringStream( string );
    readNext( [] );
    function readNext( resultsSoFar ) {
        read( stream, function () {  // onEnd
            then( resultsSoFar );
        }, function ( message ) {  // onFailure
            then( resultsSoFar.concat(
                [ { ok: false, msg: message } ] ) );
        }, function ( result ) {  // onSuccess
            readNext( resultsSoFar.concat(
                [ { ok: true, val: result } ] ) );
        } );
    }
}

window.onload = function () {
    function generateOutput() {
        var startMillis = new Date().getTime();
        var penknife = makePkRuntime();
        pkReadAll(
            document.getElementById( "pk-prelude" ).firstChild.data,
            function ( preludeResults ) {
        pkReadAll(
            document.getElementById( "code-in-textarea" ).value,
            function ( textareaResults ) {
        
        var results = [].concat(
            arrMap( preludeResults, function ( result ) {
                return { result: result, displayThisResult: false };
            } ),
            arrMap( textareaResults, function ( result ) {
                return { result: result, displayThisResult: true };
            } )
        );
        
        function reportError( result, errorIntro ) {
            if ( result.tag === "nope" ) {
                displays.push(
                    "" + errorIntro + " error: " + result.ind( 0 ) );
                return true;
            } else if ( result.tag !== "yep" ) {
                displays.push(
                    "" + errorIntro + " error (poorly wrapped): " +
                    result );
                return true;
            } else {
                // This is a triumph.
                return false;
            }
        }
        var displays = [];
        for ( var i = 0, n = results.length; i < n; i++ ) {
            var result = results[ i ];
            if ( !result.result.ok ) {
                displays.push( "Parse error: " + result.result.msg );
                break;
            }
            var macroexpanded = penknife.conveniences_runSyncYoke(
                penknife.conveniences_macroexpandArrays(
                    result.result.val ) ).result;
            if ( reportError( macroexpanded, "Macroexpansion" ) ) {
                break;
            } else {
//                displays.push(
//                    "Macroexpansion: " + macroexpanded.ind( 0 ) );
            }
            var macroexpandedDrop = penknife.conveniences_runSyncYoke(
                penknife.conveniences_pkDrop( macroexpanded )
            ).result;
            if ( reportError( macroexpandedDrop,
                "Macroexpansion result drop" ) )
                break;
            
            var interpreted = penknife.conveniences_runSyncYoke(
                penknife.conveniences_interpretEssence(
                    macroexpanded.ind( 0 ) ) ).result;
            if ( reportError( interpreted, "Interpretation" ) ) {
                break;
            } else {
                if ( result.displayThisResult ) {
                    displays.push( "" + interpreted.ind( 0 ) );
//                    displays.push( "" );
                }
            }
            var interpretedDrop = penknife.conveniences_runSyncYoke(
                penknife.conveniences_pkDrop( interpreted ) ).result;
            if ( reportError( interpretedDrop,
                "Interpretation result drop" ) )
                break;
            
            var defined = penknife.conveniences_runSyncYoke(
                penknife.conveniences_runDefinitions() ).result;
            if ( reportError( defined, "Definition" ) )
                break;
            var definedDrop = penknife.conveniences_runSyncYoke(
                penknife.conveniences_pkDrop( defined ) ).result;
            if ( reportError( definedDrop,
                "Definition result drop" ) )
                break;
        }
        document.getElementById( "result" ).value =
            displays.join( "\n" );
        var runMillis = new Date().getTime() - startMillis;
        // TODO: Either remove this or display it more prominently.
        console.log( "Ran for " + runMillis / 1000 + " seconds." );
        
        } );
        } );
    }
    document.getElementById( "go" ).onclick = generateOutput;
    generateOutput();
};
</script>
</body>
</html>
