Cene (part of link:https://github.com/rocketnia/era[Era])
=========================================================

image::https://travis-ci.org/rocketnia/era-cene.svg?branch=master["Build Status", link="https://travis-ci.org/rocketnia/era-cene"]

_(In this repo, Cene is still largely going by the name Staccato. I named Staccato for a particular lambda-lifting desugaring phase that made all remaining functions take constant time. Programming in raw Staccato was tiresome enough that I developed a macro system for it, and then I implemented a much faster version of Staccato based on a few of those macros, actually skipping the desugaring phase altogether. Without that phase, the language can't really be called Staccato anymore. What Cene is instead... well...)_

Cene is instead is a minimalistic Lisp dialect that compiles to JavaScript, with a particularly comprehensive set of approaches to core issues that Lisp dialects that compile to JavaScript face:

* Nested quasiquotation, with labeled unquotes rather than de Bruijn unquote repetition.
* Nested quasiquotation *of interpolated string literals*, again with labeled interpolations.
* Whitespace normalization in string literals. That way, code formatting conventions don't influence the value of the string.
* A simple syntactic workaround that makes the nesting horrors of continuation-passing style easy to live with.
* Impurity enough for errors and general recursion, but otherwise a pure style that uses world-passing and commutative monads.
* Namespaces with assign-once definitions.
* Gensyms based on endless trees of gensyms, not based on impurity.
* Hygienic and unhygienic macros.
* Comparison results that are only usable by the metacircular interpreter that defines the comparison operator, rather than being observable by the caller. This allows name lookup data structures to be efficient without breaking alpha-renaming for the interpreted language.
* (TODO) Big numbers that can be fixnums for performance.
* (TODO) Big strings that can be fixnum-sized strings for performance.
* (TODO) Computations that run as synchronous JavaScript code for performance or as asynchronous JavaScript code for more responsive concurrency.
* (TODO) A standard way for pure code to invoke impure features offered by its metacircular interpreter.
* (TODO) Error handling based on seeking help from the metacircular interpreter.
* (TODO) Some basic CLI integration so that if you Greenspun your own toy language, it can be as easy to install and use as Cene itself.
* (TODO) JavaScript FFI.
* (TODO) A small enough language design that it should be rather simple to express in a standards document or implement metacircularly.

The Era project in general
--------------------------

Programming is an activity of last resort. Like a programming language, Era is a program that facilitates programming where it's necessary. Era tries to reduce the burden that comes with programming, including the burden of maintaining Era itself:

* It must be easy to reimplement Era from its documented semantics.
* If a useful goal can be accomplished by reimplementing Era in a way that breaks Era's documented semantics, there must be another way to achieve that goal that is consistent with Era's semantics.
* Era must facilitate programming. For Era's purposes, programming is when a person nurtures a serializable artifact in one time or place with the intention to make it applicable in another.

To put a limit on the scope of this project, although Era may make it easy to stay out of messes, Era will not necessarily make it difficult to get into them. After all, someone could easily get themselves into a mess just by choosing not to use Era.

Because of our broad view of programming, it even encompasses word processing, art asset production, playlist maintenance, and other creative tasks, so Era is eventually going to be an OS. However, the OS design is still far off.

Wherever it makes sense to do so, Era will help people share artifacts in the form of a monotonic knowledge representation. If any two people have collections of their favorite serializable artifacts, they can combine these collections without fear that some of the artifacts will conflict with each other. If this works, it should minimize the need to do extra programming just to negotiate conflicts. Conflict negotiation makes the maintenance cost grow superlinearly with the number of modules involved, and that kind of cost growth should be minimized so that it doesn't put unnecessary friction in the way of knowledge sharing.

To facilitate programming, Era should also facilitate the creation of additional tools to help with programming. With quasiquotation, Era's syntaxes will make it easy to maintain programs that generate Era's syntaxes.

The Era project contains a few sub-projects, and their implementations may blend in with each other a bit. The one under most active development recently is Staccato.

In this document, links like this one will take you to live demos:

link:http://rocketnia.github.io/era-cene/demos/unit-tests.html[Run some unit tests in your browser.]

Most of the demos aren't very interesting to view, but one is interactive.

The Staccato language
---------------------

link:http://rocketnia.github.io/era-cene/demos/staccato-runner-mini.html[Run some Staccato tests in your browser.]

The popular present-day programming languages have several superficial things in common: Most of them have interpreters, compilers, and/or servers you can run from the command line, which process a file tree full of plain text files. Most of them have some IDE support. Most of them have ways to install packages from the Web. Staccato is going to be a programming language in that sense.

### Staccato's run time semantics

The design of Staccato starts with a simple model for run time semantics: Semantically, every first-class value is a tagged record, and the stack is a simple list of values that will be called. Function definitions can be attached to tags, but the behavior of a single function must always take constant time. That way, a Staccato program can always be suspended in a well-defined state.

That well-defined state isn't always going to be useful, and it usually impedes optimizations and concurrency. Most of the time, the actual implementation details of a Staccato system will differ from this representation. However, it acts as a semantic structure against which Staccato step debuggers, profilers, JITs, reflective towers, etc. can be specified and understood.

Additionally, by considering every single first-class value to be a tagged record, Staccato is a good starting point for language features where selective encapsulation is needed: Function code is not encapsulated to everybody, but it is encapsulated to everybody who doesn't statically "know" the tag name, and this lack of knowledge can be enforced with sandbox abstractions, common Web service data security practices, or code signing.

### Staccato's textual syntax

link:http://rocketnia.github.io/era-cene/demos/reader.html[Run the reader in your browser. It's interactive!]

Staccato's syntax is designed to get out of the way when dirty programming tricks are needed. The textual syntax is based on Lisp, but the simple addition of +(a b /c d)+ syntax as an alternative to +(a b (c d))+ means it's easy to write code in a way that avoids avoids heavy nesting:

-----------------------------------------------
(defn bag-minus a b
  (cast a bag a-avl-tree
    err.\;qq[Expected an a value of type bag]
  /cast b bag b-avl-tree
    err.\;qq[Expected a b value of type bag]
  /bag/bag-fold-asc a-avl-tree b /fn state elem
    (avl-minus-entry state elem)))
-----------------------------------------------

This has the crucial benefit that code written in continuation-passing style or monadic style can be formatted in a flat way, very much like imperative code:

-----------------------------------------------------------------
(defn compile-def-type mode definition-ns name projection-list
  (bind-effects
    (procure-put-defined
      (ns-get-string str.projection-list
      /ns-get-name (constructor-name mode definition-ns name)
      /ns-get-name str.constructors definition-ns)
      projection-list)
  /fn -
  /bind-effects
    (procure-put-defined
      (ns-get-string str.function
      /ns-get-name (macro-name mode definition-ns name)
      /ns-get-name str.macros definition-ns)
      constructor-macro.projection-list)
  /fn -
  /no-effects/compile-ret-tuple mode definition-ns str.nil /nil))
-----------------------------------------------------------------

Staccato's string literals are written +\;qq[\...]+ or +\;qq(\...)+. Since this starts with a backslash and uses brackets, it's possible to write code that generates textual code that generates textual code, at any level of nesting, without needing to scatter escape sequences all over the code.

------------------------------------
(fn -
  str.\;qq[
    (fn -
      str.\;qq[
        (fn -
          str.\;qq[Hello, world!])])])
------------------------------------

The forward slash can even be used with string delimiters, facilitating a string-based continuation-passing style that would be nightmarish in other languages:

---------------
(fn - str.\;qq/
\/fn - str.\;qq/
\/fn - str.\;qq/
Hello, world!)
---------------

It's not recommended to write code in this style. However, this style is a natural consequence of using compilers that expect plain text as input. Since Staccato provides just such a compiler, it would be hypocritical not to support this kind of coding.

By default, the string syntax normalizes whitespace, so the above two examples are precisely equivalent. This is convenient for embedding natural language texts into the code, such as error messages. If necessary, individual whitespace characters can be specified explicitly using escape sequences, or whitespace normalization can be suppressed for a string altogether.

### Staccato's side effects

In usual practice, Staccato is a functional language with referential transparency. If an effect can be performed in a referentially transparent way--that is, if the only way to observe the effect is to observe the result value--and if it is semi-deterministic--that is, it has only one possible result value for a given input, but it may sometimes encounter an error and fail to produce it--then it can be performed in a direct way. All other effects are performed using a commutative monad.

If an effect is not naturally commutative with the other effects in the system, then it must be expressed as an effect that sets up a callback to be called to produce a future bundle of commutative effects. After all, "setting up a callback" is usually commutative. Unless they're used in a completely sequential way, these callbacks will tend to fan out and lose track of each other. When this happens, they can be synchronized again using promises.

This is a general approach to all kinds of side effects, and Staccato will have at least two disjoint effect systems designed this way: Services and macros. These are described below.

### Staccato's live services

Microservice architectures are becoming prominent for good reason: Humans and computer hardware happen to be interactive systems that maintain their identity over time. Software services can be peers in that respect, replacing and abstracting over hardware APIs.

For this reason, Staccato's error handling is based on the idea that there's a hardware service where the Staccato code is running, and this hardware service can be interacted with like any other service. In practice, instead of real hardware, this can be any kind of implementation of the Staccato language.

Live services live through continuous time; they don't inherently need a notion of discrete events. David Barbour's reactive demand programming (RDP) has explored a kind of stateless computation model with glitch tolerance. The idea of glitch tolerance is that if execution is somehow incorrect for a split second, it usually doesn't have large, lasting effects. To achieve this, at one point RDP had no notion of discrete events. All computation was in the form of continuous reactivity. Another feature that contributes to RDP's glitch tolerance is the use of static delays, which effectively means a program cannot live longer than a duration specified in its source code.

Staccato live services will be similar to RDP. They'll use continuous reactive semantics, and they'll pass around explicit licenses that authorize the use of persistent state for a limited time.

### Staccato's macros and namespaces

Because it must be easy to reimplement Era, it must be easy to reimplement Staccato. Staccato will support a macro system so people can easily bootstrap their slight extensions and modifications without reimplementing the whole language.

As far as modularity and encapsulation are concerned, Staccato macros are not a good alternative to writing functions; they are a good alternative to writing compilers. Nevertheless, if Staccato macros are written with a certain discipline, they can play well with other Staccato code; Common Lisp and Racket are examples of languages where this kind of discipline has paid off.

In particular, Staccato has a macro hygiene discipline. Macros pass around hierarchical namespaces, and the programmer should make sure to pass mutually exclusive namespaces to any two subcomputations that shouldn't be able to see each other's work. The global definition namespace is another parameter to the macro, and it's usually shared by all subcomputations, but it can be replaced with another namespace to achieve sandboxing.

Staccato's top-level declarations will act concurrently. A macro defined in any declaration in a codebase will be accessible anywhere else as long as there are no cyclic dependencies. Macro implementation code will see actually see this as an explicit form of concurrency. From the perspective of macro implementation code, installing a definition is a commutative side effect, and looking one up is a referentially transparent side effect.

To support incremental compilation, the macro system passes around a value representing the current "time," which in this case means the current compilation. That way, a definition lookup may have a result that varies over multiple source code edits, while still being a deterministic computation.

About this project
------------------

Era Cene is released under the MIT license. See LICENSE.txt.
