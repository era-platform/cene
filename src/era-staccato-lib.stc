\ era-staccato-lib.stc
\ Copyright 2015 Ross Angle. Released under the MIT License.
\
\ These are utilities written in a macro layer over Staccato. For now,
\ I'm porting the utilities from era-avl.js. (Many of the utilities
\ were actually ported from era-staccato-lib.js and
\ era-staccato-lib-gensym.js, which were ported from era-avl.js.)
\
\ See era-staccato.js for more information about what Staccato is.


\ NOTE: This file depends only on these macros, which are implemented
\ in era-staccato-lib-runner.js:
\
\ def-type defn case caselet cast c c-new err fn run-defs test let


\ ===== Lists and boolean tags =======================================

(def-type cons car cdr)
(def-type yep val)
(def-type nope val)
(def-type nil)

(defn foldl-short state list combiner
  (cast list cons first rest nope.state
  /caselet combiner-result (c combiner state first)
    yep result combiner-result
    nope result (c-new foldl-short result rest combiner)
    err.\-qq[Expected a combiner-result of type yep or nope]))

(defn foldl state list combiner
  (cast list cons first rest state
  /c-new foldl (c combiner state first) rest combiner))

(defn foldl-double-short state list-a list-b combiner
  (cast list-a cons first-a rest-a nope.state
  /cast list-b cons first-b rest-b nope.state
  /caselet combiner-result (c combiner state first-a first-b)
    
    yep result combiner-result
    
    nope result
    (c-new foldl-double-short result list-a list-b combiner)
    
    err.\-qq[Expected a combiner-result of type yep or nope]))

(defn foldl-double state list-a list-b combiner
  (case
    (foldl-double-short state list-a list-b /fn state elem-a elem-b
      (nope/c combiner state elem-a elem-b))
    nope result result
    err.\-qq[Internal error]))

(defn rev-onto target source
  (foldl target source /fn state elem /cons elem state))

(defn rev source
  (rev-onto (nil) source))

(defn append past rest
  (rev-onto rest rev.past))

(defn map list func
  (rev/foldl (nil) list /fn state elem /cons (c func elem) state))

(defn any list func
  (foldl-short (nil) list /fn state elem
    (caselet func-result (c func elem)
      yep result func-result
      nope result (nope/nil)
      err.\-qq[Expected a func-result of type yep or nope])))

(defn any-double list-a list-b func
  (foldl-double-short (nil) list-a list-b /fn state elem-a elem-b
    (caselet func-result (c func elem-a elem-b)
      yep result func-result
      nope result (nope/nil)
      err.\-qq[Expected a func-result of type yep or nope])))

(defn not-yep-nope yep-nope
  (case yep-nope
    yep val nope.val
    nope val yep.val
    err.\-qq[Expected a yep-nope of type yep or nope]))

(defn or-yep-nope a b
  (case a yep - a
  /case b yep - b
  /nope/nil))

(defn and-yep-nope a b
  (case a nope - a
  /case b nope - b
  /yep/nil))

(defn xor-yep-nope a b
  (case a yep -
    (case b yep - (nope/nil) a)
    (case b yep - b (nope/nil))))

(defn yep-nope-swap a b
  (case a yep - b not-yep-nope.b))

(defn all func list
  (not-yep-nope/any list /fn elem /not-yep-nope/c func elem))

\ TODO: Rename this to `rev-cut`.
(defn cut list-to-measure-by list-to-cut
  \ TODO: Stop using cons as a pair here.
  (foldl (cons (nil) list-to-cut) list-to-measure-by
  /fn state ignored-elem
    (cast state cons rev-before after
      err.\-qq[Internal error]
    /cast after cons first after
      err.\-qq[
        Expected a list-to-measure-by no longer than the list-to-cut]
    /cons (cons first rev-before) after)))

\ TODO: Stop using cons as a pair here.
(defn tails lists
  (cast lists cons list-a list-b
    err.\-qq[Expected a lists value of type cons]
  /cast list-a cons elem-a list-a lists
  /cast list-b cons elem-b list-b lists
  /c-new tails /cons list-a list-b))


\ ===== "Fixnum operations," a generic interface for bigint digits ===

\ NOTE: Although they're separated into different sections, fixops and
\ digpairs are actually interdependent.

(def-type
  fixops zero one complement compare plus minus times div dual-div)
(def-type carried main carry)

(defn fixops-zero fixops
  (cast fixops
    fixops zero one complement compare plus minus times div dual-div
    err.\-qq[Expected a fixops value of type fixops]
    zero))

(defn fixops-one fixops
  (cast fixops
    fixops zero one complement compare plus minus times div dual-div
    err.\-qq[Expected a fixops value of type fixops]
    one))

(defn fixops-complement fixops
  (cast fixops
    fixops zero one complement compare plus minus times div dual-div
    err.\-qq[Expected a fixops value of type fixops]
    complement))

(defn fixops-compare fixops
  (cast fixops
    fixops zero one complement compare plus minus times div dual-div
    err.\-qq[Expected a fixops value of type fixops]
    compare))

(defn fixops-plus fixops
  (cast fixops
    fixops zero one complement compare plus minus times div dual-div
    err.\-qq[Expected a fixops value of type fixops]
    plus))

(defn fixops-minus fixops
  (cast fixops
    fixops zero one complement compare plus minus times div dual-div
    err.\-qq[Expected a fixops value of type fixops]
    minus))

(defn fixops-times fixops
  (cast fixops
    fixops zero one complement compare plus minus times div dual-div
    err.\-qq[Expected a fixops value of type fixops]
    times))

(defn fixops-div fixops
  (cast fixops
    fixops zero one complement compare plus minus times div dual-div
    err.\-qq[Expected a fixops value of type fixops]
    div))

(defn fixops-dual-div fixops
  (cast fixops
    fixops zero one complement compare plus minus times div dual-div
    err.\-qq[Expected a fixops value of type fixops]
    dual-div))

(defn fixops-is-zero fixops n
  (case (fixops-compare fixops fixops-zero.fixops n) nil
    (yep/nil)
    (nope/nil)))


\ ===== "Digit pairs," fixnums built out of two smaller fixnums ======

(def-type digpair fixops is-zero bdig ldig)

(defn make-digpair fixops bdig ldig
  (let is-zero
    (and-yep-nope
      (fixops-is-zero fixops bdig)
      (fixops-is-zero fixops ldig))
  /digpair fixops is-zero bdig ldig))

(defn digpair-with-digits n bdig ldig
  (cast n digpair fixops is-zero orig-bdig orig-ldig
    err.\-qq[Expected an n value of type digpair]
  /make-digpair fixops bdig ldig))

(defn digpair-promote-sub n digit
  (cast n digpair fixops is-zero bdig ldig
    err.\-qq[Expected an n value of type digpair]
  /digpair-with-digits n fixops-zero.fixops digit))

(defn make-fixops-digpair digit-fixops
  (let zero fixops-zero.digit-fixops
  /fixops
    (make-digpair digit-fixops zero zero)
    (make-digpair digit-fixops zero fixops-one.digit-fixops)
    c-new.digpair-complement
    c-new.digpair-compare
    c-new.digpair-plus
    c-new.digpair-minus
    c-new.digpair-times
    fixops-dual-div.digit-fixops
    c-new.digpair-dual-div))

(defn digpair-carried-promote carried
  (cast carried carried n carry
    err.\-qq[Expected a carried value of type carried]
  /cast n digpair fixops is-zero bdig ldig
    err.\-qq[Expected an n value of type digpair]
  /make-digpair make-fixops-digpair.fixops carry n))

(defn digpair-is-zero n
  (cast n digpair fixops is-zero bdig ldig
    err.\-qq[Expected an n value of type digpair]
    is-zero))

(defn digpair-as-zero n
  (cast n digpair fixops is-zero bdig ldig
    err.\-qq[Expected an n value of type digpair]
  /case is-zero yep - n
  /let zero-digit fixops-zero.fixops
  /digpair-with-digits n zero-digit zero-digit))

(defn digpair-complement n
  (cast n digpair fixops is-zero bdig ldig
    err.\-qq[Expected an n value of type digpair]
  /digpair-with-digits n
    (fixops-complement fixops bdig)
    (fixops-complement fixops ldig)))

(defn digpair-compare n m
  (cast n digpair fixops n-is-zero n-bdig n-ldig
    err.\-qq[Expected an n value of type digpair]
  /cast m digpair - m-is-zero m-bdig m-ldig
    err.\-qq[Expected an m value of type digpair]
  \ Optimization: If either thing to compare is zero, we can avoid
  \ iterating over the digits.
  /case n-is-zero yep -
    (case m-is-zero yep -
      (nil)
      (yep/nil))
  /case m-is-zero yep -
    (nope/nil)
  /caselet bcompare (fixops-compare fixops n-bdig m-bdig) nil
    (fixops-compare n-ldig n-bdig)
    bcompare))

(defn digpair-plus n m-carried
  (cast n digpair fixops n-is-zero n-bdig n-ldig
    err.\-qq[Expected an n value of type digpair]
  /cast m-carried carried m carry
    err.\-qq[Expected an m-carried value of type carried]
  /cast m digpair - m-is-zero m-bdig m-ldig
    err.\-qq[Expected an m value of type digpair]
  /cast carry digpair - carry-is-zero -b cdig
    err.\-qq[Expected a carry value of type digpair]
  
  \ Optimization: If either summand is zero and the carry is also
  \ zero, we can just use the other as the result.
  /case (and-yep-nope n-is-zero carry-is-zero) yep - (carried m carry)
  /case (and-yep-nope m-is-zero carry-is-zero) yep - (carried n carry)
  
  /cast (fixops-plus fixops n-ldig /carried m-ldig cdig)
    carried r-ldig cdig
    err.\-qq[Internal error]
  /cast (fixops-plus fixops n-bdig /carried m-bdig cdig)
    carried r-bdig cdig
    err.\-qq[Internal error]
  /carried (digpair-with-digits n r-bdig r-ldig)
  /digpair-promote-sub n cdig))

(defn digpair-minus n m-carried
  (cast n digpair fixops n-is-zero n-bdig n-ldig
    err.\-qq[Expected an n value of type digpair]
  /cast m-carried carried m carry
    err.\-qq[Expected an m-carried value of type carried]
  /cast m digpair - m-is-zero m-bdig m-ldig
    err.\-qq[Expected an m value of type digpair]
  /cast carry digpair - carry-is-zero -b cdig
    err.\-qq[Expected a carry value of type digpair]
  
  \ Optimization: If both things to subtract from this are zero, we
  \ can just skip the subtraction.
  /case (and-yep-nope m-is-zero carry-is-zero) yep - (carried n carry)
  
  /cast (fixops-minus fixops n-ldig /carried m-ldig cdig)
    carried r-ldig cdig
    err.\-qq[Internal error]
  /cast (fixops-minus fixops n-bdig /carried m-bdig cdig)
    carried r-bdig cdig
    err.\-qq[Internal error]
  /carried (digpair-with-digits n r-bdig r-ldig)
  /digpair-promote-sub n cdig))

(defn digpair-times-small n m-carried
  (cast n digpair fixops n-is-zero n-bdig n-ldig
    err.\-qq[Expected an n value of type digpair]
  /cast m-carried carried m carry
    err.\-qq[Expected an m-carried value of type carried]
  /let carry-is-zero (fixops-is-zero fixops carry)
  
  \ Optimization: If either factor is zero and the carry is also zero,
  \ we can just use a result of zero.
  /case (and-yep-nope n-is-zero carry-is-zero) yep - (carried n carry)
  
  /case (and-yep-nope (fixops-is-zero fixops m) carry-is-zero) yep -
    (carried digpair-as-zero.n carry)
  /cast (fixops-times fixops n-ldig /carried m carry)
    carried r-ldig carry
    err.\-qq[Internal error]
  /cast (fixops-times fixops n-bdig /carried m carry)
    carried r-bdig carry
    err.\-qq[Internal error]
  /carried (digpair-with-digits n r-bdig r-ldig) carry))

(defn digpair-times n m-carried
  (cast n digpair fixops n-is-zero n-bdig n-ldig
    err.\-qq[Expected an n value of type digpair]
  \ TODO: See if this can be more efficient.
  /cast m-carried carried m carry
    err.\-qq[Expected an m-carried value of type carried]
  /cast m digpair - m-is-zero m-bdig m-ldig
    err.\-qq[Expected an m value of type digpair]
  
  \ Optimization: If either factor is zero, we can just use the
  \ carry as the result value.
  /case n-is-zero yep - (carried carry n)
  /case m-is-zero yep - (carried carry m)
  
  /let zero digpair-as-zero.carry
  /let zero-digit fixops-zero.fixops
  /let big-carry (make-digpair zero zero carry)
  /let digit-times
    (fn a b /fixops-times fixops a /carried b zero-digit)
  /let plus-no-carry
    (fn a b
      (case (fixops-plus fixops a /carried b zero-digit)
        carried sum carry sum
        err.\-qq[Internal error]))
  /let four-digit
    (fn a b c d
      (make-digpair zero
        (make-digpair zero-digit a b)
        (make-digpair zero-digit c d)))
  /let r-ll
    (cast (c digit-times n-ldig m-ldig) carried dig carry
      err.\-qq[Internal error]
    /c four-digit zero-digit zero-digit carry dig)
  /let r-lb
    (cast (c digit-times n-ldig m-bdig) carried dig carry
      err.\-qq[Internal error]
    /c four-digit zero-digit carry dig zero-digit)
  /let r-bl
    (cast (c digit-times n-bdig m-ldig) carried dig carry
      err.\-qq[Internal error]
    /c four-digit zero-digit carry dig zero-digit)
  /let r-bb
    (cast (c digit-times n-bdig m-bdig) carried dig carry
      err.\-qq[Internal error]
    /c four-digit carry dig zero-digit zero-digit)
  
  \ NOTE: When the digits are 16-bit, the maximum value of `carry` is
  \ 0xFFFFFFFF, and the maximum value of `n` times `m` plus the carry
  \ is 0xFFFFFFFF00000000, so there's no excess.
  /cast
    (c plus-no-carry r-ll
    /c plus-no-carry r-lb
    /c plus-no-carry r-bl
    /c plus-no-carry r-bb
    /make-digpair zero zero carry)
    
    digpair fixops is-zero bdig ldig
    err.\-qq[Internal error]
  /carried ldig bdig))

(defn digpair-div-small n m-carried
  (cast n digpair fixops n-is-zero n-bdig n-ldig
    err.\-qq[Expected an n value of type digpair]
  /cast m-carried carried m carry
    err.\-qq[Expected an m-carried value of type carried]
  /cast (fixops-is-zero fixops m) yep -
    err.\-qq[Called digpair-div-small with a zero divisor]
  /let carry-is-zero (fixops-is-zero fixops carry)
  
  \ Optimization: If the dividend is zero and the carry is also zero,
  \ we can just use a result of zero.
  /case (and-yep-nope n-is-zero carry-is-zero) yep - (carried n carry)
  
  /cast (fixops-div fixops n-bdig /carried m carry)
    carried r-bdig carry
    err.\-qq[Internal error]
  /cast (fixops-div fixops n-ldig /carried m carry)
    carried r-ldig carry
    err.\-qq[Internal error]
  /carried (digpair-with-digits n r-bdig r-ldig) carry))

(defn digpair-dual-div-no-carry n3210 m3210
  (let long-zero digpair-as-zero.n3210
  /cast long-zero digpair long-fixops - -b short-zero
    err.\-qq[Internal error]
  /let make-short (fn a b /digpair-with-digits short-zero a b)
  /let long-one
    (digpair-with-digits long-zero short-zero fixops-one.long-fixops)
  /let four-digits
    (fn a b c d
      (digpair-with-digits long-zero
        (c make-short a b)
        (c make-short c d)))
  /case (digpair-compare n3210 m3210) yep -
    err.\-qq[
      Called digpair-dual-div-no-carry with a smaller dividend than
      divisor]
  /cast n3210 digpair - -b n32 n10
    err.\-qq[Expected an n3210 value of type digpair]
  /cast m3210 digpair - -b m32 m10
    err.\-qq[Expected an m3210 value of type digpair]
  /case digpair-is-zero.m32 yep -
    err.\-qq[Called digpair-dual-div-no-carry with a zero m32]
  /cast n32 digpair digit-fixops - n3 n2
    err.\-qq[Expected an n32 value of type digpair]
  /cast n10 digpair - -b n1 n0
    err.\-qq[Expected an n10 value of type digpair]
  /cast m32 digpair - -b m3 m2
    err.\-qq[Expected an m32 value of type digpair]
  /cast m10 digpair - -b m1 m0
    err.\-qq[Expected an m10 value of type digpair]
  /let zdig fixops-zero.digit-fixops
  /let ignore-carry
    (fn carried
      (case carried carried result carry
        result
        err.\-qq[Internal error]))
  /let mid1-result
    \ We ignore the remainder because we're just going to calculate a
    \ more accurate remainder by multiplying the full-precision
    \ divisor.
    (c ignore-carry /c-new digpair-dual-div
      (c four-digits zdig n3 n2 n1)
    /carried
      \ We ignore the carry because it must be zero.
      (c ignore-carry /digpair-plus long-one
      /c four-digits zdig m3 m2 m1)
      long-zero)
  /let mid1-remainder
    \ We ignore the subtraction carry because it must be zero.
    (c ignore-carry /digpair-minus n3210
    /carried
      \ We ignore the multiplication carry because it must be zero.
      (c ignore-carry /digpair-times m3210
      /carried mid1-result long-zero)
      long-zero)
  
  \ At this point, we might be *one* subtraction away from a fully
  \ accurate result. (We can't be two or more subtractions away, since
  \ the approximate divisor would have been small enough to fit in the
  \ space of twice the accurate divisor. After all, the approximate
  \ divisor is only too large by (1 + maxDigitValue) or less, and we
  \ already know the divisor is at least (1 + maxDigitValue)^2.) So,
  \ we do that subtraction if possible.
  \
  /case (digpair-compare mid1-remainder m3210) yep -
    (carried mid1-result mid1-remainder)
    (carried
      
      \ We ignore the carry because it must be zero.
      (c ignore-carry /digpair-plus mid1-result
      /carried long-one long-zero)
      
      \ We ignore the carry because it must be zero.
      (c ignore-carry /digpair-minus mid1-remainder
      /carried m3210 long-zero))))

(defn digpair-dual-div n m-carried
  \ TODO: See if this can be more efficient.
  (cast n digpair fixops n-is-zero n-bdig n-ldig
    err.\-qq[Expected an n value of type digpair]
  /cast m-carried carried m carry
    err.\-qq[Expected an m-carried value of type carried]
  /cast m digpair - m-is-zero m-bdig m-ldig
    err.\-qq[Expected an m value of type digpair]
  /case m-is-zero yep -
    err.\-qq[Called digpair-dual-div with a zero divisor]
  /cast carry digpair - carry-is-zero c-bdig c-ldig
    err.\-qq[Expected a carry value of type digpair]
  /let zdig fixops-zero.fixops
  /case carry-is-zero yep -
    
    \ If the carry is zero and the dividend is less than the divisor,
    \ we return zero and a remainder equal to the dividend.
    (case (fixops-compare fixops n m) yep -
      (carried digpair-as-zero.n n)
    
    \ If the carry is zero and the first digit of the divisor is zero,
    \ we can reduce this division to a division of the digits.
    /case (fixops-is-zero fixops m-bdig) yep -
      (cast (fixops-dual-div fixops n-bdig /carried m-ldig zdig)
        carried r-bdig intermediate1-carry
        err.\-qq[Internal error]
      /cast
        (fixops-dual-div fixops n-ldig
        /carried m-ldig intermediate1-carry)
        carried r-ldig carry
        err.\-qq[Internal error]
      /carried (digpair-with-digits n r-bdig r-ldig)
      /digpair-with-digits zdig carry)
    
    \ If the carry is zero, if the divisor is less than or equal to
    \ the dividend, and if the first digit of the divisor isn't zero,
    \ then we split the digits into sub-digits and divide by an
    \ approximation where we drop the least significant sub-digits.
    \ The approximation may be off by one, so we check for this and
    \ subtract one more time if necessary. We handle this in a
    \ separate function.
    /digpair-dual-div-no-carry fixops n m)
  
  \ If the carry isn't zero, we shift the carry-and-divisor
  \ combination down by one digit, do a division from there, and then
  \ do another division to account for the digit that was dropped.
  \ This means the carry-and-divisor combination will have one fewer
  \ nonzero digit, and it will take no more than two of these
  \ reductions to wind up at the carry-is-zero case.
  /cast
    (c-new digpair-dual-div (digpair-with-digits n c-ldig n-bdig)
    /carried m (digpair-with-digits n zdig c-bdig))
    carried intermediate1-result intermediate1-carry
    err.\-qq[Internal error]
  /cast intermediate1-result digpair - -b -c ir-ldig
    err.\-qq[Internal error]
  /cast intermediate1-carry digpair - -b ic-bdig ic-ldig
    err.\-qq[Internal error]
  /cast
    (c-new digpair-dual-div (digpair-with-digits n ic-ldig n-ldig)
    /carried m (digpair-with-digits n zdig ic-bdig))
    carried intermediate2-result carry
    err.\-qq[Internal error]
  /cast
    (digpair-plus (digpair-with-digits ir-ldig zdig)
    /carried intermediate2-result digpair-as-zero.n)
    carried result -
    err.\-qq[Internal error]
  /carried result carry))


\ ===== One-bit fixnums in terms of (yep/nil) and (nope/nil) =========

(defn make-fixops-yep-nope -
  (fixops
    (nope/nil)
    (yep/nil)
    (not-yep-nope)
    
    (fn n m
      \ Compare
      (case n yep -
        (case m yep - (nil) (nope/nil))
        (case m yep - (yep/nil) (nil))))
    
    (fn n m-carried
      \ Plus
      (cast m-carried carried m carry
        err.\-qq[Expected an m-carried value of type carried]
      /case (xor-yep-nope n m) yep -
        (carried not-yep-nope.carry carry)
        (carried carry n)))
    
    (fn n m-carried
      \ Minus
      (cast m-carried carried m carry
        err.\-qq[Expected an m-carried value of type carried]
      /case (xor-yep-nope n m) yep -
        (carried not-yep-nope.carry m)
        (carried carry carry)))
    
    (fn n m-carried
      \ Times
      (cast m-carried carried m carry
        err.\-qq[Expected an m-carried value of type carried]
      /case (and-yep-nope n m) yep -
        (carried not-yep-nope.carry carry)
        (carried carry /nope/nil)))
    
    (fn n m-carried
      \ Div
      (cast m-carried carried m carry
        err.\-qq[Expected an m-carried value of type carried]
      /case m nope -
        \ Divide by zero.
        err.\-qq[
          Called make-fixops-yep-nope's div operation with a zero
          divisor]
      \ Divide by one.
      /carried n carry))
    
    (fn n m-carried
      \ Dual-div
      (cast n digpair - n-is-zero n1 n0
        err.\-qq[Expected an n value of type digpair]
      /cast m-carried carried m carry
        err.\-qq[Expected an m-carried value of type carried]
      /cast m digpair - m-is-zero m1 m0
        err.\-qq[Expected an m value of type digpair]
      /cast carry digpair - carry-is-zero n3 n2
        err.\-qq[Expected a carry value of type digpair]
      /case m-is-zero yep -
        \ Divide by zero.
        err.\-qq[
          Called make-fixops-yep-nope's dual-div operation with a zero
          divisor]
      /case (and-yep-nope not-yep-nope.m1 m0) yep -
        \ Divide by one.
        (carried n carry)
      /case not-yep-nope.m0 yep -
        \ Divide by two.
        (carried (digpair-with-digits n n2 n1)
        /digpair-with-digits n (nope/nil) n0)
      
      \ Divide by three.
      /let r1 (or-yep-nope n3 /and-yep-nope n2 n1)
      /let n2b (case r1 nope - n2 /and-yep-nope n3 n1)
      /let n1b (case r1 nope - n1 not-yep-nope.n1)
      /let n0b n0
      /let r0 (or-yep-nope n2b /and-yep-nope n1b n0b)
      /carried (digpair-with-digits n r1 r0)
      /digpair-with-digits n
        (case r0 nope - n1b /and-yep-nope n2b n0b)
        (case r0 nope - n0b not-yep-nope.n0b)))))


\ ===== Big, zero-based natural numbers ==============================

(def-type binat-internals depth fixnum)
(def-type binat fixops maybe-internals)

(defn binat-zero-for-fixops fixops
  (binat fixops /nil))

(defn binat-yep-nope-zero -
  (binat-zero-for-fixops/make-fixops-yep-nope/nil))

(defn binat-as-zero n
  (cast n binat fixops n-internals
    err.\-qq[Expected an n value of type binat]
    binat-zero-for-fixops.fixops))

(defn binat-as-one n
  (cast n binat fixops n-internals
    err.\-qq[Expected an n value of type binat]
  /binat fixops
  /binat-internals (binat fixops /nil) fixops-one.fixops))

(defn binat-is-zero n
  (cast n binat fixops n-internals
    err.\-qq[Expected an n value of type binat]
  /case n-internals binat-internals depth fixnum
    (nope/nil)
    (yep/nil)))

(defn improper-binat-is-zero n
  (cast n binat fixops n-internals
    err.\-qq[Expected an n value of type binat]
  /case n-internals binat-internals depth fixnum
    (case binat-is-zero.depth yep -
      (fixops-is-zero fixops fixnum)
      digpair-is-zero.fixnum)
    (yep/nil)))

(defn binat-compare n m
  (cast n binat fixops n-internals
    err.\-qq[Expected an n value of type binat]
  /cast m binat - m-internals
    err.\-qq[Expected an m value of type binat]
  /case n-internals binat-internals n-depth nfix
    (case m-internals binat-internals m-depth mfix
      (caselet depth-comparison (c-new binat-compare n-depth m-depth)
        nil
        (case binat-is-zero.n-depth yep -
          (fixops-compare fixops nfix mfix)
          (digpair-compare nfix mfix))
        depth-comparison)
      (nope/nil))
    (case m-internals binat-internals - -b
      (yep/nil)
      (nil))))

(defn improper-binat-reduce n
  (cast n binat fixops n-internals
    err.\-qq[Expected an n value of type binat]
  /cast n-internals binat-internals depth fixnum
    n
  /case binat-is-zero.depth yep -
    (case (fixops-is-zero fixops fixnum) yep -
      binat-as-zero.n
      n)
  /cast fixnum digpair digit-fixops is-zero bdig ldig
    err.\-qq[Expected a fixnum value of type digpair]
  /case is-zero yep -
    binat-as-zero.n
  /case (fixops-is-zero digit-fixops bdig) nope -
    n
  /c-new improper-binat-reduce
  /binat fixops
  /binat-internals
    (case (c-new binat-subtracted-from binat-as-one.depth depth)
      yep depth-minus-one depth-minus-one
      nil binat-as-zero.depth
      err.\-qq[Internal error])
    ldig))

(defn improper-binat-promote-carried fixops depth carried
  (cast carried carried result carry
    err.\-qq[Expected a carried value of type carried]
  /case
    (case binat-is-zero.depth yep -
      (fixops-is-zero fixops carry)
      digpair-is-zero.carry)
    
    yep - (binat fixops /binat-internals depth result)
    
    (binat fixops
    /binat-internals (c-new binat-plus depth binat-as-one.depth)
      digpair-carried-promote.carried)))

(defn improper-binat-promote n
  (cast n binat fixops n-internals
    err.\-qq[Expected an n value of type binat]
  /cast n-internals binat-internals depth fixnum
    err.\-qq[Expected an n value that wasn't zero]
  /binat fixops
  /binat-internals (c-new binat-plus depth binat-as-one.depth)
  /case binat-is-zero.depth yep -
    (make-digpair
      make-fixops-digpair.fixops fixops-zero.fixops fixnum)
    (digpair-carried-promote/carried fixnum digpair-as-zero.fixnum)))

(defn improper-binat-plus n m
  (cast n binat fixops n-internals
    err.\-qq[Expected an n value of type binat]
  /cast m binat - m-internals
    err.\-qq[Expected an m value of type binat]
  /cast n-internals binat-internals n-depth nfix
    m
  /cast m-internals binat-internals m-depth mfix
    n
  /case (binat-compare n-depth m-depth)
    yep - (c-new improper-binat-plus improper-binat-promote.n m)
    nope - (c-new improper-binat-plus n improper-binat-promote.m)
  /improper-binat-promote-carried fixops n-depth
  /case binat-is-zero.n-depth yep -
    (fixops-plus fixops nfix /carried mfix fixops-zero.fixops)
    (digpair-plus nfix /carried mfix digpair-as-zero.nfix)))

(defn binat-plus m n
  (improper-binat-plus m n))

(defn improper-binat-subtracted-from n m
  (case (binat-compare n m)
    nil (nil)
    nope - (not-yep-nope/c-new improper-binat-subtracted-from m n)
  /cast n binat fixops n-internals
    err.\-qq[Expected an n value of type binat]
  /cast m binat - m-internals
    err.\-qq[Expected an m value of type binat]
  /cast n-internals binat-internals n-depth nfix
    yep.m
  /cast m-internals binat-internals m-depth mfix
    err.\-qq[Internal error]
  /case (binat-compare n-depth m-depth) yep -
    (c-new improper-binat-subtracted-from improper-binat-promote.n m)
  /cast
    (case binat-is-zero.n-depth yep -
      (fixops-minus fixops mfix /carried nfix fixops-zero.fixops)
      (digpair-minus mfix /carried nfix digpair-as-zero.nfix))
    carried result carry
    err.\-qq[Internal error]
  /nope/binat fixops /binat-internals n-depth result))

(defn binat-subtracted-from m n
  (case (improper-binat-subtracted-from m n)
    yep result (yep improper-binat-reduce.result)
    nope result (nope improper-binat-reduce.result)
  /nil))

(defn improper-binat-times n m
  (cast n binat fixops n-internals
    err.\-qq[Expected an n value of type binat]
  /cast m binat - m-internals
    err.\-qq[Expected an m value of type binat]
  /cast n-internals binat-internals n-depth nfix
    n
  /cast m-internals binat-internals m-depth mfix
    m
  /case (binat-compare n-depth m-depth)
    yep - (c-new improper-binat-times improper-binat-promote.n m)
    nope - (c-new improper-binat-times n improper-binat-promote.m)
  /improper-binat-promote-carried fixops n-depth
  /case binat-is-zero.n-depth yep -
    (fixops-times fixops nfix /carried mfix fixops-zero.fixops)
    (digpair-times nfix /carried mfix digpair-as-zero.nfix)))

(defn binat-times m n
  (improper-binat-reduce/improper-binat-times m n))

(defn improper-binat-div n m
  (case (binat-compare n m)
    nil (carried binat-as-one.n binat-as-zero.n)
    yep - (carried binat-as-zero.n n)
  /case improper-binat-is-zero.m yep -
    err.\-qq[Called improper-binat-div with a zero divisor]
  /cast n binat fixops n-internals
    err.\-qq[Expected an n value of type binat]
  /cast m binat - m-internals
    err.\-qq[Expected an m value of type binat]
  /cast n-internals binat-internals n-depth nfix
    err.\-qq[Internal error]
  /cast m-internals binat-internals m-depth mfix
    err.\-qq[Internal error]
  /case (binat-compare n-depth m-depth) nope -
    (c-new improper-binat-div n improper-binat-promote.m)
  /cast
    (case binat-is-zero.n-depth yep -
      (fixops-div fixops nfix /carried mfix fixops-zero.fixops)
    /case (binat-compare n-depth binat-as-one.n-depth) nil
      (fixops-dual-div fixops nfix /carried mfix digpair-as-zero.nfix)
      (digpair-dual-div nfix /carried mfix digpair-as-zero.nfix))
    carried result carry
    err.\-qq[Internal error]
  /carried (binat fixops /binat-internals n-depth result)
  /binat fixops /binat-internals n-depth carry))

(defn binat-div m n
  (cast (improper-binat-div m n) carried result carry
    err.\-qq[Internal error]
  /carried improper-binat-reduce.result improper-binat-reduce.carry))


\ ===== Big signed integers ==========================================
\
\ These might even be integers that carry a big sign. You can't say
\ they aren't.

(def-type bigint fixops nat)

(defn bigint-zero-for-fixops fixops
  (bigint fixops /nil))

(defn bigint-yep-nope-zero -
  (bigint-zero-for-fixops/make-fixops-yep-nope/nil))

(defn bigint-as-zero n
  (cast n bigint fixops n-nat
    err.\-qq[Expected an n value of type bigint]
    bigint-zero-for-fixops.fixops))

(defn bigint-as-one n
  (cast n bigint fixops n-nat
    err.\-qq[Expected an n value of type bigint]
  /bigint fixops /yep/binat-as-one binat-zero-for-fixops.fixops))

(defn bigint-neg n
  (cast n bigint fixops n-nat
    err.\-qq[Expected an n value of type bigint]
  /case n-nat nil
    n
  /bigint fixops not-yep-nope.n))

(defn bigint-abs n
  (cast n bigint fixops n-nat
    err.\-qq[Expected an n value of type bigint]
  /case n-nat nope -
    bigint-neg.n
    n))

(defn bigint-compare n m
  (cast n bigint - n
    err.\-qq[Expected an n value of type bigint]
  /cast m bigint - m
    err.\-qq[Expected an m value of type bigint]
  /case n
    
    yep n
    (case m yep m
      (binat-compare n m)
      (nope/nil))
    
    nope n
    (case m nope m
      (binat-compare m n)
      (yep/nil))
    
  /case m
    yep - (yep/nil)
    nope - (nope/nil)
    (nil)))

(defn bigint-plus n m
  (cast n bigint fixops n
    err.\-qq[Expected an n value of type bigint]
  /cast m bigint - m
    err.\-qq[Expected an m value of type bigint]
  /case n
    
    yep n
    (case m
      yep m (bigint fixops /yep/binat-plus n m)
      nope m (bigint fixops /binat-subtracted-from m n)
    /bigint fixops n)
    
    nope n
    (case m
      yep m (bigint fixops /binat-subtracted-from n m)
      nope m (bigint fixops /nope/binat-plus n m)
    /bigint fixops n)
    
  /bigint fixops m))

(defn bigint-minus n m
  (bigint-plus n bigint-neg.m))

(defn bigint-times n m
  (cast n bigint fixops n
    err.\-qq[Expected an n value of type bigint]
  /cast m bigint - m
    err.\-qq[Expected an m value of type bigint]
  /case n
    
    yep n
    (case m
      yep m (bigint fixops /yep/binat-times n m)
      nope m (bigint fixops /nope/binat-times m n)
    /bigint fixops /nil)
    
    nope n
    (case m
      yep m (bigint fixops /nope/binat-times n m)
      nope m (bigint fixops /yep/binat-times n m)
    /bigint fixops /nil)
    
  /bigint fixops /nil))

(defn bigint-div-toward-zero n m
  (let pos (fn n yep.n)
  /let neg (fn n nope.n)
  /cast n bigint fixops n
    err.\-qq[Expected an n value of type bigint]
  /cast m bigint - m
    err.\-qq[Expected an m value of type bigint]
  /let div
    (fn n m result-sign carry-sign
      (cast (binat-div n m) carried result carry
        err.\-qq[Internal error]
      /bigint fixops
      /carried (bigint fixops /c result-sign result)
      /bigint fixops /c carry-sign carry))
  
  \ NOTE: These examples may clarify the following signs.
  \
  \   9  /   2  =   4  R   1  because   9  =   2  *   4  +   1
  \   9  /  -2  =  -4  R   1  because   9  =  -2  *  -4  +   1
  \  -9  /   2  =  -4  R  -1  because  -9  =   2  *  -4  +  -1
  \  -9  /  -2  =   4  R  -1  because  -9  =  -2  *   4  +  -1
  
  /case n
    
    yep n
    (case m
      yep m (c div n m pos pos)
      nope m (c div n m neg pos)
      err.\-qq[Called bigint-div-toward-zero with a zero divisor])
    
    nope n
    (case m
      yep m (c div n m neg neg)
      nope m (c div n m pos neg)
      err.\-qq[Called bigint-div-toward-zero with a zero divisor])
  
  /bigint fixops /nil))

\ TODO: Port toStringInRadix and bigIntFromStringInRadix. We don't
\ have string manipulation yet, though.


\ ===== AVL trees ====================================================

\ TODO: See if our use of binary bigints is less efficient than
\ era-avl.js's use of unary bigints.

(def-type avl-leaf fixops compare)
(def-type
  avl-branches nope-unbalance nope-branch yep-unbalance yep-branch)
(def-type avl-branch fixops compare key val branches)
(def-type depth-modified depth-was-modified result)

\ TODO: Find a better name for this.
(def-type map-fold-state state val)

(defn avl-branches-swap polarity branches
  (case polarity yep - branches
  /cast branches avl-branches nub nbranch yub ybranch
    err.\-qq[Expected a branches value of type avl-branches]
  /avl-branches yub ybranch nub nbranch))

(defn avl-get-maybe tree k
  (case tree avl-leaf fixops compare
    (nil)
  /case tree avl-branch fixops compare key val branches
    (cast branches avl-branches nub nbranch yub ybranch
      err.\-qq[Expected a branches value of type avl-branches]
    /case (c compare key k)
      nope - (c-new avl-get-maybe nbranch k)
      yep - (c-new avl-get-maybe ybranch k)
      yep.tree)
    err.\-qq[Expected a tree value of type avl-leaf or avl-branch]))

(def-type
  depth-changed nope-depth-change yep-depth-change balanced-tree)

(defn depth-changed-swap polarity balance-result
  (case polarity yep - balance-result
  /cast balance-result
    depth-changed nope-depth-change yep-depth-change balanced-tree
    err.\-qq[Expected a balance-result value of type depth-changed]
  /depth-changed yep-depth-change nope-depth-change balanced-tree))

(defn improper-avl-branch-balance tree
  (cast tree avl-branch fixops compare key val branches
    err.\-qq[Expected a tree value of type avl-branch]
  /cast branches avl-branches nub nbranch yub ybranch
    err.\-qq[Expected a branches value of type avl-branches]
  /let bigint-minus-one (fn n /bigint-minus n bigint-as-one.n)
  /let bigint-plus-one (fn n /bigint-plus n bigint-as-one.n)
  /let bigint-lteq-one
    (fn n
      (case (bigint-compare n bigint-as-one.n) nope -
        (nope/nil)
        (yep/nil)))
  /let n-is-zero bigint-is-zero.nub
  /let y-is-zero bigint-is-zero.yub
  /case (or-yep-nope n-is-zero y-is-zero) nope -
    (c-new improper-avl-branch-balance
    /avl-branch fixops compare key val
    /avl-branches
      bigint-minus-one.nub nbranch
      bigint-minus-one.yub ybranch)
  /case (and-yep-nope bigint-lteq-one.nub bigint-lteq-one.yub) yep -
    (let zero bigint-zero-for-fixops.fixops
    /depth-changed zero zero tree)
  /let polarity y-is-zero
  /cast (avl-branches-swap polarity branches)
    avl-branches wub wbranch tub tbranch
    err.\-qq[Internal error]
  /cast (c-new avl-minus-extreme-entry wbranch polarity)
    avl-minus-extreme-entry-succeeded
    max-depth-decreased k v wbranch
    err.\-qq[Internal error]
  /cast
    \ TODO: Stop using cons as a pair here.
    (case (c-new avl-plus-entry tbranch key val)
      nope result (cons (nope/nil) result)
      yep result (cons (yep/nil) result)
      err.\-qq[Internal error])
    cons max-depth-increased tbranch
    err.\-qq[Internal error]
  /let wub (case max-depth-decreased yep - bigint-minus-one.wub wub)
  /let wub (case max-depth-increased yep - bigint-minus-one.wub wub)
  /cast
    (depth-changed-swap polarity
    /c-new improper-avl-branch-balance /avl-branch fixops compare k v
    /avl-branches-swap polarity
    /avl-branches wub wbranch tub tbranch)
    depth-changed w-depth-change t-depth-change tree
    err.\-qq[Internal error]
  /let w-depth-change
    (case max-depth-decreased yep -
      bigint-minus-one.w-depth-change
      w-depth-change)
  /let t-depth-change
    (case max-depth-decreased yep -
      bigint-plus-one.t-depth-change
      t-depth-change)
  /depth-changed-swap polarity
  /depth-changed w-depth-change t-depth-change tree))

(def-type avl-minus-extreme-entry-succeeded
  max-depth-decreased k v tree-remaining)

(defn avl-branch-finish-minus fixops compare branches
  \ NOTE: This effectively concatenates the branches. Like
  \ `improper-avl-branch-balance`, this assumes all the elements are
  \ already in the proper order, just not necessarily balanced between
  \ the two branches. It's not a merge of arbitrary trees. For that,
  \ see `avl-merge`. Furthermore, this can even rely on the fact that
  \ the branches were initially balanced before the root key/value
  \ entry was subtracted from the tree.
  (cast branches avl-branches nub nbranch yub ybranch
    err.\-qq[Expected a branches value of type avl-branches]
  /let attempt-shift
    (fn polarity on-fail
      (cast branches (avl-branches-swap polarity branches)
        avl-branches wub wbranch tub tbranch
        err.\-qq[Internal error]
      /case (c-new avl-minus-extreme-entry wbranch polarity)
        
        nope - (c on-fail /nil)
        
        avl-minus-extreme-entry-succeeded
        max-depth-decreased k v tree-remaining
        (let inc (fn n /bigint-plus n bigint-as-one.n)
        /let new-tub
          (case max-depth-decreased yep -
            inc.tub
            tub)
        /cast
          (depth-changed-swap polarity
          /improper-avl-branch-balance/avl-branch fixops compare k v
          /avl-branches-swap polarity
          /avl-branches wub wbranch new-tub tbranch)
          depth-changed w-depth-change t-depth-change tree
        /yep-nope-swap
          (and-yep-nope max-depth-decreased
          /and-yep-nope (not-yep-nope bigint-is-zero.tub)
            (case
              (bigint-compare bigint-as-zero.w-depth-change
                w-depth-change)
              yep - (nope/nil)
              (yep/nil)))
          tree)
        
        err.\-qq[Internal error]))
  
  /attempt-shift (yep/nil) /fn -
  /attempt-shift (nope/nil) /fn -
   yep.ybranch))

\ NOTE: This body takes its args as (state k v).
(defn avl-short-fold-asc state tree body
  (case tree avl-leaf fixops compare
    nope.state
  /case tree avl-branch fixops compare key val branches
    (cast branches avl-branches nub nbranch yub ybranch
      err.\-qq[Expected a branches value of type avl-branches]
    /caselet first-result
      (c-new avl-short-fold-asc state nbranch body)
      
      yep - first-result
      
      nope state
      (caselet second-result (c body state k v)
        yep - second-result
        nope state (c-new avl-short-fold-asc state ybranch body)
        err.\-qq[Expected body to return a value of type yep or nope])
      
      err.\-qq[Internal error])
    err.\-qq[Expected a tree value of type avl-leaf or avl-branch]))

\ NOTE: This body takes its args as (state k v).
(defn avl-map-short-fold-asc state tree body
  (case tree avl-leaf fixops compare
    (map-fold-state state self)
  /case tree avl-branch fixops compare key val branches
    (cast branches avl-branches nub nbranch yub ybranch
      err.\-qq[Expected a branches value of type avl-branches]
    /caselet first-result
      (c-new avl-map-short-fold-asc state nbranch body)
      
      yep - first-result
      
      map-fold-state state result-nbranch
      (caselet second-result (c body state k v)
        
        yep - second-result
        
        map-fold-state state result-val
        (caselet third-result
          (c-new avl-map-short-fold-asc state ybranch body)
          
          yep - third-result
          
          map-fold-state state result-ybranch
          (map-fold-state state
          /avl-branch fixops compare key result-val
          /avl-branches nub result-nbranch yub result-ybranch)
          
          err.\-qq[Internal error])
        
        err.\-qq[
          Expected body to return a value of type yep or
          map-fold-state])
      
      err.\-qq[Internal error])
    err.\-qq[Expected a tree value of type avl-leaf or avl-branch]))

(defn avl-get-max-depth tree
  (case tree avl-leaf fixops compare
    bigint-zero-for-fixops.fixops
  /case tree avl-branch fixops compare key val branches
    (cast branches avl-branches nub nbranch yub ybranch
      err.\-qq[Expected a branches value of type avl-branches]
    /let zero bigint-zero-for-fixops.fixops
    /let one bigint-as-one.zero
    /bigint-plus one /c-new avl-get-max-depth /case nub nil
      ybranch
      nbranch)
    err.\-qq[Expected a tree value of type avl-leaf or avl-branch]))

(defn avl-merge a b maybe-process-both
  \ TOOD: Make sure this algorithm is near-optimal both when
  \ `maybe-process-both` is (yep ...) and when it's (nil). When it's
  \ (nil), this algorithm certainly takes at least O( m + n ) time
  \ because it transforms every element.
  \
  \ Online forum advice for merging AVL trees seems to recommend the
  \ use of sorted vectors, building the tree by bisecting the vector.
  \ We don't really have bigint-indexable vectors, and bisecting a
  \ bigint would have its own time complexity to worry about, so
  \ that's not an obvious way forward.
  \
  \ (Yes, we're worrying about bigint operation complexity while not
  \ worrying about memory allocation complexity.)
  
  \ TODO: Stop using cons as a pair here.
  (let to-left
    (fn val
      (case maybe-process-both yep -
        val
        (cons yep.val (nil))))
  /let to-right
    (fn val
      (case maybe-process-both yep -
        val
        (cons (nil) yep.val)))
  /let to-both-keys (fn left right right)
  /let to-both
    (fn left right
      (case maybe-process-both yep process-both
        (c process-both left right)
        (cons yep.left yep.right)))
  /let map-left
    (fn a-branch
      (case maybe-process-both yep -
        a-branch
        (avl-map-short-fold-asc (nil) a-branch /fn state k v
          (nope/c to-left v))))
  /let map-right
    (fn b-branch
      (case maybe-process-both yep -
        b-branch
        (avl-map-short-fold-asc (nil) b-branch /fn state k v
          (nope/c to-right v))))
  /let bigint-minus-one (fn n /bigint-minus n bigint-as-one.n)
  /let combine-branch-changes
    (fn wub tub w-balanced-change t-balanced-change
      w-sub-merge-change t-sub-merge-change
      \ TODO: This is one of the few places that actually adds two
      \ depth numbers of non-constant size. See if there's an
      \ alternative algorithm that avoids this. If there is, we should
      \ switch to a unary bigint representation of depth.
      (case bigint-is-zero.wub yep -
        (bigint-plus t-balanced-change t-sub-merge-change)
        (bigint-plus w-balanced-change w-sub-merge-change)))
  /cast a avl-branch a-fixops a-compare a-key a-val a-branches
    (let max-depth avl-get-max-depth.b
    /depth-changed max-depth bigint-as-zero.max-depth /c map-right b)
  /cast b avl-branch b-fixops b-compare b-key b-val b-branches
    (let max-depth avl-get-max-depth.a
    /depth-changed bigint-as-zero.max-depth max-depth /c map-left a)
  /caselet b-lt-a (c a-compare b-key a-key) nil
    
    (cast a-branches avl-branches a-nub a-nbranch a-yub a-ybranch
      err.\-qq[Expected an a-branches value of type avl-branches]
    /cast b-branches avl-branches b-nub b-nbranch b-yub b-ybranch
      err.\-qq[Expected a b-branches value of type avl-branches]
    /cast (c-new avl-merge a-nbranch b-nbranch maybe-process-both)
      depth-changed an-change bn-change nbranch
      err.\-qq[Internal error]
    /let nub (bigint-plus a-nub an-change)
    /cast (c-new avl-merge a-ybranch b-ybranch maybe-process-both)
      depth-changed ay-change by-change ybranch
      err.\-qq[Internal error]
    /let yub (bigint-plus a-yub ay-change)
    /cast
      (improper-avl-branch-balance
      /avl-branch a-fixops a-compare
        (c to-both-keys a-key b-key)
        (c to-both a-val b-val)
      /avl-branches nub nbranch yub ybranch)
      depth-changed n-change y-change tree
      err.\-qq[Internal error]
    /depth-changed
      (c combine-branch-changes
        a-nub a-yub n-change y-change an-change ay-change)
      (c combine-branch-changes
        b-nub b-yub n-change y-change bn-change by-change)
      tree)
    
    \ TODO: See if this case would be more efficient if we sometimes
    \ merged `a-wbranch` and `b` instead. We'd probably need to know
    \ which of `a` and `b` is smallest, and then merge it with the
    \ smallest branch of the other.
    (cast (avl-branches-swap b-lt-a a-branches)
      avl-branches a-wub a-wbranch a-tub a-tbranch
      err.\-qq[Expected an a-branches value of type avl-branches]
    /cast (avl-branches-swap b-lt-a b-branches)
      avl-branches b-wub b-wbranch b-tub b-tbranch
      err.\-qq[Expected a b-branches value of type avl-branches]
    /cast
      (depth-changed-swap b-lt-a
      /c-new avl-merge a b-tbranch maybe-process-both)
      depth-changed a-merge-change b-merge-change tbranch
      err.\-qq[Internal error]
    /let wbranch (c map-right b-wbranch)
    /let tub (bigint-plus b-tub b-merge-change)
    /cast
      (depth-changed-swap b-lt-a
      /improper-avl-branch-balance
      /avl-branch b-fixops b-compare b-key (c to-right b-val)
      /avl-branches-swap b-lt-a
      /avl-branches b-wub wbranch tub tbranch)
      depth-changed w-balance-change t-balance-change tree
      err.\-qq[Internal error]
    /depth-changed
      (bigint-plus t-balance-change a-merge-change)
      (c combine-branch-changes
        b-wub b-tub w-balance-change t-balance-change
        bigint-as-zero.b-merge-change b-merge-change)
      tree)))

(defn avl-minus-extreme-entry tree k-polarity
  (case tree avl-leaf fixops compare
    nope.tree
  /case tree avl-branch fixops compare key val branches
    (cast (avl-branches-swap k-polarity branches)
      avl-branches wub wbranch tub tbranch
      err.\-qq[Expected a branches value of type avl-branches]
    /case (c-new avl-minus-extreme-entry tbranch k-polarity)
      
      nope -
      (avl-minus-extreme-entry-succeeded (yep/nil) key val wbranch)
      
      avl-minus-extreme-entry-succeeded
      max-depth-decreased subtracted-key subracted-val tbranch
      (let wub
        (case max-depth-decreased yep -
          (bigint-plus wub bigint-as-one.wub)
          wub)
      /cast
        (depth-changed-swap k-polarity
        /improper-avl-branch-balance
        /avl-branch fixops compare key val
        /avl-branches-swap k-polarity
        /avl-branches wub wbranch tub tbranch)
        depth-changed w-depth-change t-depth-change balanced-tree
        err.\-qq[Internal error]
      /cast balanced-tree avl-branch - -b -c -d balanced-branches
        err.\-qq[Internal error]
      /cast balanced-branches
        avl-branches balanced-wub - balanced-tub -b
        err.\-qq[Internal error]
      /avl-minus-extreme-entry-succeeded
        
        \ There are two ways the overall max depth can decrease:
        \
        \  - Subtracting the entry from one side caused that side to
        \    stop having more max depth than the other.
        \  - Subtracting the entry from one side caused that side to
        \    have much less max depth than the other, and the other
        \    lost some depth during a rebalancing.
        \
        (or-yep-nope
          (and-yep-nope (not-yep-nope bigint-is-zero.tub)
            bigint-is-zero.balanced-tub)
          (and-yep-nope max-depth-decreased
          /and-yep-nope (not-yep-nope bigint-is-zero.balanced-wub)
            (case
              (bigint-compare bigint-as-zero.w-depth-change
                w-depth-change)
              yep - (nope/nil)
              (yep/nil))))
        
        subtracted-key subtracted-val balanced-tree)
      
      err.\-qq[Internal error])
    err.\-qq[Expected a tree value of type avl-leaf or avl-branch]))

(defn avl-plus-entry tree k v
  (case tree avl-leaf fixops compare
    (let zero bigint-zero-for-fixops.fixops
    /yep/avl-branch fixops compare k v
    /avl-branches zero tree zero tree)
  /case tree avl-branch fixops compare key val branches
    (caselet polarity (c compare key k) nil
      (nope/avl-branch fixops compare k v branches)
    /cast (avl-branches-swap polarity branches)
      avl-branches wub wbranch tub tbranch
      err.\-qq[Expected a branches value of type avl-branches]
    /cast
      \ TODO: Stop using cons as a pair here.
      (case (c-new avl-plus-entry tbranch k v)
        nope result (cons (nope/nil) result)
        yep result (cons (yep/nil) result)
        err.\-qq[Internal error])
      cons max-depth-increased tbranch
      err.\-qq[Internal error]
    /let new-tub
      (case max-depth-increased yep -
        (bigint-plus tub bigint-as-one.tub)
        tub)
    /cast
      (depth-changed-swap polarity
      /improper-avl-branch-balance
      /avl-branch fixops compare key val
      /avl-branches-swap polarity
      /avl-branches wub wbranch new-tub tbranch)
      depth-changed w-depth-change t-depth-change balanced-tree
      err.\-qq[Internal error]
    /cast balanced-tree avl-branch - -b -c -d balanced-branches
      err.\-qq[Internal error]
    /cast balanced-branches
      avl-branches balanced-wub - balanced-tub -b
      err.\-qq[Internal error]
    /yep-nope-swap
      
      \ There are two ways the overall max depth can increase:
      \
      \  - Adding the entry to one side caused that side to start
      \    having more max depth than the other.
      \  - Adding the entry to one side caused that side to have much
      \    more max depth than the other, and it didn't lose that edge
      \    during a rebalancing.
      \
      (or-yep-nope
        (and-yep-nope bigint-is-zero.tub
        /not-yep-nope bigint-is-zero.balanced-tub)
        (and-yep-nope max-depth-increased
        /and-yep-nope (not-yep-nope bigint-is-zero.balanced-tub)
          (case
            (bigint-compare bigint-as-zero.t-depth-change
              t-depth-change)
            nope - (nope/nil)
            (yep/nil))))
      yep.balanced-tree)
    err.\-qq[Expected a tree value of type avl-leaf or avl-branch]))

(defn avl-minus-entry tree k
  (case tree avl-leaf fixops compare
    nope.tree
  /case tree avl-branch fixops compare key val branches
    (caselet polarity (c compare key k) nil
      (avl-branch-finish-minus fixops compare branches)
    /cast
      \ TODO: Stop using cons as a pair here.
      (case (c-new avl-minus-entry tbranch k)
        nope result (cons (nope/nil) result)
        yep result (cons (yep/nil) result)
        err.\-qq[Internal error])
      cons max-depth-decreased tbranch
      err.\-qq[Internal error]
    /let new-wub
      (case max-depth-decreased yep -
        (bigint-plus tub bigint-as-one.tub)
        tub)
    /cast
      (depth-changed-swap polarity
      /improper-avl-branch-balance
      /avl-branch fixops compare key val
      /avl-branches-swap polarity
      /avl-branches new-wub wbranch tub tbranch)
      depth-changed w-depth-change t-depth-change balanced-tree
      err.\-qq[Internal error]
    /cast balanced-tree avl-branch - -b -c -d balanced-branches
      err.\-qq[Internal error]
    /cast balanced-branches
      avl-branches balanced-wub - balanced-tub -b
      err.\-qq[Internal error]
    /yep-nope-swap
      
      \ There are two ways the overall max depth can decrease:
      \
      \  - Subtracting the entry from one side caused that side to
      \    stop having more max depth than the other.
      \  - Subtracting the entry from one side caused that side to
      \    have much less max depth than the other, and the other lost
      \    some depth during a rebalancing.
      \
      (or-yep-nope
        (and-yep-nope (not-yep-nope bigint-is-zero.tub)
          bigint-is-zero.balanced-tub)
        (and-yep-nope max-depth-increased
        /and-yep-nope (not-yep-nope bigint-is-zero.balanced-tub)
          (case
            (bigint-compare bigint-as-zero.w-depth-change
              w-depth-change)
            nope - (yep/nil)
            (nope/nil))))
      yep.balanced-tree)
    err.\-qq[Expected a tree value of type avl-leaf or avl-branch]))

(defn avl-has-any tree
  (case tree avl-leaf fixops compare
    (nope/nil)
    (yep/nil)))

\ TODO: Rename this to be more convenient to call.
(defn avl-minus-entry-ignoring-depth avl k
  (case (avl-minus-entry avl k)
    yep result result
    nope result result
    err.\-qq[Internal error]))

\ TODO: Rename this to be more convenient to call.
(defn avl-plus-entry-ignoring-depth avl k
  (case (avl-plus-entry avl k)
    yep result result
    nope result result
    err.\-qq[Internal error]))

(defn avl-plus-nil tree k
  (avl-plus-entry tree k /nil))

(defn avl-plus-nils tree list
  (foldl tree list /avl-plus-nil))

\ NOTE: This body takes its args as (k v).
(defn avl-any tree body
  (caselet result
    (avl-short-fold-asc (nil) tree /fn state k v /body k v))
    nope - (nope/nil)
    result))

\ NOTE: This body takes its args as (k v).
(defn avl-each tree body
  (let -
    (avl-any tree /fn k v
      (let - (body k v)
      /nope/nil))
  /nil))

\ NOTE: This body takes its args as (k v).
(defn avl-map tree body
  (case
    (avl-map-short-fold-asc (nil) tree /fn state k v
      (map-fold-state (nil) /body k v))
    map-fold-state state result result
    err.\-qq[Internal error]))

(defn avl-plus a b
  (cast (avl-merge a b /yep/fn a b b)
    depth-changed n-depth-change y-depth-change tree
    err.\-qq[Internal error]
    tree))


\ ===== Finger trees =================================================

\ NOTE: Finger trees don't have their best amortized computational
\ complexity unless they can use lazy thunks, so they're not like the
\ other, stateless utilities here.

\ The `ftree-meta` value's `make-lazy` and `force` should usually
\ implement memoized thunks. However, they may also implement pure
\ thunks that execute more than once. This finger tree implementation
\ will only ever call them with thunks that are safe to execute more
\ than once, and which have the same space footprint before and after
\ the computation.
\
\ When `make-lazy` implements memoized thunks, the `ftree-push` and
\ `ftree-pop` operations run in amortized constant time, and the
\ `ftree-get-summary-stack` and `ftree-split` operations run in
\ logarithmic time. (TODO: Is that true?)
\
\ When it implements pure thunks, all four of these operations run in
\ logarithmic time. (TODO: Is that true?)

(defn make-immediate-lazy make-lazy val
  (c make-lazy /fn - val))

(defn list-order-swap polarity list
  (case polarity yep - list rev.list))

(def-type ftree-meta make-lazy force measure plus)
(def-type ftree-node summary elements)

\ NOTE: The values of `n-digits` and `y-digits` are lists of one to
\ four elements. When used directly in an `ftree-deep`, the elements
\ in `n-digits` are the first ones, and the keys in `y-digits` are the
\ last ones.
(def-type ftree-digits n-digits y-digits)

(def-type ftree-empty meta)
(def-type ftree-single meta element)

\ NOTE: The value of `lazy-next` is a `make-lazy` object that
\ calculates a finger tree containing "nodes" containing the type of
\ elements of this finger tree. A node is an object of the form
\ (ftree-node summary elements), where `elements` is a list of two or
\ three elements.
(def-type ftree-deep meta digits lazy-next)

(defn ftree-digits-swap polarity digits
  (case polarity yep - digits
  /cast digits ftree-digits n-digits y-digits
    err.\-qq[Expected a digits value of type ftree-digits]
  /ftree-digits y-digits n-digits))

(defn ftree-push tree polarity new-element
  (case tree ftree-empty meta
    (ftree-single meta new-element)
  /case tree ftree-single meta element
    (cast meta ftree-meta make-lazy force measure plus
      err.\-qq[Expected a meta value of type ftree-meta]
    /let sub-measure
      (fn node
        (cast node ftree-node summary elements
          err.\-qq[Expected a node value of type ftree-node]
          summary))
    /ftree-deep meta
      (ftree-digits-swap polarity
      /ftree-digits (cons element /nil) (cons new-element /nil))
    /make-immediate-lazy make-lazy
    /ftree-empty/ftree-meta make-lazy force sub-measure plus)
  /case tree ftree-deep meta digits lazy-next
    (cast meta ftree-meta make-lazy force measure plus
      err.\-qq[Expected a meta value of type ftree-meta]
    /cast (ftree-digits-swap polarity digits)
      ftree-digits w-digits t-digits
      err.\-qq[Expected a digits value of type ftree-digits]
    /let not-four-digits
      (fn -
        (ftree-deep meta
          (ftree-digits-swap polarity
          /ftree-digits w-digits (append t-digits /cons element /nil))
          lazy-next))
    /cast t-digits cons d0 t-digits (c not-four-digits /nil)
    /cast t-digits cons d1 t-digits (c not-four-digits /nil)
    /cast t-digits cons d2 t-digits (c not-four-digits /nil)
    /cast t-digits cons d3 t-digits (c not-four-digits /nil)
    /let d012 (cons d0 /cons d1 /cons d2 /nil)
    /let new-node (ftree-node (c plus /map d012 measure) d012)
    /ftree-deep meta
      (ftree-digits-swap polarity
      /ftree-digits w-digits (cons d3 /cons element /nil))
    \ NOTE: This `makeLazy()` isn't constant-time, so it's impure. It
    \ does have the same space footprint before and after.
    /c make-lazy /fn -
      (c-new ftree-push (c force lazy-next) polarity new-node))
    err.\-qq[
      Expected a tree value of type ftree-empty, ftree-single, or
      ftree-deep]))

\ NOTE: If the `polarity` is `(nope/nil)`, this will push the elements
\ so they're in the opposite order as they are in the original list.
(defn ftree-push-list tree polarity list
  (foldl tree list /fn tree elem /ftree-push tree polarity elem))

(def-type ftree-pop-result maybe-popped-val tree)

(defn ftree-pop tree polarity
  (case tree ftree-empty meta
    (ftree-pop-result (nil) tree)
  /case tree ftree-single meta element
    (ftree-pop-result yep.element ftree-empty.meta)
  /case tree ftree-deep meta digits lazy-next
    (cast (ftree-digits-swap polarity digits)
      ftree-digits w-digits t-digits
      err.\-qq[Expected a digits value of type ftree-digits]
    /cast rev.t-digits cons last rev-past
      err.\-qq[Expected a t-digits value with at least one digit]
    /ftree-pop-result yep.last
    /c-new ftree-maybe-deep polarity meta
      (ftree-digits-swap polarity /ftree-digits w-digits rev.rev-past)
      lazy-next)
    err.\-qq[
      Expected a tree value of type ftree-empty, ftree-single, or
      ftree-deep]))

(defn ftree-get-summary-stack tree
  (case tree ftree-empty meta
    (cast meta ftree-meta make-lazy force measure plus
      err.\-qq[Expected a meta value of type ftree-meta]
    /cons (c plus /nil) /nil)
  /case tree ftree-single meta element
    (cast meta ftree-meta make-lazy force measure plus
      err.\-qq[Expected a meta value of type ftree-meta]
    /cons (c measure element) /nil)
  /case tree ftree-deep meta digits lazy-next
    (cast meta ftree-meta make-lazy force measure plus
      err.\-qq[Expected a meta value of type ftree-meta]
    /let add-side
      (fn summary polarity
        (cast (ftree-digits-swap polarity digits)
          ftree-digits w-digits t-digits
          err.\-qq[Expected a digits value of type ftree-digits]
        /foldl summary t-digits /fn summary digit
          (c plus /list-order-swap polarity
          /cons summary /cons (c measure digit) /nil)))
    /let parent-summary-stack
      (c-new ftree-get-summary-stack /c force lazy-next)
    /cast parent-summary-stack cons summary rest
      err.\-qq[Internal error]
    /let summary (c add-side summary /nope/nil)
    /let summary (c add-side summary /yep/nil)
    /cons summary parent-summary-stack)
    err.\-qq[
      Expected a tree value of type ftree-empty, ftree-single, or
      ftree-deep]))

(def-type ftree-split-iter-state summary-so-far rev-before after)
(def-type ftree-split-iter-result-fell-off summary-so-far)
(def-type ftree-split-iter-result-completed early-tree late-tree)

(defn ftree-split-iter
  tree summary-so-far summary-stack polarity test-is-early
  
  (case tree ftree-empty meta
    ftree-split-iter-result-fell-off.summary-so-far
  /case tree ftree-single meta element
    (let summary-so-far
      (c plus /list-order-swap polarity
      /cons (c measure element) /cons summary-so-far /nil)
    /case (c test-is-early summary-so-far) yep -
      ftree-split-iter-result-fell-off.summary-so-far
    /ftree-split-iter-result-completed ftree-empty.meta tree)
  /case tree ftree-deep meta digits lazy-next
    (cast meta ftree-meta make-lazy force measure plus
      err.\-qq[Expected a meta value of type ftree-meta]
    /cast summary-stack cons summary-stack-first summary-stack-rest
      err.\-qq[Expected a summary-stack value of type cons]
    /cast (ftree-digits-swap polarity digits)
      ftree-digits w-digits t-digits
      err.\-qq[Expected a digits value of type ftree-digits]
    /let try-side
      (fn summary-so-far side-polarity on-failed
        (let iterating-inward
          (not-yep-nope/xor-yep-nope polarity side-polarity)
        /cast (ftree-digits-swap polarity digits)
          ftree-digits w2-digits t2-digits
          err.\-qq[Internal error]
        /let digits-to-traverse
          (list-order-swap iterating-inward rev.t2-digits)
        /case
          (foldl-short
            (ftree-split-iter-state summary-so-far (nil)
              digits-to-traverse)
            digits-to-traverse
          /fn state elem
            (cast state
              ftree-split-iter-state summary-so-far rev-before after
              err.\-qq[Internal error]
            /cast after cons elem after
              err.\-qq[Internal error]
            /let summary-so-far
              (c plus /list-order-swap polarity
              /cons (c measure elem) /cons summary-so-far /nil)
            /case (c test-is-early summary-so-far) yep -
              (nope/ftree-split-iter-state
                summary-so-far (cons elem rev-before) after)
              yep.state))
          
          yep state
          (cast state
            ftree-split-iter-state summary-so-far rev-before after
            err.\-qq[Internal error]
          /c on-failed summary-so-far)
          
          nope state
          (cast state
            ftree-split-iter-state summary-so-far rev-before after
            err.\-qq[Internal error]
          /let w2t-digits
            (case iterating-inward yep -
              rev.after
              rev.rev-before)
          /let t2-digits
            (case iterating-inward yep -
              rev-before
              after)
          /let t2-tree
            (ftree-push-list ftree-empty.meta side-polarity t2-digits)
          /let w2-tree
            (ftree-maybe-deep side-polarity meta
              (ftree-digits-swap side-polarity
              /ftree-digits w2-digits w2t-digits)
              lazy-next)
          /case iterating-inward yep -
            (ftree-split-iter-result-completed t2-tree w2-tree)
            (ftree-split-iter-result-completed w2-tree t2-tree))
          
          err.\-qq[Internal error]))
    
    \ Try each of the `polarity`-side digits.
    /c try-side summary-so-far polarity /fn summary-so-far
    
    \ Try a recursive call on the `lazy-next`.
    /case
      (c-new ftree-split-iter (c force lazy-next) summary-so-far
        summary-stack-rest polarity test-is-early)
      
      ftree-split-iter-result-completed early-tree late-tree
      (ftree-split-iter-result-completed
        (ftree-push-list early-tree polarity t-digits)
        (ftree-push-list late-tree not-yep-nope.polarity w-digits))
      
      ftree-split-iter-result-fell-off summary-so-far
      \ Try each of the digits on the side opposite to `polarity`.
      (c try-side summary-so-far not-yep-nope.polarity
      /fn summary-so-far
      /ftree-split-iter-result-fell-off summary-so-far)
      
      err.\-qq[Internal error])
    
    err.\-qq[
      Expected a tree value of type ftree-empty, ftree-single, or
      ftree-deep]))

\ This works like `(ftree-deep meta digits lazy-next)`, except that it
\ allows one of the sides of digits to be empty.
(defn ftree-maybe-deep polarity meta digits lazy-next
  (cast meta ftree-meta make-lazy force measure plus
    err.\-qq[Expected a meta value of type ftree-meta]
  /cast (ftree-digits-swap polarity digits)
    ftree-digits w-digits t-digits
    err.\-qq[Expected a digits value of type ftree-digits]
  /case t-digits cons - -b (ftree-deep meta digits lazy-next)
  /cast (ftree-pop (c force lazy-next) polarity)
    ftree-pop-result maybe-node rest
    err.\-qq[Internal error]
  /cast maybe-node yep node
    (ftree-push-list ftree-empty.meta not-yep-nope.polarity w-digits)
  /cast node ftree-node summary elements
    err.\-qq[
      Expected the finger tree in lazy-next to contain values of type
      ftree-node]
  /ftree-deep meta
    (ftree-digits-swap polarity
    /ftree-digits w-digits (list-order-swap polarity elements))
  /make-immediate-lazy make-lazy rest))

(defn ftree-append-with-middle a middle b
  (case a ftree-empty meta
    (ftree-push-list b (nope/nil) rev.middle)
  /case b ftree-empty meta
    (ftree-push-list a (yep/nil) middle)
  /case a ftree-single meta element
    (ftree-push-list b (nope/nil) /rev-onto middle /cons element /nil)
  /case b ftree-single meta element
    (ftree-push-list a (yep/nil) /append middle /cons element /nil)
  /cast a ftree-deep a-meta a-digits a-lazy-next
    err.\-qq[
      Expected an a value of type ftree-empty, ftree-single, or
      ftree-deep]
  /cast a-digits ftree-digits an-digits ay-digits
    err.\-qq[Expected an a-digits value of type ftree-digits]
  /cast b ftree-deep b-meta b-digits b-lazy-next
    err.\-qq[
      Expected a b value of type ftree-empty, ftree-single, or
      ftree-deep]
  /cast b-digits ftree-digits bn-digits by-digits
    err.\-qq[Expected a b-digits value of type ftree-digits]
  /cast a-meta ftree-meta make-lazy force measure plus
    err.\-qq[Expected an a-meta value of type ftree-meta]
  /ftree-deep a-meta (ftree-digits an-digits by-digits)
  \ NOTE: This `make-lazy` isn't constant-time, so it's impure. It
  \ does have the same space footprint before and after.
  /c make-lazy /c-new ftree-append-with-middle
    (c force a-lazy-next)
    (append ay-digits /append middle bn-digits)
    (c force b-lazy-next)))

(defn ftree-split-result early-tree late-tree)

\ This looks through every segment of the tree starting from the end
\ that corresponds with `polarity` until it can drill down to the one
\ element whose summary doesn't satisfy the predicate `test-is-early`.
\ It returns `(ftree-split-result early-tree late-tree)` with a tree
\ containing the early elements and a tree containing the rest. (Note
\ that if the polarity is 1, the `earlyTree` will be a suffix of the
\ original tree, and `lateTree` will be a prefix.)
\
\ The `test-is-early` function is expected to satisfy certain
\ properties with regard to the measurement monoid:
\
\   early (a + b) -> early a
\   early 0
\
\ This allows us to scan over aggregate summaries (the `summary`
\ property of `(ftree-node summary elements)` node values) and
\ determine they're fully early without having to drill down and scan
\ them for exceptional prefixes.
\
\ NOTE: This operation doesn't follow quite the same contract as Hinze
\ and Paterson's `splitTree`. In particular, where we use
\ `test-is-early`, they use the complement of that predicate, and
\ where we split the tree into two trees, they split it into two trees
\ and a first non-early element in between, which their operation
\ requires to exist.
\
(defn ftree-split tree polarity test-is-early
  (cast
    (case tree ftree-empty meta meta
    /case tree ftree-single meta element meta
    /case tree ftree-deep meta digits lazy-next meta
      err.\-qq[
        Expected a tree value of type ftree-empty, ftree-single, or
        ftree-deep])
    ftree-meta make-lazy force measure plus
    err.\-qq[Expected a meta value of type ftree-meta]
  /case
    (ftree-split-iter (c plus /nil) ftree-summary-stack.tree polarity
      test-is-early)
    
    ftree-split-iter-result-fell-off summary-so-far
    \ Apparently everything is early.
    (ftree-split-result tree ftree-empty.meta)
    
    ftree-split-iter-result-completed early-tree late-tree
    (ftree-split-result early-tree late-tree)
    
    err.\-qq[Internal error]))


\ ===== Finishing up and some basic unit tests =======================

(run-defs)

(test/rev/cons (yep/nil) /cons (nope/nil) /nil)

(test/rev/nil)

(test/not-yep-nope/yep/nil)

(test
  (let x (nope/nil) y (yep/nil)
  /let x y y x
  /cons x y))
