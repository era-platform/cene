\ era-staccato-lib.stc
\ Copyright 2015 Ross Angle. Released under the MIT License.


\ Although this may look like source code, and it may even become full
\ source code at some point, right now it mostly serves as a
\ collection of notes.
\
\ One side of the notes explores a potential high-level design for
\ Staccato macro definitions and ad hoc namespace manipulation. This
\ is far more expressive than Staccato is likely to support for some
\ time, but it means that I can writing Staccato code freely, safe in
\ the knowledge that I won't be tied down to regretful name choices or
\ ever-growing lists of syntactic primitives.
\
\ The other side of these notes begins the more immediate exercise of
\ porting the era-stacato.js desugarer to Staccato. This could
\ hypothetically be used to implement `(defn ...)` and
\ `(def-type ...)` as macros someday, but what it proves is that the
\ design of the desugarer itself is something programmers can replace
\ when needed. Furthermore, the port should ultimately support a
\ slightly different syntax than before: In a raw Staccato AST,
\ constructors and their projections will no longer be designated by
\ unqualified strings, but by fully qualified names.
\
\ TODO: The macro system would have all definitions happen as side
\ effects of macro calls. On the other hand, the desugarer can't
\ eliminate (def ...) until basically the end of the desugaring
\ process; all of the desugaring leads up to that.


\ ===== Notes and examples for using the macro system ================

\ These depend on a type `(stx stx-details s-expr)` representing an
\ s-expression tagged with source location information.
\
\ These depend on a type `(foreign name)` representing an s-expression
\ that consists of a name. The program may not know of a way to encode
\ the name as serializable data, but it can still be passed to
\ `(compile ...)`.
\
\ These depend on a macro `(nam name)` which obtains a first-class
\ representation of the given name. This is usually useless, but it is
\ useful for `(compile ...)`.
\
\ These sort of depend on a macro `(new type)`, which creates a value
\ of the given type. The type must have no projections.
\
\ These depend on a macro `(str string)`, which obtains a first-class
\ string value with the given literal text.
\
\ These depend on a function `(compile unique-ns definition-ns stx)`
\ which macroexpands the given `stx` and installs any definitions it
\ produces.
\
\ A macro could depend on a function `(derive-ns ns ns)` which obtains
\ a sub-namespace determined by the first namespace, using the second
\ namespace's complete identity as a "folder name." Usually, distinct
\ "folder names" will yield distinct sub-namespaces, but sometimes the
\ interpreter may be configured so that this isn't the case.
\
\ These depend on a function `(string-ns ns string)` which obtains a
\ sub-namespace determined by the first namespace, using the string as
\ a "folder name." Usually, distinct "folder names" will yield
\ distinct sub-namespaces, but sometimes the interpreter may be
\ configured so that this isn't the case.
\
\ These depend on a function `(ns-get ns)`, which blocks until the
\ given namespace has a defined Staccato value and then returns it.
\
\ A macro could depend on a function `(ns-put ns value)`, which
\ installs a definition so that the given namespace has a defined
\ Staccato value, namely the given one. The return value is `(nil)`.
\
\ Yes, we're using deterministic side effects during macroexpansion.
\ Since a macro will necessarily need to *read* existing definitions
\ in order for its implementation code to do anything at all, we're
\ doing concurrency with blocking reads and assumed-unique writes. If
\ two or more conflicting writes are performed, all definitions that
\ depended on reading those writes will be retroactively updated.
\ Usually, conflicting definitions are an error. However, at a REPL,
\ definitions from a newer command may take the place of definitions
\ from an older command without error. Errors or updates may cascade
\ through several layers of other definitions that depended on them.
\
\ Common definitions are stored like so, where slashes represent
\ `string-ns` except where marked as `derive-ns`:
\
\   <definition-ns>/constructor-names/<constructor name string>/name
\     = No defined value, but the proper identity to use for the
\       constructor in everything except manually keyboarded code.
\   <definition-ns>/constructor-names/<constructor name string>/
\       projection-list
\       = An ordered list of projection name strings. Projections
\         should only be treated as an ordered list in manually
\         keyboarded code and in macros catering to manually
\         keyboarded code.
\   <definition-ns>/constructor-names/<constructor name string>/
\     projection-names/<projection name string>/name
\     = No defined value, but the proper identity to use for the
\       projection in everything except manually keyboarded code.
\
\   <definition-ns>/macro-names/<macro name string>/name
\     = No defined value, but the proper identity to use for the macro
\       in everything except manually keyboarded code.
\
\   <definition-ns>/macros/<derive-ns: macro identity>/function
\     = A value that can be invoked with the arguments of a macro
\       call.
\
\   <definition-ns>/functions/<derive-ns: constructor identity>/
\     staccato
\     = An s-expression that can be compiled as a raw, sugarless
\       Staccato function definition.
\
\ The usual definition forms generate several definitions all at once:
\
\   (def-type ...)
\     * The constructor name information desired.
\     * A macro so that the construction is easy to do.
\     * The name information for that macro.
\     * Constructor name information for a callable value which
\       implements that macro.
\     * A function implementation for that callable value.
\
\   (defn ...)
\     * The function implementation desired.
\     * Constructor name information for a first-class representation
\       of the function.
\     * A macro so that the function is easy to call. (Fortunately,
\       every (defn ...) macro can reuse the same callable value
\       constructor and function implementation.)
\     * The name information for that macro.
\
\ A macro could depend on a function `(shadowing-ns ns ns ns)` which
\ creates a new namespace that behaves like the first namespace in
\ almost every way, except when the second namespace is requested as a
\ "folder name", in which case the third namespace is returned
\ instead. This can be used to establish local macros. The new
\ namespace even works the same way as the old one when it's used as
\ the "folder name" itself. This way, we can imagine that the
\ namespace's "complete identity" is stored as an entry somewhere in
\ the namespace, just using a key that we don't have the ability to
\ construct.
\
\ A macro's `unique-ns` parameter is a namespace. It's useful in the
\ way that gensyms are typically useful in other macro-capable
\ languages, but the uniqueness is achieved by playing along: If the
\ macro compiles more than one subexpression, each subexpression
\ should be given a `unique-ns` derived in different ways from this
\ one.
\
\ A macro's `definition-ns` parameter is a namespace. If the macro
\ needs to install any definitions or look up any definitions, this is
\ the namespace for that purpose. It should usually be passed as-is to
\ any compiled subexpressions, except when defining a macro that's
\ local to a certain subexpression.
\
\ A macro's `my-stx-details` parameter is a collection of source
\ location information. There's no direct way to deconstruct this
\ value, but it conveys information about this macro invocation, so
\ the macro can use it to receive attribution for any `stx` values it
\ creates.
\
\ (TODO: Figure out what the format of source location information
\ actually is. For now, this is sort of just an unspecified area, but
\ at least a language implementation can use this to hold filenames
\ and line numbers in practice. An implementation should be able to
\ treat this as a completely empty data structure; it's not needed for
\ any variable scoping purposes.)
\
\ A macro's `args` parameter is a list of `(stx stx-details s-expr)`
\ values. The list is built out of `(cons car cdr)` and `(nil)`
\ values.

(def-macro c-new unique-ns definition-ns my-stx-details args
  (let s (fn it /stx my-stx-details it)
  /cast args cons func-name args
    err.\-qq[Not enough arguments to c-new]
  /compile unique-ns definition-ns
  /c s
  /cons (c s /foreign nam.c)
  /cons (c s /list (c s /foreign nam.new) func-name)
    args))

(def-macro case unique-ns definition-ns my-stx-details args
  (let s (fn it /stx my-stx-details it)
  /compile (string-ns unique-ns str.body) definition-ns
  /c s
  /cons (c s /foreign nam.caselet)
  /cons (c s /foreign/string-ns unique-ns str.ignored)
    args))

(def-macro cast unique-ns definition-ns my-stx-details args
  (let s (fn it /stx my-stx-details it)
  \ TODO: Oops, we didn't need this utility. Do something with it.
  /let to-constructor-name
    (fn constructor-name
      (case constructor-name
        
        foreign name name
        
        string-nil constructor-string
        (string-ns
          (string-ns
            (string-ns definition-ns str.constructor-names)
            constructor-string)
          str.name)
        
        err.\-qq[Called cast with a non-name]))
  \ TODO: Oops, we didn't need this utility. Do something with it.
  /let to-projection-name
    (fn constructor-name projection-name
      (case projection-name
        
        foreign name name
        
        string-nil projection-string
        (case constructor-name string-nil constructor-string
          (string-ns
            (string-ns
              (string-ns
                (string-ns
                  (string-ns definition-ns str.constructor-names)
                  constructor-string)
                str.projection-names)
              projection-string)
            str.name)
          err.\-qq[
            Called to-projection-name with an inconsistent constructor
            name])
        
        err.\-qq[Called to-projection-name with a non-name]))
  /case args cons var args
    (case args cons constructor-string args
      (let projection-list
        (ns-get/string-ns
          (string-ns
            (string-ns definition-ns str.constructor-names)
            constructor-string)
          str.projection-names)
        \ TODO: Fold over the `projection-list` to get the pattern
        \ variables, and build a call to `(case ...)`.
        /TODO)
      err.\-qq[Not enough arguments to cast])
    err.\-qq[Not enough arguments to cast]))



\ ===== Reimplementation of the desugarer ============================


(def-type string val)
(defn string-compare a b /TODO)
\ TODO: Don't actually use (def-macro ...) for this -- at least, not
\ yet. Just implement this as a built-in macro.
(def-macro str /TODO)
(def-type name val)
(defn name-metacompare a b /TODO)


(def-type stc-def tuple-name opt-proj-pattern case-list)
(def-type stc-let-case var case-list)
(def-type stc-match tuple-name proj-pattern get-expr case-list)
(def-type stc-any get-expr)
(def-type stc-let-bindings-nil)
(def-type stc-let-bindings-cons var get-expr let-bindings-expr)
(def-type stc-proj-nil)
(def-type stc-proj-cons proj-name get-expr proj-expr)
(def-type stc-let-def def get-expr)
(def-type stc-let let-bindings-expr get-expr)
(def-type stc-local var)
(def-type stc-tuple tuple-name proj-expr)
(def-type stc-save-root save-root get-expr)
(def-type stc-save
  save-root call-tuple-name
  call-func tuple-name opt-proj-pattern
  call-arg var arg)
(def-type stc-fn tuple-name opt-proj-pattern case-list)
\ TODO: Make a note that this is a namespace from which the projection
\ names can be derived as "<ns>/<projection name>/name".
(def-type stc-proj-pattern-omitted namespace)
(def-type stc-proj-pattern proj-pattern)
(def-type stc-proj-pattern-nil)
(def-type stc-proj-pattern-cons proj-name var proj-pattern)


(def-type scope-policy-save-root save-root)
(def-type scope-policy-not-root)
(def-type scope-policy-does-not-matter)
(def-type scope-policy-no-free-vars)

(def-type visitor-object impl)
(def-type method-visitor-visit part shadow scope-policy)
(def-type method-visitor-redecorate extra-vars whole)
(def-type visitor-visit-result result visitor)

(defn make-visitor impl
  visitor-object.impl)

(defn visitor-visit visitor part shadow scope-policy
  (cast visitor visitor-object impl
    err.\-qq[Expected a visitor of type visitor-object]
  /c impl /method-visitor-visit part shadow scope-policy))

(defn visitor-redecorate visitor extra-vars whole
  (cast visitor visitor-object impl
    err.\-qq[Expected a visitor of type visitor-object]
  /c impl /method-visitor-redecorate extra-vars whole))


\ NOTE: In order to remove free variables as we cross binding forms
\ (`free-vars-minus`) and in order to infer deduplicated capture lists
\ (`free-vars-fold`), we need to be able to compare variable names for
\ equality.
\
\ Macros become more expressive if they can compare names for
\ equality -- maybe a little too expressive for namespace sandboxing
\ purposes -- but if we do this, we'll want an ordered comparison on
\ names as well. An ordered comparison would let us implement more
\ efficient name-indexed data structures.
\
\ Names have no natural ordering; even if they were ordered as
\ strings, that would block capture-avoiding alpha-renaming! So
\ whatever order we use, it will expose implementation details and
\ make namespace sandboxing into a headache... unless the
\ implementation details are hidden in the same way as we usually
\ hide them: By using obscure naming (and enforcing the obscurity with
\ code-signing if necessary).
\
\ We can refrain from exposing implementation details by defining
\ "metacompare" operations that usually work like "compare"
\ operations, but sometimes return values that user-defined macro code
\ doesn't know how to deconstruct. (The "meta" stands for
\ "metacircular", because there may be a few layers of the reflective
\ tower all running as macros in the same macroexpansion phase. Each
\ layer must be implemented with obscure names that its interpreted
\ layer doesn't know about.) Once we have metacomparison operations,
\ we can provide an encapsulated AVL tree data type that sorts its
\ keys using a metacomparison.
\
\ The elegance of this encapsulated AVL tree data type will depend on
\ whether it lets us implement general computation on unordered
\ collections, or whether we instead have to complicate the language
\ design every time we need a new kind of computation. In service of
\ general computation, we may get quite a range of abilities all at
\ once if we simply add a metacomparator that compares the
\ encapsulated AVL trees themselves. That way we can detect emptiness
\ by comparing to the empty tree, and we can detect singletonhood by
\ comparing to the singletons of each entry.
\
\ In the process, a lot of ugliness may arise: If concatenation of
\ encapsulated AVL trees doesn't somehow check that their
\ metacomparators are equivalent, we may end up with malformed
\ encapsulated AVL trees that leak implementation details. We could
\ potentially avoid this situation by passing some sort of equality
\ certifier to the concatenation operation, but then we'd need a
\ specialized language (or at least a collection of combinators) for
\ defining equality certifiers. An easier approach would be to use a
\ specialized language (or combinators) for the metacomparators
\ themselves. This language would quickly resemble a static type
\ system, much like our "cmpd" utilities already resemble algebraic
\ data type definitions. So, this probably isn't worth solving until
\ we take a typed approach.
\
\ For now, we can start small, merely providing specific features as
\ built-ins, rather than aiming for general computation. As long as we
\ can at least perform an equality check on names
\ (`name-metacompare`), we can use inefficient association lists to
\ track free variables (`free-vars-object`).

(defn stringy-name-metacompare a b
  (bimap (cmpd-compare) a b /fn it
    (case it string -
      (cmpd-cons (string-compare) it /cmpd-nil)
    /cmpd-succ/case it name -
      (cmpd-cons (name-metacompare) it /cmpd-nil)
      err.\-qq[Expected a value of type string or name])))

(def-type free-var-entry-var name)
(def-type free-var-entry-saved-input-var save-root name)
(def-type free-var-entry-saved-free-var save-root name)
(def-type free-var-entry-scope-error)

(defn free-vars-entry-metacompare a b
  (bimap (cmpd-compare) a b /fn it
    (case it free-var-entry-var name
      (cmpd-cons (stringy-name-metacompare) name /cmpd-nil)
    /cmpd-succ/case it free-var-entry-saved-input-var save-root name
      (cmpd-cons (stringy-name-metacompare) save-root
      /cmpd-cons (stringy-name-metacompare) name
      /cmpd-nil)
    /cmpd-succ/case it free-var-entry-saved-free-var save-root name
      (cmpd-cons (stringy-name-metacompare) save-root
      /cmpd-cons (stringy-name-metacompare) name
      /cmpd-nil)
    /cmpd-succ/case it free-var-entry-scope-error
      (cmpd-nil)
      err.\-qq[Expected a free variable entry])))

(def-type free-vars-object list)

(defn free-vars-any free-vars check
  (cast free-vars free-vars-object list
    err.\-qq[
      Called free-vars-any with a free-vars that wasn't a
      free-vars-object]
  /any list check))

(defn free-vars-fold state free-vars combiner
  (cast free-vars free-vars-object list
    err.\-qq[
      Called free-vars-fold with a free-vars that wasn't a
      free-vars-object]
  /foldl state list combiner))

(defn free-vars-has free-vars entry
  (free-vars-any free-vars /fn entry2
    (isa nil /free-vars-entry-metacompare entry entry2)))

(defn free-vars-keep free-vars check
  (cast free-vars free-vars-object list
    err.\-qq[
      Called free-vars-keep with a free-vars that wasn't a
      free-vars-object]
  /free-vars-object /keep list check))

(defn free-vars-minus a b
  (free-vars-keep a /fn entry /not/free-vars-has b entry))

(defn free-vars-plus-entry free-vars entry
  (cast free-vars free-vars-object list
    err.\-qq[
      Called free-vars-plus-entry with a free-vars that wasn't a
      free-vars-object]
  /case (free-vars-has free-vars entry)
    yep - free-vars
    (free-vars-object /cons entry list)))

(defn free-vars -
  (free-vars-object/nil))

(defn free-vars-just entry
  (free-vars-plus-entry (free-vars/nil) entry))

(defn free-vars-map free-vars func
  (free-vars-fold (free-vars/nil) free-vars /fn state entry
    (free-vars-plus-entry state /c func entry)))

(defn free-vars-plus a b
  (free-vars-fold a b /fn state entry
    (free-vars-plus-entry state entry)))


(defn staccato-let-bindings-expr-keys let-bindings-expr
  (case let-bindings-expr
    
    let-bindings-nil
    (free-vars/nil)
    
    let-bindings-cons var get-expr let-bindings-expr
    (free-vars-plus-entry
      (c-new staccato-let-bindings-expr-keys let-bindings-expr)
      free-var-entry-var.var)
    
    err.\-qq[
      Called staccato-let-bindings-expr-keys on a value that wasn't a
      let-bindings-expr syntax]))

(defn staccato-proj-pattern-get-vars proj-pattern
  (case proj-pattern
    
    stc-proj-pattern-nil
    (free-vars/nil)
    
    stc-proj-pattern-cons proj-name var proj-pattern
    (free-vars-plus-entry
      (c-new staccato-proj-pattern-get-vars proj-pattern)
      free-var-entry-var.var)
    
    err.\-qq[
      Called staccato-proj-pattern-get-vars on a value that wasn't a
      proj-pattern syntax]))

(defn staccato-opt-proj-pattern-get-vars opt-proj-pattern
  (case opt-proj-pattern
    
    stc-proj-pattern-omitted namespace
    (nil)
    
    stc-proj-pattern proj-pattern
    (yep staccato-proj-pattern-get-vars.proj-pattern)
    
    err.\-qq[
      Called staccato-opt-proj-pattern-get-vars on a value that wasn't
      an opt-proj-pattern syntax]))

(defn opt-proj-pattern-or opt-proj-pattern default
  (case opt-proj-pattern
    
    stc-proj-pattern-omitted namespace
    (stc-proj-pattern
    /free-vars-fold (proj-pattern-nil) default /fn state var truth
      (cast var free-var-entry-var name
        err.\-qq[
          Called opt-proj-pattern-or with a default variable list that
          contained a key that wasn't a free-var-entry-var]
      \ TODO: Use args.namespace to derive the projection name, rather
      \ than just using the variable name directly.
      /stc-proj-pattern-cons name name state))
    
    stc-proj-pattern proj-pattern
    opt-proj-pattern
    
    err.\-qq[
      Called opt-proj-pattern-or on a value that wasn't an
      opt-proj-pattern syntax]))

(defn proj-pattern-capture proj-pattern
  (case proj-pattern
    
    stc-proj-pattern-nil
    (stc-proj-nil)
    
    stc-proj-pattern-cons proj-name var proj-pattern
    (stc-proj-cons proj-name (stc-local var)
    /c-new proj-pattern-capture proj-pattern)
    
    err.\-qq[
      Called proj-pattern-capture on a value that wasn't a
      proj-pattern syntax]))

(defn opt-proj-pattern-capture opt-proj-pattern
  (case opt-proj-pattern
    
    stc-proj-pattern-omitted namespace
    err.\-qq[
      Called opt-proj-pattern-capture on a stc-proj-pattern-omitted]
    
    stc-proj-pattern proj-pattern
    proj-pattern-capture.proj-pattern
    
    err.\-qq[
      Called opt-proj-pattern-capture on a value that wasn't an
      opt-proj-pattern syntax]))


(defn staccato-visit expr visitor
  (case expr
    
    stc-def tuple-name opt-proj-pattern case-list
    (cast
      (visitor-visit visitor case-list
        (case staccato-opt-proj-pattern-get-vars.opt-proj-pattern
          yep vars vars
          (free-vars/nil))
      /scope-policy-no-free-vars)
      visitor-visit-result case-list visitor
      err.\-qq[Internal error]
    /visitor-redecorate visitor (free-vars/nil)
    /stc-def tuple-name opt-proj-pattern case-list)
    
    stc-let-case var case-list
    (cast var string -
      err.\-qq[Visited a stc-let-case where the var was not a string]
    /cast
      (visitor-visit visitor case-list
        (free-vars-just free-var-entry-var.var)
      /scope-policy-does-not-matter)
      visitor-visit-result case-list visitor
      err.\-qq[Internal error]
    /visitor-redecorate visitor (free-vars/nil)
    /stc-let-case var case-list)
    
    stc-match tuple-name proj-pattern get-expr case-list
    (cast
      (visitor-visit visitor get-expr
        staccato-proj-pattern-get-vars.proj-pattern
      /scope-policy-not-root)
      visitor-visit-result get-expr visitor
      err.\-qq[Internal error]
    /cast
      (visitor-visit visitor case-list (free-vars/nil)
      /scope-policy-not-root)
      visitor-visit-result case-list visitor
      err.\-qq[Internal error]
    /visitor-redecorate visitor (free-vars/nil)
    /stc-match tuple-name proj-pattern get-expr case-list)
    
    stc-any get-expr
    (cast
      (visitor-visit visitor get-expr (free-vars/nil)
      /scope-policy-not-root)
      visitor-visit-result get-expr visitor
      err.\-qq[Internal error]
    /visitor-redecorate visitor (free-vars/nil)
    /stc-any get-expr)
    
    stc-let-bindings-nil
    (visitor-redecorate visitor (free-vars/nil)
    /stc-let-bindings-nil)
    
    stc-let-bindings-cons var get-expr proj-expr
    (cast
      (visitor-visit visitor get-expr (free-vars/nil)
      /scope-policy-not-root)
      visitor-visit-result get-expr visitor
      err.\-qq[Internal error]
    /cast
      (visitor-visit visitor proj-expr (free-vars/nil)
      /scope-policy-not-root)
      visitor-visit-result proj-expr visitor
      err.\-qq[Internal error]
    /visitor-redecorate visitor (free-vars/nil)
    /stc-let-bindings-cons var get-expr proj-expr)
    
    stc-proj-nil
    (visitor-redecorate visitor (free-vars/nil)
    /stc-proj-nil)
    
    stc-proj-cons proj-name get-expr proj-expr
    (cast
      (visitor-visit visitor get-expr (free-vars/nil)
      /scope-policy-not-root)
      visitor-visit-result get-expr visitor
      err.\-qq[Internal error]
    /cast
      (visitor-visit visitor proj-expr (free-vars/nil)
      /scope-policy-not-root)
      visitor-visit-result proj-expr visitor
      err.\-qq[Internal error]
    /visitor-redecorate visitor (free-vars/nil)
    /stc-proj-cons proj-name get-expr proj-expr)
    
    stc-let-def def get-expr
    (cast
      (visitor-visit visitor def (free-vars/nil)
      /scope-policy-does-not-matter)
      visitor-visit-result def visitor
      err.\-qq[Internal error]
    /cast
      (visitor-visit visitor get-expr (free-vars/nil)
      /scope-policy-not-root)
      visitor-visit-result get-expr visitor
      err.\-qq[Internal error]
    /visitor-redecorate visitor (free-vars/nil)
    /stc-let-def def get-expr)
    
    stc-let let-bindings-expr get-expr
    (cast
      (visitor-visit visitor let-bindings-expr (free-vars/nil)
      /scope-policy-not-root)
      visitor-visit-result let-bindings-expr visitor
      err.\-qq[Internal error]
    /cast
      (visitor-visit visitor get-expr
        staccato-let-bindings-expr-keys.let-bindings-expr
      /scope-policy-not-root)
      visitor-visit-result get-expr visitor
      err.\-qq[Internal error]
    /visitor-redecorate visitor (free-vars/nil)
    /stc-let let-bindings-expr get-expr)
    
    stc-local var
    (cast var string -
      err.\-qq[Visited a stc-local where the var was not a string]
    /visitor-redecorate visitor
      (free-vars-just free-var-entry-var.var)
    /stc-local var)
    
    stc-tuple tuple-name proj-expr
    (cast
      (visitor-visit visitor proj-expr (free-vars/nil)
      /scope-policy-not-root)
      visitor-visit-result proj-expr visitor
      err.\-qq[Internal error]
    /visitor-redecorate visitor (free-vars/nil)
    /stc-tuple tuple-name proj-expr)
    
    stc-save-root save-root get-expr
    (cast save-root string -
      err.\-qq[
        Visited a stc-local where the save-root was not a string]
    /cast
      (visitor-visit visitor get-expr (free-vars/nil)
      /scope-policy-save-root save-root)
      visitor-visit-result get-expr visitor
      err.\-qq[Internal error]
    /visitor-redecorate visitor (free-vars/nil)
    /stc-save-root save-root get-expr)
    
    stc-save
    save-root call-tuple-name
    call-func tuple-name opt-proj-pattern
    call-arg var arg
    (cast save-root string -
      err.\-qq[
        Visited a stc-save where the save-root was not a string]
    /cast
      (visitor-visit visitor arg (free-vars/nil)
      /scope-policy-save-root save-root)
      visitor-visit-result arg visitor
      err.\-qq[Internal error]
    /visitor-redecorate visitor
      (free-vars-plus-entry
        (case staccato-opt-proj-pattern-get-vars.opt-proj-pattern
          
          yep vars
          (free-vars-map vars /fn entry
            (cast entry free-var-entry-var name
              err.\-qq[Internal error]
            /free-var-entry-saved-free-var save-root name))
          
          (free-vars/nil))
      /free-var-entry-saved-input-var save-root var)
    /stc-save
      save-root call-tuple-name
      call-func tuple-name opt-proj-pattern
      call-arg var arg)
    
    stc-fn tuple-name opt-proj-pattern case-list
    (cast
      (visitor-visit visitor case-list (free-vars/nil)
      /scope-policy-not-root)
      visitor-visit-result case-list visitor
      err.\-qq[Internal error]
    /visitor-redecorate visitor
      (case staccato-opt-proj-pattern-get-vars.opt-proj-pattern
        yep vars vars
        (free-vars/nil))
    /stc-fn tuple-name opt-proj-pattern case-list)
    
    err.\-qq[
      Called staccato-visit with an expr that wasn't a Staccato
      expression]))

(defn fix func
  (fn arg
    (c func (c-new fix func) arg)))

(defn make-fix-visitor body
  (make-visitor/fix/fn loop
    (c body make-visitor.loop)))

(defn id-visitor recur
  (make-fix-visitor/fn self method /case method
    
    method-visitor-visit part shadow scope-policy
    (visitor-visit-result (c recur part shadow scope-policy) self)
    
    method-visitor-redecorate extra-vars whole whole
    
    err.\-qq[Expected method to be a visitor method]))

(def-type desugared-save-expr expr)
(def-type desugared-save-save
  desugared-save-root call-tuple-name
  call-func tuple-name opt-proj-pattern
  call-arg var arg
  tuple-body-expr)

(defn staccato-desugar-save expr
  (case expr
    
    stc-save-root save-root get-expr
    (fix
      (fn loop expr
        (caselet desugared (c-new staccato-desugar-save expr)
          
          desugared-save-expr expr desugared
          
          desugared-save-save
          desugared-save-root call-tuple-name call-func tuple-name
          opt-proj-pattern call-arg var arg tuple-body-expr
          (cast (string-compare save-root desugared-save-root) nil
            desugared
          /c loop /stc-save-root save-root
          /stc-tuple call-tuple-name
          /stc-proj-cons call-func
            (stc-fn tuple-name opt-proj-pattern
              (stc-let-case var
              /stc-any tuple-body-expr))
          /stc-proj-cons call-arg arg
          /stc-proj-nil)
          
          err.\-qq[Internal error]))
      get-expr)
    
    stc-save
    save-root call-tuple-name
    call-func tuple-name opt-proj-pattern
    call-arg var arg
    (desugared-save-save
      save-root call-tuple-name
      call-func tuple-name opt-proj-pattern
      call-arg var arg
    /stc-local var)
    
    (staccato-visit expr /make-fix-visitor/fn self method /case method
      
      method-visitor-visit part shadow scope-policy
      (case (c-new staccato-desugar-save part)
        
        desugared-save-expr expr
        (visitor-visit-result expr self)
        
        desugared-save-save
        desugared-save-root call-tuple-name call-func tuple-name
        opt-proj-pattern call-arg var arg tuple-body-expr
        (visitor-visit-result tuple-body-expr
        /make-fix-visitor/fn self method /case method
          
          method-visitor-visit part shadow scope-policy
          (visitor-visit-result part self)
          
          method-visitor-redecorate extra-vars whole
          (desugared-save-save
            desugared-save-root call-tuple-name call-func tuple-name
            opt-proj-pattern call-arg var arg whole)
          
          err.\-qq[Expected method to be a visitor method])
        
        err.\-qq[Internal error])
      
      method-visitor-redecorate extra-vars whole
      desugared-save-expr.whole
      
      err.\-qq[Expected method to be a visitor method])))

(defn get-free-vars expr
  (staccato-visit expr /make-visitor/fix
    (fn visitor-loop result method /case method
      
      method-visitor-visit part shadow scope-policy
      (let shadowed
        (free-vars-minus (c-new get-free-vars part) shadow)
      /let shadowed
        (case
          (and (isa scope-policy-no-free-vars scope-policy)
          /free-vars-any shadowed /fn entry
            (not/isa free-var-entry-scope-error entry))
          yep -
          \ TODO: Use this error message: Encountered a use of
          \ (def ...) with free variables
          (free-vars-just/free-var-entry-scope-error)
          shadowed)
      /let shadowed
        (case
          (free-vars-any shadowed /fn entry
            (case entry free-var-entry-saved-input-var save-root name
              (free-vars-has shadow free-var-entry-var.name)
              (nope/nil)))
          yep -
          \ TODO: Use this error message: Encountered a use of
          \ (save ...) where the saved value's variable name was
          \ locally bound somewhere between the save root and the
          \ saved location
          (free-vars-plus-entry shadowed /free-var-entry-scope-error)
          shadowed)
      /let use-shadowed
        (fn shadowed
          (visitor-visit-result part /make-visitor/c visitor-loop
          /free-vars-plus result shadowed))
      /let sanitize-and-finish
        (fn -
          (case
            (free-vars-any shadowed /fn entry
              (or (isa free-var-entry-saved-input-var entry)
                (isa free-var-entry-saved-free-var entry)))
            yep -
            \ TODO: Write an error message for this.
            err.\-qq[]
          /c use-shadowed shadowed))
      /case scope-policy
        
        scope-policy-save-root save-root
        (let shadowed
          (case
            (free-vars-any shadowed /fn entry
              (cast entry
                free-var-entry-saved-input-var save-root-2 name
                (nope/nil)
              /and (isa nil /string-compare save-root save-root-2)
                (free-vars-has shadowed free-var-entry-var.name)))
            
            \ TODO: Use this error message: Encountered a use of
            \ (save ...) where the saved value's variable name was
            \ used somewhere under the save root
            (free-vars-plus-entry shadowed
            /free-var-entry-scope-error)
            shadowed)
        /let shadowed
          (free-vars-keep shadowed /fn entry
            (cast entry
              free-var-entry-saved-input-var save-root-2 name
              (yep/nil)
            /not/isa nil /string-compare save-root save-root-2))
        /let shadowed
          (free-vars-map shadowed /fn entry
            (cast entry free-var-entry-saved-free-var save-root-2 name
              entry
            /cast (string-compare save-root save-root-2) nil
              entry
              free-var-entry-var.name))
        /c use-shadowed shadowed)
        
        scope-policy-not-root (c use-shadowed shadowed)
        scope-policy-does-not-matter (c sanitize-and-finish /nil)
        scope-policy-no-free-vars (c sanitize-and-finish /nil)
        
        err.\-qq[Internal error])
      
      method-visitor-redecorate extra-vars whole
      (free-vars-plus result extra-vars)
      
      err.\-qq[Expected method to be a visitor method])
    (free-vars/nil)))

(defn staccato-desugar-omitted expr
  (case expr
    
    stc-def tuple-name opt-proj-pattern case-list
    (let inner-free-vars get-free-vars.case-list
    /stc-def tuple-name
      (opt-proj-pattern-or opt-proj-pattern inner-free-vars)
      (c-new staccato-desugar-omitted case-list))
    
    stc-save-root - -2
    err.\-qq[Called staccato-desugar-omitted on a stc-save-root]
    
    stc-save - -2 -3 -4 -5 -6 -7 -8
    err.\-qq[Called staccato-desugar-omitted on a stc-save]
    
    stc-fn tuple-name opt-proj-pattern case-list
    (let inner-free-vars get-free-vars.case-list
    /stc-fn tuple-name
      (opt-proj-pattern-or opt-proj-pattern inner-free-vars)
      (c-new staccato-desugar-omitted case-list))
    
    (staccato-visit expr /id-visitor/fn part shadow scope-policy
      (c-new staccato-desugar-omitted part))))

(defn staccato-desugar-fn expr
  (case expr
    
    stc-save-root - -2
    err.\-qq[Called staccato-desugar-fn on a stc-save-root]
    
    stc-save - -2 -3 -4 -5 -6 -7 -8
    err.\-qq[Called staccato-desugar-fn on a stc-save]
    
    stc-fn tuple-name opt-proj-pattern case-list
    (stc-let-def
      (stc-def tuple-name opt-proj-pattern
        (c-new staccato-desugar-fn case-list))
    /stc-tuple tuple-name opt-proj-pattern-capture.opt-proj-pattern)
    
    (staccato-visit expr /id-visitor/fn part shadow scope-policy
      (c-new staccato-desugar-fn part))))

(def-type desugar-def-result defs expr)

(defn staccato-desugar-def-including-self expr
  (cast expr stc-def tuple-name opt-proj-pattern case-list
    err.\-qq[
      Called staccato-desugar-def-including-self on an expr that
      wasn't a stc-def]
  /cast (c-new staccato-desugar-def case-list)
    desugar-def-result defs expr
    err.\-qq[Internal error]
  /append defs /cons (stc-def tuple-name opt-proj-pattern expr) /nil))

(defn staccato-desugar-def expr
  (case expr
    
    stc-let-def def get-expr
    (let desugared-def staccato-desugar-def-including-self.def
    /cast (c-new staccato-desugar-def get-expr)
      desugar-def-result defs expr
      err.\-qq[Internal error]
    /desugar-def-result (append desugared-def defs) expr)
    
    stc-save-root - -2
    err.\-qq[Called staccato-desugar-def on a stc-save-root]
    
    stc-save - -2 -3 -4 -5 -6 -7 -8
    err.\-qq[Called staccato-desugar-def on a stc-save]
    
    stc-fn - -2 -3
    err.\-qq[Called staccato-desugar-def on a stc-fn]
    
    (staccato-visit expr
    /make-visitor/fix
      (fn visitor-loop defs method /case method
        
        method-visitor-visit part shadow scope-policy
        (cast (c-new staccato-desugar-def part)
          desugar-def-result more-defs expr
          err.\-qq[Internal error]
        /visitor-visit-result expr
        /make-visitor/c visitor-loop /append defs more-defs)
        
        method-visitor-redecorate extra-vars whole
        (desugar-def-result defs whole)
        
        err.\-qq[Expected method to be a visitor method])
      (nil))))
