\ era-staccato-lib.stc
\ Copyright 2015 Ross Angle. Released under the MIT License.


\ Although this may look like source code, and it may even become full
\ source code at some point, right now it mostly serves as a
\ collection of notes.
\
\ One side of the notes explores a potential high-level design for
\ Staccato macro definitions and ad hoc namespace manipulation. This
\ is far more expressive than Staccato is likely to support for some
\ time, but it means that I can begin writing Staccato code freely,
\ safe in the knowledge that I won't be tied down to regretful name
\ choices or ever-growing lists of syntactic primitives.
\
\ The other side of these notes begins the more immediate exercise of
\ porting the era-stacato.js desugarer to Staccato. This could
\ hypothetically be used to implement `(defn ...)` and
\ `(def-type ...)` as macros someday, but what it ensures is that the
\ design of the desugarer itself is something programmers can replace
\ when needed. Furthermore, the port should ultimately support a
\ slightly different syntax than before: In a raw Staccato AST,
\ constructors and their projections will no longer be designated by
\ unqualified strings, but by fully qualified names.


\ ===== Notes about dependencies =====================================

\ (def-type string val)
\ A reference to a string. The value inside is in a format user-level
\ code does not know how to deconstruct.

\ (defn string-compare a b ...)
\ Compares two strings.

\ macro (str \-qq[example string])
\ Obtains a first-class string value with the given literal text.

\ (def-type name val)
\ A reference to a fully qualified name. The value inside is in a
\ format user-level code does not know how to deconstruct.

\ (defn name-metacompare a b ...)
\ Compares two names. For inequal names, the result will be in a
\ format user-level code does not know how to deconstruct. For equal
\ names, the result will be (nil).
\
\ Names are somewhat useful for access control, and they're opaque
\ external tokens to an extent, but they're not entirely opaque. They
\ can be compared for equality.
\
\ Macros would be less expressive if they had to treat names as
\ uncomparable values, and what benefit would that bring? The macros
\ would still have a range of expression close to that anyway: A macro
\ could still dive into one of its syntax parameters and extract names
\ from there into its own bag of tricks, so names wouldn't really be
\ secrets between macros. A macro could still reconstruct a syntax
\ parameter while inserting two occurrences of any name it likes, just
\ to ensure that the two occurrences are equal. A macro could still do
\ a hackish equality assertion by defining something by one name and
\ looking up the definition by another. A macro could still do a
\ hackish *inequality* assertion by installing two definitions under
\ the (supposedly) two names.
\
\ If macros couldn't check names for equality, one thing a macro
\ couldn't do... is to associate a variable binding site with a
\ variable usage site. For instance, it couldn't act as a Staccato
\ desugarer. It couldn't act as a compiler of some other DSL, unless
\ that DSL completely forewent the namespace system and just used
\ string names everywhere. So people who have adventurous new syntaxes
\ to try would want to build new namespace systems for them, and this
\ macro system would have complicated the Staccato language for no
\ purpose that couldn't have been accomplished with an exhaustive
\ suite of built-in syntaxes.
\
\ (TODO: Do nominal types already support an equality check?
\ James Cheney's "Simple Nominal Type Theory" presents systems with
\ and without equality checks. If this is very common, maybe we can
\ rationalize this decision in terms of standard practice too.)
\
\ So, macros will be able to compare names for equality. As long as
\ they can do that, we could promote better efficiency by permitting
\ ordered comparisons instead of just equality checks. That way, names
\ could be lookup keys in AVL trees and other efficiently indexed data
\ structures.
\
\ It's tricky, because names have no natural ordering. Even if they
\ were arbitrarily associated with strings and ordered that way, that
\ ordering would not be stable in the face of capture-avoiding
\ alpha-renaming! So whatever order we use, it will expose
\ implementation details and make namespace sandboxing into a
\ headache... unless, that is, the implementation details were hidden
\ in a familiar way: By using obscure naming (and enforcing this
\ obscurity with code-signing if necessary).
\
\ To wit, we can refrain from exposing implementation details by
\ defining "metacompare" operations that usually work like "compare"
\ operations, but sometimes return values that user-defined macro code
\ doesn't know how to deconstruct. (The "meta" stands for
\ "metacircular", under the idea that there may be a few layers of the
\ reflective tower all running as macros in the same macroexpansion
\ phase. Each layer must be implemented with obscure names that its
\ interpreted layer doesn't know about.) Once we have metacomparison
\ operations, we can provide encapsulated data types that sort their
\ data using a metacomparison.
\
\ If we just support encapsulated AVL trees, that might go a long way,
\ especially if it serves as a complete model of computation over
\ unordered collections. We can get quite a range of computational
\ ability all at once if we simply add a metacomparator over the
\ AVL trees themselves. For instance, that lets us detect emptiness
\ by comparing to the empty tree, and it lets us detect singletonhood
\ by looping over the entries and comparing to the singletons of each.
\
\ In the process, a lot of ugliness may arise: If concatenation of
\ encapsulated AVL trees doesn't somehow check that their
\ metacomparators are equivalent, we may end up with malformed
\ encapsulated AVL trees that leak implementation details. We could
\ potentially avoid this situation by passing some sort of equality
\ certifier to the concatenation operation, but then we'd need a
\ specialized language (or at least a collection of combinators) for
\ defining equality certifiers. An easier approach would be to use a
\ specialized language (or combinators) for the metacomparators
\ themselves. This language would quickly resemble a static type
\ system, much like our "cmpd" utilities already resemble algebraic
\ data type definitions. So, this probably isn't worth solving until
\ we take a typed approach.
\
\ For now, we can start small, merely providing a single
\ metacomparator over names (`name-metacompare`), rather than aiming
\ for efficiency and general computation. As long as we have that, we
\ can use inefficient association lists to track free variables
\ (`free-vars-object`).

\ (def-type istring-nil string)
\ An interpolated string s-expression that consists of a string with
\ no interpolations.

\ (TODO: Use this.)
\ (def-type istring-cons string-past interpolated istring-rest)
\ An interpolated string s-expression that consists of a string, a
\ single interpolated value to go after that string, and a remaining
\ interpolated string s-expression to go after that.

\ (def-type foreign val)
\ An s-expression that consists of an embedded value of any type, but
\ usually a name. The program may not know of a way to encode the name
\ as serializable data, but it can still be passed to `(compile ...)`.

\ macro (new type)
\ Creates a value of the given type. The type must have no
\ projections. (TODO: Stop depending on this one. It's just here for
\ the example of how to write `c-new` as a user-level macro.)

\ (def-type stx stx-details s-expr)
\ An s-expression tagged with source location information.

\ (defn macro-stx-details mode unique-ns definition-ns stx)
\ Constructs a syntax details object that refers to a macro's input,
\ so that the macro's output can be associated with it. The `stx` must
\ be a located cons list whose first element is a string or foreign
\ name referring to a macro.

\ (defn ns-get-name name ns)
\ Obtains a sub-namespace determined by the given namespace, using the
\ given name as a "folder name." Usually, distinct "folder names" will
\ yield distinct sub-namespaces, but sometimes the interpreter may be
\ configured so that this isn't the case.

\ (defn ns-get-string string ns)
\ Obtains a sub-namespace determined by the first namespace, using the
\ given string as a "folder name." Usually, distinct "folder names"
\ will yield distinct sub-namespaces, but sometimes the interpreter
\ may be configured so that this isn't the case.

\ (defn procure-name mode ns)
\ Uses the given namespace to obtain a first-class name value. The
\ given modality must be the current one.

\ (defn procure-defined mode ns)
\ Blocks until the given namespace has a defined Staccato value and
\ then returns it. The given modality must be the current one.

\ (TODO: Use this.)
\ (defn procure-put-defined mode ns value then)
\ then (fn mode ...)
\ Constructs a monad that, if invoked, installs a definition so that
\ the given namespace has a defined Staccato value, namely the given
\ one. The monad's result value is `(nil)`. In a later tick, once the
\ definition has been installed, the callback is invoked, and its own
\ monadic side effects occur. If the definition cannot be installed,
\ the program is in error, and the callback may or may not be invoked;
\ other computations that depend on the defined value may or may not
\ be canceled or retroactively voided.

\ (TODO: Use this.)
\ (defn no-effects val)
\ Constructs a monad that, if invoked, does nothing. The monad's
\ result value is the given value.

\ (TODO: Use this.)
\ (defn bind-effects monad then)
\ then (fn result ...)
\ Constructs a monad that, if invoked, calls the callback with the
\ given monad's result value, obtains a monad as the result of that
\ function, and performs the effects of both monads. The monad's
\ result value is the result value of the monad returned by the
\ callback.

\ (TODO: Use this.)
\ (ns-shadow-name name ns ns)
\ Creates a new namespace that behaves like the second namespace in
\ almost every way, except when the given name is requested as a
\ "folder name", in which case the first namespace is returned
\ instead.

\ (TODO: Use this.)
\ (ns-shadow-string string ns ns)
\ Creates a new namespace that behaves like the second namespace in
\ almost every way, except when the given string is requested as a
\ "folder name", in which case the first namespace is returned
\ instead.

\ The `ns-shadow-name` and `ns-shadow-string` functions can be used to
\ establish local macros. A namespace created this way even works the
\ same way as the old one when it's used in a `procure-...` primitive.
\ This way, we can imagine that the namespace's own identity is stored
\ under an entry somewhere in the namespace, just using a key that we
\ don't have the ability to construct.



\ ===== Reimplementation of the desugarer ============================


(def-type stc-def tuple-name opt-proj-pattern case-list)
(def-type stc-let-case var case-list)
(def-type stc-match tuple-name proj-pattern get-expr case-list)
(def-type stc-any get-expr)
(def-type stc-let-bindings-nil)
(def-type stc-let-bindings-cons var get-expr let-bindings-expr)
(def-type stc-proj-nil)
(def-type stc-proj-cons proj-name get-expr proj-expr)
(def-type stc-let-def def get-expr)
(def-type stc-let let-bindings-expr get-expr)
(def-type stc-local var)
(def-type stc-tuple tuple-name proj-expr)
(def-type stc-save-root save-root get-expr)
(def-type stc-save
  save-root call-tuple-name
  call-func tuple-name opt-proj-pattern
  call-arg var arg)
(def-type stc-fn tuple-name opt-proj-pattern case-list)
\ TODO: Make a note that this is a namespace from which the projection
\ names can be derived via "<ns>/<projection name>/name".
(def-type stc-proj-pattern-omitted namespace)
(def-type stc-proj-pattern proj-pattern)
(def-type stc-proj-pattern-nil)
(def-type stc-proj-pattern-cons proj-name var proj-pattern)


(def-type scope-policy-save-root save-root)
(def-type scope-policy-not-root)
(def-type scope-policy-does-not-matter)
(def-type scope-policy-no-free-vars)

(def-type visitor-object impl)
(def-type method-visitor-visit part shadow scope-policy)
(def-type method-visitor-redecorate extra-vars whole)
(def-type visitor-visit-result result visitor)

(defn make-visitor impl
  visitor-object.impl)

(defn visitor-visit visitor part shadow scope-policy
  (cast visitor visitor-object impl
    err.\-qq[Expected a visitor of type visitor-object]
  /c impl /method-visitor-visit part shadow scope-policy))

(defn visitor-redecorate visitor extra-vars whole
  (cast visitor visitor-object impl
    err.\-qq[Expected a visitor of type visitor-object]
  /c impl /method-visitor-redecorate extra-vars whole))

(defn stringy-name-metacompare a b
  (bimap (cmpd-compare) a b /fn it
    (case it string -
      (cmpd-cons (string-compare) it /cmpd-nil)
    /cmpd-succ/case it name -
      (cmpd-cons (name-metacompare) it /cmpd-nil)
      err.\-qq[Expected a value of type string or name])))

(def-type free-var-entry-var name)
(def-type free-var-entry-saved-input-var save-root name)
(def-type free-var-entry-saved-free-var save-root name)
(def-type free-var-entry-scope-error)

(defn free-vars-entry-metacompare a b
  (bimap (cmpd-compare) a b /fn it
    (case it free-var-entry-var name
      (cmpd-cons (stringy-name-metacompare) name /cmpd-nil)
    /cmpd-succ/case it free-var-entry-saved-input-var save-root name
      (cmpd-cons (stringy-name-metacompare) save-root
      /cmpd-cons (stringy-name-metacompare) name
      /cmpd-nil)
    /cmpd-succ/case it free-var-entry-saved-free-var save-root name
      (cmpd-cons (stringy-name-metacompare) save-root
      /cmpd-cons (stringy-name-metacompare) name
      /cmpd-nil)
    /cmpd-succ/case it free-var-entry-scope-error
      (cmpd-nil)
      err.\-qq[Expected a free variable entry])))

(def-type free-vars-object list)

(defn free-vars-any free-vars check
  (cast free-vars free-vars-object list
    err.\-qq[
      Called free-vars-any with a free-vars that wasn't a
      free-vars-object]
  /any list check))

(defn free-vars-fold state free-vars combiner
  (cast free-vars free-vars-object list
    err.\-qq[
      Called free-vars-fold with a free-vars that wasn't a
      free-vars-object]
  /foldl state list combiner))

(defn free-vars-has free-vars entry
  (free-vars-any free-vars /fn entry2
    (isa nil /free-vars-entry-metacompare entry entry2)))

(defn free-vars-keep free-vars check
  (cast free-vars free-vars-object list
    err.\-qq[
      Called free-vars-keep with a free-vars that wasn't a
      free-vars-object]
  /free-vars-object /keep list check))

(defn free-vars-minus a b
  (free-vars-keep a /fn entry /not/free-vars-has b entry))

(defn free-vars-plus-entry free-vars entry
  (cast free-vars free-vars-object list
    err.\-qq[
      Called free-vars-plus-entry with a free-vars that wasn't a
      free-vars-object]
  /case (free-vars-has free-vars entry)
    yep - free-vars
    (free-vars-object /cons entry list)))

(defn free-vars -
  (free-vars-object/nil))

(defn free-vars-just entry
  (free-vars-plus-entry (free-vars/nil) entry))

(defn free-vars-map free-vars func
  (free-vars-fold (free-vars/nil) free-vars /fn state entry
    (free-vars-plus-entry state /c func entry)))

(defn free-vars-plus a b
  (free-vars-fold a b /fn state entry
    (free-vars-plus-entry state entry)))


(defn staccato-let-bindings-expr-keys let-bindings-expr
  (case let-bindings-expr
    
    let-bindings-nil
    (free-vars/nil)
    
    let-bindings-cons var get-expr let-bindings-expr
    (free-vars-plus-entry
      (c-new staccato-let-bindings-expr-keys let-bindings-expr)
      free-var-entry-var.var)
    
    err.\-qq[
      Called staccato-let-bindings-expr-keys on a value that wasn't a
      let-bindings-expr syntax]))

(defn staccato-proj-pattern-get-vars proj-pattern
  (case proj-pattern
    
    stc-proj-pattern-nil
    (free-vars/nil)
    
    stc-proj-pattern-cons proj-name var proj-pattern
    (free-vars-plus-entry
      (c-new staccato-proj-pattern-get-vars proj-pattern)
      free-var-entry-var.var)
    
    err.\-qq[
      Called staccato-proj-pattern-get-vars on a value that wasn't a
      proj-pattern syntax]))

(defn staccato-opt-proj-pattern-get-vars opt-proj-pattern
  (case opt-proj-pattern
    
    stc-proj-pattern-omitted namespace
    (nil)
    
    stc-proj-pattern proj-pattern
    (yep staccato-proj-pattern-get-vars.proj-pattern)
    
    err.\-qq[
      Called staccato-opt-proj-pattern-get-vars on a value that wasn't
      an opt-proj-pattern syntax]))

(defn opt-proj-pattern-or opt-proj-pattern default
  (case opt-proj-pattern
    
    stc-proj-pattern-omitted namespace
    (stc-proj-pattern
    /free-vars-fold (proj-pattern-nil) default /fn state var truth
      (cast var free-var-entry-var name
        err.\-qq[
          Called opt-proj-pattern-or with a default variable list that
          contained a key that wasn't a free-var-entry-var]
      \ TODO: Use args.namespace to derive the projection name, rather
      \ than just using the variable name directly.
      /stc-proj-pattern-cons name name state))
    
    stc-proj-pattern proj-pattern
    opt-proj-pattern
    
    err.\-qq[
      Called opt-proj-pattern-or on a value that wasn't an
      opt-proj-pattern syntax]))

(defn proj-pattern-capture proj-pattern
  (case proj-pattern
    
    stc-proj-pattern-nil
    (stc-proj-nil)
    
    stc-proj-pattern-cons proj-name var proj-pattern
    (stc-proj-cons proj-name (stc-local var)
    /c-new proj-pattern-capture proj-pattern)
    
    err.\-qq[
      Called proj-pattern-capture on a value that wasn't a
      proj-pattern syntax]))

(defn opt-proj-pattern-capture opt-proj-pattern
  (case opt-proj-pattern
    
    stc-proj-pattern-omitted namespace
    err.\-qq[
      Called opt-proj-pattern-capture on a stc-proj-pattern-omitted]
    
    stc-proj-pattern proj-pattern
    proj-pattern-capture.proj-pattern
    
    err.\-qq[
      Called opt-proj-pattern-capture on a value that wasn't an
      opt-proj-pattern syntax]))


(defn staccato-visit expr visitor
  (case expr
    
    stc-def tuple-name opt-proj-pattern case-list
    (cast
      (visitor-visit visitor case-list
        (case staccato-opt-proj-pattern-get-vars.opt-proj-pattern
          yep vars vars
          (free-vars/nil))
      /scope-policy-no-free-vars)
      visitor-visit-result case-list visitor
      err.\-qq[Internal error]
    /visitor-redecorate visitor (free-vars/nil)
    /stc-def tuple-name opt-proj-pattern case-list)
    
    stc-let-case var case-list
    (cast var string -
      err.\-qq[Visited a stc-let-case where the var was not a string]
    /cast
      (visitor-visit visitor case-list
        (free-vars-just free-var-entry-var.var)
      /scope-policy-does-not-matter)
      visitor-visit-result case-list visitor
      err.\-qq[Internal error]
    /visitor-redecorate visitor (free-vars/nil)
    /stc-let-case var case-list)
    
    stc-match tuple-name proj-pattern get-expr case-list
    (cast
      (visitor-visit visitor get-expr
        staccato-proj-pattern-get-vars.proj-pattern
      /scope-policy-not-root)
      visitor-visit-result get-expr visitor
      err.\-qq[Internal error]
    /cast
      (visitor-visit visitor case-list (free-vars/nil)
      /scope-policy-not-root)
      visitor-visit-result case-list visitor
      err.\-qq[Internal error]
    /visitor-redecorate visitor (free-vars/nil)
    /stc-match tuple-name proj-pattern get-expr case-list)
    
    stc-any get-expr
    (cast
      (visitor-visit visitor get-expr (free-vars/nil)
      /scope-policy-not-root)
      visitor-visit-result get-expr visitor
      err.\-qq[Internal error]
    /visitor-redecorate visitor (free-vars/nil)
    /stc-any get-expr)
    
    stc-let-bindings-nil
    (visitor-redecorate visitor (free-vars/nil)
    /stc-let-bindings-nil)
    
    stc-let-bindings-cons var get-expr proj-expr
    (cast
      (visitor-visit visitor get-expr (free-vars/nil)
      /scope-policy-not-root)
      visitor-visit-result get-expr visitor
      err.\-qq[Internal error]
    /cast
      (visitor-visit visitor proj-expr (free-vars/nil)
      /scope-policy-not-root)
      visitor-visit-result proj-expr visitor
      err.\-qq[Internal error]
    /visitor-redecorate visitor (free-vars/nil)
    /stc-let-bindings-cons var get-expr proj-expr)
    
    stc-proj-nil
    (visitor-redecorate visitor (free-vars/nil)
    /stc-proj-nil)
    
    stc-proj-cons proj-name get-expr proj-expr
    (cast
      (visitor-visit visitor get-expr (free-vars/nil)
      /scope-policy-not-root)
      visitor-visit-result get-expr visitor
      err.\-qq[Internal error]
    /cast
      (visitor-visit visitor proj-expr (free-vars/nil)
      /scope-policy-not-root)
      visitor-visit-result proj-expr visitor
      err.\-qq[Internal error]
    /visitor-redecorate visitor (free-vars/nil)
    /stc-proj-cons proj-name get-expr proj-expr)
    
    stc-let-def def get-expr
    (cast
      (visitor-visit visitor def (free-vars/nil)
      /scope-policy-does-not-matter)
      visitor-visit-result def visitor
      err.\-qq[Internal error]
    /cast
      (visitor-visit visitor get-expr (free-vars/nil)
      /scope-policy-not-root)
      visitor-visit-result get-expr visitor
      err.\-qq[Internal error]
    /visitor-redecorate visitor (free-vars/nil)
    /stc-let-def def get-expr)
    
    stc-let let-bindings-expr get-expr
    (cast
      (visitor-visit visitor let-bindings-expr (free-vars/nil)
      /scope-policy-not-root)
      visitor-visit-result let-bindings-expr visitor
      err.\-qq[Internal error]
    /cast
      (visitor-visit visitor get-expr
        staccato-let-bindings-expr-keys.let-bindings-expr
      /scope-policy-not-root)
      visitor-visit-result get-expr visitor
      err.\-qq[Internal error]
    /visitor-redecorate visitor (free-vars/nil)
    /stc-let let-bindings-expr get-expr)
    
    stc-local var
    (cast var string -
      err.\-qq[Visited a stc-local where the var was not a string]
    /visitor-redecorate visitor
      (free-vars-just free-var-entry-var.var)
    /stc-local var)
    
    stc-tuple tuple-name proj-expr
    (cast
      (visitor-visit visitor proj-expr (free-vars/nil)
      /scope-policy-not-root)
      visitor-visit-result proj-expr visitor
      err.\-qq[Internal error]
    /visitor-redecorate visitor (free-vars/nil)
    /stc-tuple tuple-name proj-expr)
    
    stc-save-root save-root get-expr
    (cast save-root string -
      err.\-qq[
        Visited a stc-local where the save-root was not a string]
    /cast
      (visitor-visit visitor get-expr (free-vars/nil)
      /scope-policy-save-root save-root)
      visitor-visit-result get-expr visitor
      err.\-qq[Internal error]
    /visitor-redecorate visitor (free-vars/nil)
    /stc-save-root save-root get-expr)
    
    stc-save
    save-root call-tuple-name
    call-func tuple-name opt-proj-pattern
    call-arg var arg
    (cast save-root string -
      err.\-qq[
        Visited a stc-save where the save-root was not a string]
    /cast
      (visitor-visit visitor arg (free-vars/nil)
      /scope-policy-save-root save-root)
      visitor-visit-result arg visitor
      err.\-qq[Internal error]
    /visitor-redecorate visitor
      (free-vars-plus-entry
        (case staccato-opt-proj-pattern-get-vars.opt-proj-pattern
          
          yep vars
          (free-vars-map vars /fn entry
            (cast entry free-var-entry-var name
              err.\-qq[Internal error]
            /free-var-entry-saved-free-var save-root name))
          
          (free-vars/nil))
      /free-var-entry-saved-input-var save-root var)
    /stc-save
      save-root call-tuple-name
      call-func tuple-name opt-proj-pattern
      call-arg var arg)
    
    stc-fn tuple-name opt-proj-pattern case-list
    (cast
      (visitor-visit visitor case-list (free-vars/nil)
      /scope-policy-not-root)
      visitor-visit-result case-list visitor
      err.\-qq[Internal error]
    /visitor-redecorate visitor
      (case staccato-opt-proj-pattern-get-vars.opt-proj-pattern
        yep vars vars
        (free-vars/nil))
    /stc-fn tuple-name opt-proj-pattern case-list)
    
    err.\-qq[
      Called staccato-visit with an expr that wasn't a Staccato
      expression]))

(defn fix func
  (fn arg
    (c func (c-new fix func) arg)))

(defn make-fix-visitor body
  (make-visitor/fix/fn loop
    (c body make-visitor.loop)))

(defn id-visitor recur
  (make-fix-visitor/fn self method /case method
    
    method-visitor-visit part shadow scope-policy
    (visitor-visit-result (c recur part shadow scope-policy) self)
    
    method-visitor-redecorate extra-vars whole whole
    
    err.\-qq[Expected method to be a visitor method]))

(def-type desugared-save-expr expr)
(def-type desugared-save-save
  desugared-save-root call-tuple-name
  call-func tuple-name opt-proj-pattern
  call-arg var arg
  tuple-body-expr)

(defn staccato-desugar-save expr
  (case expr
    
    stc-save-root save-root get-expr
    (fix
      (fn loop expr
        (caselet desugared (c-new staccato-desugar-save expr)
          
          desugared-save-expr expr desugared
          
          desugared-save-save
          desugared-save-root call-tuple-name call-func tuple-name
          opt-proj-pattern call-arg var arg tuple-body-expr
          (cast (string-compare save-root desugared-save-root) nil
            desugared
          /c loop /stc-save-root save-root
          /stc-tuple call-tuple-name
          /stc-proj-cons call-func
            (stc-fn tuple-name opt-proj-pattern
              (stc-let-case var
              /stc-any tuple-body-expr))
          /stc-proj-cons call-arg arg
          /stc-proj-nil)
          
          err.\-qq[Internal error]))
      get-expr)
    
    stc-save
    save-root call-tuple-name
    call-func tuple-name opt-proj-pattern
    call-arg var arg
    (desugared-save-save
      save-root call-tuple-name
      call-func tuple-name opt-proj-pattern
      call-arg var arg
    /stc-local var)
    
    (staccato-visit expr /make-fix-visitor/fn self method /case method
      
      method-visitor-visit part shadow scope-policy
      (case (c-new staccato-desugar-save part)
        
        desugared-save-expr expr
        (visitor-visit-result expr self)
        
        desugared-save-save
        desugared-save-root call-tuple-name call-func tuple-name
        opt-proj-pattern call-arg var arg tuple-body-expr
        (visitor-visit-result tuple-body-expr
        /make-fix-visitor/fn self method /case method
          
          method-visitor-visit part shadow scope-policy
          (visitor-visit-result part self)
          
          method-visitor-redecorate extra-vars whole
          (desugared-save-save
            desugared-save-root call-tuple-name call-func tuple-name
            opt-proj-pattern call-arg var arg whole)
          
          err.\-qq[Expected method to be a visitor method])
        
        err.\-qq[Internal error])
      
      method-visitor-redecorate extra-vars whole
      desugared-save-expr.whole
      
      err.\-qq[Expected method to be a visitor method])))

(defn get-free-vars expr
  (staccato-visit expr /make-visitor/fix
    (fn visitor-loop result method /case method
      
      method-visitor-visit part shadow scope-policy
      (let shadowed
        (free-vars-minus (c-new get-free-vars part) shadow)
      /let shadowed
        (case
          (and (isa scope-policy-no-free-vars scope-policy)
          /free-vars-any shadowed /fn entry
            (not/isa free-var-entry-scope-error entry))
          yep -
          \ TODO: Use this error message: Encountered a use of
          \ (def ...) with free variables
          (free-vars-just/free-var-entry-scope-error)
          shadowed)
      /let shadowed
        (case
          (free-vars-any shadowed /fn entry
            (case entry free-var-entry-saved-input-var save-root name
              (free-vars-has shadow free-var-entry-var.name)
              (nope/nil)))
          yep -
          \ TODO: Use this error message: Encountered a use of
          \ (save ...) where the saved value's variable name was
          \ locally bound somewhere between the save root and the
          \ saved location
          (free-vars-plus-entry shadowed /free-var-entry-scope-error)
          shadowed)
      /let use-shadowed
        (fn shadowed
          (visitor-visit-result part /make-visitor/c visitor-loop
          /free-vars-plus result shadowed))
      /let sanitize-and-finish
        (fn -
          (case
            (free-vars-any shadowed /fn entry
              (or (isa free-var-entry-saved-input-var entry)
                (isa free-var-entry-saved-free-var entry)))
            yep -
            \ TODO: Write an error message for this.
            err.\-qq[]
          /c use-shadowed shadowed))
      /case scope-policy
        
        scope-policy-save-root save-root
        (let shadowed
          (case
            (free-vars-any shadowed /fn entry
              (cast entry
                free-var-entry-saved-input-var save-root-2 name
                (nope/nil)
              /and (isa nil /string-compare save-root save-root-2)
                (free-vars-has shadowed free-var-entry-var.name)))
            
            \ TODO: Use this error message: Encountered a use of
            \ (save ...) where the saved value's variable name was
            \ used somewhere under the save root
            (free-vars-plus-entry shadowed
            /free-var-entry-scope-error)
            shadowed)
        /let shadowed
          (free-vars-keep shadowed /fn entry
            (cast entry
              free-var-entry-saved-input-var save-root-2 name
              (yep/nil)
            /not/isa nil /string-compare save-root save-root-2))
        /let shadowed
          (free-vars-map shadowed /fn entry
            (cast entry free-var-entry-saved-free-var save-root-2 name
              entry
            /cast (string-compare save-root save-root-2) nil
              entry
              free-var-entry-var.name))
        /c use-shadowed shadowed)
        
        scope-policy-not-root (c use-shadowed shadowed)
        scope-policy-does-not-matter (c sanitize-and-finish /nil)
        scope-policy-no-free-vars (c sanitize-and-finish /nil)
        
        err.\-qq[Internal error])
      
      method-visitor-redecorate extra-vars whole
      (free-vars-plus result extra-vars)
      
      err.\-qq[Expected method to be a visitor method])
    (free-vars/nil)))

(defn staccato-desugar-omitted expr
  (case expr
    
    stc-def tuple-name opt-proj-pattern case-list
    (let inner-free-vars get-free-vars.case-list
    /stc-def tuple-name
      (opt-proj-pattern-or opt-proj-pattern inner-free-vars)
      (c-new staccato-desugar-omitted case-list))
    
    stc-save-root - -2
    err.\-qq[Called staccato-desugar-omitted on a stc-save-root]
    
    stc-save - -2 -3 -4 -5 -6 -7 -8
    err.\-qq[Called staccato-desugar-omitted on a stc-save]
    
    stc-fn tuple-name opt-proj-pattern case-list
    (let inner-free-vars get-free-vars.case-list
    /stc-fn tuple-name
      (opt-proj-pattern-or opt-proj-pattern inner-free-vars)
      (c-new staccato-desugar-omitted case-list))
    
    (staccato-visit expr /id-visitor/fn part shadow scope-policy
      (c-new staccato-desugar-omitted part))))

(defn staccato-desugar-fn expr
  (case expr
    
    stc-save-root - -2
    err.\-qq[Called staccato-desugar-fn on a stc-save-root]
    
    stc-save - -2 -3 -4 -5 -6 -7 -8
    err.\-qq[Called staccato-desugar-fn on a stc-save]
    
    stc-fn tuple-name opt-proj-pattern case-list
    (stc-let-def
      (stc-def tuple-name opt-proj-pattern
        (c-new staccato-desugar-fn case-list))
    /stc-tuple tuple-name opt-proj-pattern-capture.opt-proj-pattern)
    
    (staccato-visit expr /id-visitor/fn part shadow scope-policy
      (c-new staccato-desugar-fn part))))

(def-type desugar-def-result defs expr)

(defn staccato-desugar-def-including-self expr
  (cast expr stc-def tuple-name opt-proj-pattern case-list
    err.\-qq[
      Called staccato-desugar-def-including-self on an expr that
      wasn't a stc-def]
  /cast (c-new staccato-desugar-def case-list)
    desugar-def-result defs expr
    err.\-qq[Internal error]
  /append defs /cons (stc-def tuple-name opt-proj-pattern expr) /nil))

(defn staccato-desugar-def expr
  (case expr
    
    stc-let-def def get-expr
    (let desugared-def staccato-desugar-def-including-self.def
    /cast (c-new staccato-desugar-def get-expr)
      desugar-def-result defs expr
      err.\-qq[Internal error]
    /desugar-def-result (append desugared-def defs) expr)
    
    stc-save-root - -2
    err.\-qq[Called staccato-desugar-def on a stc-save-root]
    
    stc-save - -2 -3 -4 -5 -6 -7 -8
    err.\-qq[Called staccato-desugar-def on a stc-save]
    
    stc-fn - -2 -3
    err.\-qq[Called staccato-desugar-def on a stc-fn]
    
    (staccato-visit expr
    /make-visitor/fix
      (fn visitor-loop defs method /case method
        
        method-visitor-visit part shadow scope-policy
        (cast (c-new staccato-desugar-def part)
          desugar-def-result more-defs expr
          err.\-qq[Internal error]
        /visitor-visit-result expr
        /make-visitor/c visitor-loop /append defs more-defs)
        
        method-visitor-redecorate extra-vars whole
        (desugar-def-result defs whole)
        
        err.\-qq[Expected method to be a visitor method])
      (nil))))



\ ===== A reimplementation of the macro system =======================

(defn s-expr-to-maybe-name s-expr
  (case s-expr
    foreign foreign-val
    (cast foreign-val name -
      err.\-qq[Expected a foreign-val value of type name]
      yep.foreign-val)
    
    istring-nil string
    (cast string string -
      err.\-qq[Expected a string value of type string]
      yep.string)
    
    (nil)))

(defn compile mode unique-ns definition-ns stx
  \ Macroexpands the given `stx`, allowing the macro calls to
  \ monadically install definitions and produce a desugarable Staccato
  \ expression. The given modality must be the current one.
  \
  \ TODO: See if we should actually validate the given modality.
  
  (cast stx stx - s-expr
    err.\-qq[Expected a stx value of type stx]
  /case s-expr-to-maybe-name.s-expr yep name stc-local.name
  /cast s-expr cons first-stx rest-stxs
    err.\-qq[
      Expected an s-expr value of type foreign, istring-nil, or cons])
  /cast first-stx stx - first-expr
    err.\-qq[Expected a first-stx value of type stx]
  /cast s-expr-to-maybe-name.first-expr yep name
    err\-qq[
      Expected a first-expr value of type foreign or istring-nil]
  /let name
    (case name
      name - name
      
      string -
      (procure-name mode
      /ns-get-string str.name
      /ns-get-string name
      /ns-get-string str.macro-names definition-ns)
      
      err.\-qq[Internal error])
  /let macro
    (procure-defined mode
    /ns-get-string str.function
    /ns-get-name name
    /ns-get-string str.macros definition-ns)
  /c macro mode unique-ns definition-ns
    (macro-stx-details mode unique-ns definition-ns stx)
    rest-stxs)



\ ===== Notes and examples for using the macro system ================

\ Yes, we're using deterministic, referentially transparent side
\ effects during macroexpansion. Since a macro will necessarily need
\ to *read* existing definitions in order for its implementation code
\ to do anything at all, we're allowing other blocking reads by way of
\ `procure-defined`. For referential transparency, the corresponding
\ `procure-put-defined` writes are performed in a commutative monad.
\ If two or more conflicting writes are performed, all definitions that
\ depended on reading those writes will be retroactively updated.
\ Usually, conflicting definitions are an error. However, at a REPL,
\ definitions from a newer command may take the place of definitions
\ from an older command without error. Errors or updates may cascade
\ through several layers of other definitions that depended on them.
\
\ Common definitions are stored like so, where slashes represent
\ `ns-get-string` except where marked as `ns-get-name`:
\
\   <definition-ns>/constructor-names/<constructor name string>/name
\     = No defined value, but the proper identity to use for the
\       constructor in everything except manually keyboarded code.
\
\   <definition-ns>/constructors/<ns-get-name: constructor identity>/
\       projection-list
\       = An ordered list of projection name strings. Projections
\         should only be treated as an ordered list in manually
\         keyboarded code and in macros catering to manually
\         keyboarded code.
\   <definition-ns>/constructors/<ns-get-name: constructor identity>/
\     projection-names/<projection name string>/name
\     = No defined value, but the proper identity to use for the
\       projection in everything except manually keyboarded code.
\
\   <definition-ns>/macro-names/<macro name string>/name
\     = No defined value, but the proper identity to use for the macro
\       in everything except manually keyboarded code.
\
\   <definition-ns>/macros/<ns-get-name: macro identity>/function
\     = A value that can be invoked with the arguments of a macro
\       call.
\
\   <definition-ns>/functions/<ns-get-name: constructor identity>/
\     staccato
\     = An s-expression that can be compiled as a raw, sugarless
\       Staccato function definition.
\
\ The usual definition forms generate several definitions all at once:
\
\   (def-type ...)
\     * The constructor name information desired.
\     * A macro so that the construction is easy to do.
\     * The name information for that macro.
\     * Constructor name information for a callable value which
\       implements that macro.
\     * A function implementation for that callable value.
\
\   (defn ...)
\     * The function implementation desired.
\     * Constructor name information for a first-class representation
\       of the function.
\     * A macro so that the function is easy to call. (Fortunately,
\       every (defn ...) macro can reuse the same callable value
\       constructor and function implementation.)
\     * The name information for that macro.
\
\ A macro's `mode` parameter is the current modality. A modality must
\ be passed to certain effectful primitives as a way to give the
\ effects something to be deterministic by. (The terms "mode" and
\ "modality" might be idiosyncrasies of this codebase. A more standard
\ term is "world-passing style.")
\
\ A macro's `unique-ns` parameter is a namespace. It's useful in the
\ way that gensyms are typically useful in other macro-capable
\ languages, but the uniqueness is achieved by playing along: If the
\ macro compiles more than one subexpression, each subexpression
\ should be given a `unique-ns` derived in different ways from this
\ one.
\
\ A macro's `definition-ns` parameter is a namespace. If the macro
\ needs to install any definitions or look up any definitions, this is
\ the namespace for that purpose. It should usually be passed as-is to
\ any compiled subexpressions, except when defining a macro that's
\ local to a certain subexpression.
\
\ A macro's `my-stx-details` parameter is a collection of source
\ location information. There's no direct way to deconstruct this
\ value, but it conveys information about this macro invocation, so
\ the macro can use it to receive attribution for any `stx` values it
\ creates.
\
\ (TODO: Figure out what the format of source location information
\ actually is. For now, this is sort of just an unspecified area, but
\ at least a language implementation can use this to hold filenames
\ and line numbers in practice. An implementation should be able to
\ treat this as a completely empty data structure; it's not needed for
\ any variable scoping purposes.)
\
\ A macro's `args` parameter is a list of `(stx stx-details s-expr)`
\ values. The list is built out of `(cons car cdr)` and `(nil)`
\ values.

(defn macro-name mode definition-ns name
  (case name
    name - name
    
    string -
    (procure-name mode
    /ns-get-string str.name
    /ns-get-string str
    /ns-get-string str.macro-names definition-ns)
    
    err.\-qq[Expected a name value of type name or string]))

(defn constructor-name mode definition-ns name
  (case name
    name - name
    
    string -
    (procure-name mode
    /ns-get-string str.name
    /ns-get-string str
    /ns-get-string str.constructor-names definition-ns)
    
    err.\-qq[Expected a name value of type name or string]))

\ TODO: Update this. We shouldn't really be defining a macro here, but
\ defining a macro implementation function that a metacircular
\ interpreter can be implemented in terms of.
(def-macro c-new mode unique-ns definition-ns my-stx-details args
  (let s (fn it /stx my-stx-details it)
  /let mac
    (fn str rest
      (cons (c s /foreign/macro-name mode definition-ns str) rest))
  /cast args cons func-name args
    err.\-qq[Not enough arguments to c-new]
  /compile mode unique-ns definition-ns
  /c s /c mac str.c
  /cons (c s /c mac str.new /cons func-name /nil)
    args))

(defn core-mac-case mode unique-ns definition-ns my-stx-details args
  (let s (fn it /stx my-stx-details it)
  /let mac
    (fn str rest
      (cons (c s /foreign/macro-name mode definition-ns str) rest))
  /compile mode (ns-get-string str.body unique-ns) definition-ns
  /c s /c mac str.caselet
  /cons (c s /foreign/ns-get-string str.ignored unique-ns)
    args))

(defn core-mac-cast mode unique-ns definition-ns my-stx-details args
  (let s (fn it /stx my-stx-details it)
  /let mac
    (fn str rest
      (cons (c s /foreign/macro-name mode definition-ns str) rest))
  /cast args cons subject args
    err.\-qq[Not enough arguments to cast]
  /cast args cons constructor-name args
    err.\-qq[Not enough arguments to cast]
  /cast constructor-name stx - constructor-name
    err.\-qq[Expected a constructor-name value of type stx]
  /cast s-expr-to-maybe-name.constructor-name yep constructor-name
    err.\-qq[
      Expected a constructor-name value of type foreign or istring-nil
      ]
  /let constructor-name
    (constructor-name mode definition-ns constructor-name)
  /let projection-list
    (procure-defined mode
    /ns-get-string str.projection-names
    /ns-get-name constructor-name
    /ns-get-string str.constructors definition-ns)
  /cast (maybe-cut projection-list args) yep cut-result
    err.\-qq[Not enough arguments to cast to the given constructor]
  /cast cut-result cut-result vars args
    err.\-qq[Internal error]
  /cast args cons else args
    err.\-qq[Not enough arguments to cast to the given constructor]
  /cast args cons then args
    err.\-qq[Not enough arguments to cast to the given constructor]
  /cast args nil
    err.\-qq[Too many arguments to cast to the given constructor]
  /compile mode unique-ns definition-ns
  /c s /c mac str.case /cons subject
  /cons (c s /foreign constructor-name) /append vars
  /cons then
  /cons else /nil))

(defn core-mac-isa mode unique-ns definition-ns my-stx-details args
  (let s (fn it /stx my-stx-details it)
  /let mac
    (fn str rest
      (cons (c s /foreign/macro-name mode definition-ns str) rest))
  /cast args cons constructor-name args
    err.\-qq[Not enough arguments to isa]
  /cast args cons val args
    err.\-qq[Not enough arguments to isa]
  /cast args nil
    err.\-qq[Too many arguments to isa]
  /cast constructor-name stx - constructor-name
    err.\-qq[Expected a constructor-name value of type stx]
  /cast s-expr-to-maybe-name.constructor-name yep constructor-name
    err.\-qq[
      Expected a constructor-name value of type foreign or istring-nil
      ]
  /let constructor-name
    (constructor-name mode definition-ns constructor-name)
  /let projection-list
    (procure-defined mode
    /ns-get-string str.projection-names
    /ns-get-name constructor-name
    /ns-get-string str.constructors definition-ns)
  /compile mode (ns-get-string str.body unique-ns) definition-ns
  /c s /c mac str.case /cons subject
  /cons (c s /foreign constructor-name)
  /append
    (map projection-list /fn projection-name
      (ns-get-string projection-name
      /ns-get-string str.ignored unique-ns))
  \ TODO: Either stop depending on `yep`, `nope`, and `nil` macros
  \ here, or implement those as builtins.
  /cons (c mac str.yep /cons (c mac str.nil /nil) /nil)
  /cons (c mac str.nope /cons (c mac str.nil /nil) /nil) /nil))

(defn core-mac-proj1 mode unique-ns definition-ns my-stx-details args
  (let s (fn it /stx my-stx-details it)
  /let mac
    (fn str rest
      (cons (c s /foreign/macro-name mode definition-ns str) rest))
  /cast args cons constructor-name args
    err.\-qq[Not enough arguments to proj1]
  /cast args cons val args
    err.\-qq[Not enough arguments to proj1]
  /cast args nil
    err.\-qq[Too many arguments to proj1]
  /compile mode unique-ns definition-ns
  /c s /c mac str.case /cons val
  /cons constructor-name /cons (c s /istring-nil str.val)
  /cons (c s /istring-nil str.val)
  /cons
    (c mac str.err
    /cons (c s /istring-nil str.\-qq[Internal error]) /nil)
  /nil))

\ TODO: Write the `(defn ...)` macro, which should run the desugarer
\ defined in this file so that the next-outer metacircular interpreter
\ doesn't have to.
